//! Asynchronous signal handling for the maniac runtime.
//!
//! This module provides cross-platform async signal handling with platform-specific
//! extensions for Unix and Windows.
//!
//! # Cross-Platform API
//!
//! The core API provides a unified interface for common signals:
//!
//! ```no_run
//! use maniac::signal::{ctrl_c, signal, SignalKind};
//!
//! #[maniac::main]
//! async fn main() -> std::io::Result<()> {
//!     // Simple Ctrl+C handling
//!     ctrl_c().await?;
//!     println!("Received Ctrl+C");
//!
//!     // Or create a signal listener
//!     let mut sig = signal(SignalKind::terminate())?;
//!     sig.recv().await;
//!     println!("Received terminate signal");
//!     Ok(())
//! }
//! ```
//!
//! # Platform-Specific Extensions
//!
//! For platform-specific signals, use the `unix` or `windows` submodules:
//!
//! ```no_run
//! #[cfg(unix)]
//! use maniac::signal::unix::{signal, SignalKind};
//!
//! #[cfg(unix)]
//! #[maniac::main]
//! async fn main() -> std::io::Result<()> {
//!     let mut sighup = signal(SignalKind::hangup())?;
//!     sighup.recv().await;
//!     println!("Received SIGHUP");
//!     Ok(())
//! }
//! ```

mod registry;
mod signal;

#[cfg(unix)]
pub mod unix;

#[cfg(windows)]
pub mod windows;

pub use self::signal::Signal;

use std::io;

/// Represents the kind of signal to listen for.
///
/// This enum provides a cross-platform abstraction over OS signals.
/// For platform-specific signals, use the `unix` or `windows` submodules.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SignalKind(i32);

impl SignalKind {
    /// Creates a `SignalKind` from a raw signal number.
    ///
    /// # Platform Behavior
    ///
    /// - On Unix: This is the signal number (e.g., `libc::SIGTERM`)
    /// - On Windows: This is the control event type
    pub const fn from_raw(signum: i32) -> Self {
        SignalKind(signum)
    }

    /// Returns the raw signal number.
    pub const fn as_raw(self) -> i32 {
        self.0
    }

    /// Represents the interrupt signal (SIGINT on Unix, CTRL_C_EVENT on Windows).
    ///
    /// This is typically generated by pressing Ctrl+C.
    #[cfg(unix)]
    pub const fn interrupt() -> Self {
        SignalKind(libc::SIGINT)
    }

    /// Represents the interrupt signal (SIGINT on Unix, CTRL_C_EVENT on Windows).
    ///
    /// This is typically generated by pressing Ctrl+C.
    #[cfg(windows)]
    pub const fn interrupt() -> Self {
        SignalKind(windows_sys::Win32::System::Console::CTRL_C_EVENT as i32)
    }

    /// Represents the terminate signal (SIGTERM on Unix).
    ///
    /// This is the default signal sent by the `kill` command.
    ///
    /// # Platform Behavior
    ///
    /// On Windows, this maps to CTRL_CLOSE_EVENT which is sent when the
    /// console window is closed.
    #[cfg(unix)]
    pub const fn terminate() -> Self {
        SignalKind(libc::SIGTERM)
    }

    /// Represents the terminate signal.
    ///
    /// On Windows, this maps to CTRL_CLOSE_EVENT which is sent when the
    /// console window is closed.
    #[cfg(windows)]
    pub const fn terminate() -> Self {
        SignalKind(windows_sys::Win32::System::Console::CTRL_CLOSE_EVENT as i32)
    }
}

/// Creates a new signal listener for the specified signal kind.
///
/// # Errors
///
/// Returns an error if the signal handler cannot be registered.
///
/// # Examples
///
/// ```no_run
/// use maniac::signal::{signal, SignalKind};
///
/// #[maniac::main]
/// async fn main() -> std::io::Result<()> {
///     let mut sig = signal(SignalKind::terminate())?;
///     sig.recv().await;
///     println!("Received signal");
///     Ok(())
/// }
/// ```
pub fn signal(kind: SignalKind) -> io::Result<Signal> {
    Signal::new(kind)
}

/// Completes when a Ctrl+C signal is received.
///
/// This is a convenience function equivalent to:
/// ```ignore
/// signal(SignalKind::interrupt())?.recv().await
/// ```
///
/// # Errors
///
/// Returns an error if the signal handler cannot be registered.
///
/// # Examples
///
/// ```no_run
/// use maniac::signal::ctrl_c;
///
/// #[maniac::main]
/// async fn main() -> std::io::Result<()> {
///     println!("Press Ctrl+C to exit");
///     ctrl_c().await?;
///     println!("Received Ctrl+C, exiting");
///     Ok(())
/// }
/// ```
pub async fn ctrl_c() -> io::Result<()> {
    let mut sig = signal(SignalKind::interrupt())?;
    sig.recv().await;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_kind_raw() {
        let kind = SignalKind::from_raw(42);
        assert_eq!(kind.as_raw(), 42);
    }

    #[cfg(unix)]
    #[test]
    fn test_signal_kind_interrupt_unix() {
        assert_eq!(SignalKind::interrupt().as_raw(), libc::SIGINT);
    }

    #[cfg(unix)]
    #[test]
    fn test_signal_kind_terminate_unix() {
        assert_eq!(SignalKind::terminate().as_raw(), libc::SIGTERM);
    }
}
