/* automatically generated by rust-bindgen 0.72.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 1;
pub const _HAS_CXX20: u32 = 1;
pub const _HAS_CXX23: u32 = 1;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 1;
pub const _CRT_HAS_C11: u32 = 0;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIdMAX: &[u8; 4] = b"lld\0";
pub const PRIdPTR: &[u8; 4] = b"lld\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIiMAX: &[u8; 4] = b"lli\0";
pub const PRIiPTR: &[u8; 4] = b"lli\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIoMAX: &[u8; 4] = b"llo\0";
pub const PRIoPTR: &[u8; 4] = b"llo\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIuMAX: &[u8; 4] = b"llu\0";
pub const PRIuPTR: &[u8; 4] = b"llu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIxMAX: &[u8; 4] = b"llx\0";
pub const PRIxPTR: &[u8; 4] = b"llx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIXMAX: &[u8; 4] = b"llX\0";
pub const PRIXPTR: &[u8; 4] = b"llX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNdMAX: &[u8; 4] = b"lld\0";
pub const SCNdPTR: &[u8; 4] = b"lld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNiMAX: &[u8; 4] = b"lli\0";
pub const SCNiPTR: &[u8; 4] = b"lli\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNoMAX: &[u8; 4] = b"llo\0";
pub const SCNoPTR: &[u8; 4] = b"llo\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNuMAX: &[u8; 4] = b"llu\0";
pub const SCNuPTR: &[u8; 4] = b"llu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNxMAX: &[u8; 4] = b"llx\0";
pub const SCNxPTR: &[u8; 4] = b"llx\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STL_COMPILER_PREPROCESSOR: u32 = 1;
pub const _STL_WARNING_LEVEL: u32 = 3;
pub const _CPPLIB_VER: u32 = 650;
pub const _MSVC_STL_VERSION: u32 = 143;
pub const _MSVC_STL_UPDATE: u32 = 202503;
pub const _HAS_STATIC_RTTI: u32 = 1;
pub const _HAS_STD_BYTE: u32 = 1;
pub const _ENFORCE_MATCHING_ALLOCATORS: u32 = 1;
pub const _ENFORCE_FACET_SPECIALIZATIONS: u32 = 0;
pub const _FACET_SPECIALIZATION_MESSAGE : & [u8 ; 167] = b"Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 to suppress this error.\0" ;
pub const _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS: u32 = 1;
pub const _STD_VECTORIZE_WITH_FLOAT_CONTROL: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_freestanding_algorithm: u32 = 202311;
pub const __cpp_lib_freestanding_array: u32 = 202311;
pub const __cpp_lib_freestanding_char_traits: u32 = 202306;
pub const __cpp_lib_freestanding_cstdlib: u32 = 202306;
pub const __cpp_lib_freestanding_cstring: u32 = 202311;
pub const __cpp_lib_freestanding_cwchar: u32 = 202306;
pub const __cpp_lib_freestanding_errc: u32 = 202306;
pub const __cpp_lib_freestanding_feature_test_macros: u32 = 202306;
pub const __cpp_lib_freestanding_functional: u32 = 202306;
pub const __cpp_lib_freestanding_iterator: u32 = 202306;
pub const __cpp_lib_freestanding_memory: u32 = 202306;
pub const __cpp_lib_freestanding_operator_new: u32 = 202306;
pub const __cpp_lib_freestanding_ratio: u32 = 202306;
pub const __cpp_lib_freestanding_tuple: u32 = 202306;
pub const __cpp_lib_freestanding_utility: u32 = 202306;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_shared_mutex: u32 = 201505;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_any: u32 = 201606;
pub const __cpp_lib_apply: u32 = 201603;
pub const __cpp_lib_atomic_is_always_lock_free: u32 = 201603;
pub const __cpp_lib_boyer_moore_searcher: u32 = 201603;
pub const __cpp_lib_byte: u32 = 201603;
pub const __cpp_lib_clamp: u32 = 201603;
pub const __cpp_lib_filesystem: u32 = 201703;
pub const __cpp_lib_freestanding_charconv: u32 = 202306;
pub const __cpp_lib_freestanding_optional: u32 = 202311;
pub const __cpp_lib_freestanding_string_view: u32 = 202311;
pub const __cpp_lib_freestanding_variant: u32 = 202311;
pub const __cpp_lib_gcd_lcm: u32 = 201606;
pub const __cpp_lib_hardware_interference_size: u32 = 201703;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_hypot: u32 = 201603;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_launder: u32 = 201606;
pub const __cpp_lib_make_from_tuple: u32 = 201606;
pub const __cpp_lib_math_special_functions: u32 = 201603;
pub const __cpp_lib_memory_resource: u32 = 201603;
pub const __cpp_lib_node_extract: u32 = 201606;
pub const __cpp_lib_not_fn: u32 = 201603;
pub const __cpp_lib_parallel_algorithm: u32 = 201603;
pub const __cpp_lib_raw_memory_algorithms: u32 = 201606;
pub const __cpp_lib_sample: u32 = 201603;
pub const __cpp_lib_scoped_lock: u32 = 201703;
pub const __cpp_lib_shared_ptr_weak_type: u32 = 201606;
pub const __cpp_lib_string_view: u32 = 201803;
pub const __cpp_lib_to_chars: u32 = 201611;
pub const __cpp_lib_atomic_value_initialization: u32 = 201911;
pub const __cpp_lib_char8_t: u32 = 201907;
pub const __cpp_lib_coroutine: u32 = 201902;
pub const __cpp_lib_algorithm_iterator_requirements: u32 = 202207;
pub const __cpp_lib_assume_aligned: u32 = 201811;
pub const __cpp_lib_atomic_flag_test: u32 = 201907;
pub const __cpp_lib_atomic_float: u32 = 201711;
pub const __cpp_lib_atomic_lock_free_type_aliases: u32 = 201907;
pub const __cpp_lib_atomic_ref: u32 = 201806;
pub const __cpp_lib_atomic_shared_ptr: u32 = 201711;
pub const __cpp_lib_atomic_wait: u32 = 201907;
pub const __cpp_lib_barrier: u32 = 202302;
pub const __cpp_lib_bind_front: u32 = 201907;
pub const __cpp_lib_bit_cast: u32 = 201806;
pub const __cpp_lib_bitops: u32 = 201907;
pub const __cpp_lib_bounded_array_traits: u32 = 201902;
pub const __cpp_lib_common_reference: u32 = 202302;
pub const __cpp_lib_common_reference_wrapper: u32 = 202302;
pub const __cpp_lib_constexpr_algorithms: u32 = 201806;
pub const __cpp_lib_constexpr_complex: u32 = 201711;
pub const __cpp_lib_constexpr_dynamic_alloc: u32 = 201907;
pub const __cpp_lib_constexpr_functional: u32 = 201907;
pub const __cpp_lib_constexpr_iterator: u32 = 201811;
pub const __cpp_lib_constexpr_numeric: u32 = 201911;
pub const __cpp_lib_constexpr_string: u32 = 201907;
pub const __cpp_lib_constexpr_string_view: u32 = 201811;
pub const __cpp_lib_constexpr_tuple: u32 = 201811;
pub const __cpp_lib_constexpr_utility: u32 = 201811;
pub const __cpp_lib_constexpr_vector: u32 = 201907;
pub const __cpp_lib_destroying_delete: u32 = 201806;
pub const __cpp_lib_endian: u32 = 201907;
pub const __cpp_lib_erase_if: u32 = 202002;
pub const __cpp_lib_format: u32 = 202304;
pub const __cpp_lib_format_uchar: u32 = 202311;
pub const __cpp_lib_freestanding_ranges: u32 = 202306;
pub const __cpp_lib_generic_unordered_lookup: u32 = 201811;
pub const __cpp_lib_int_pow2: u32 = 202002;
pub const __cpp_lib_integer_comparison_functions: u32 = 202002;
pub const __cpp_lib_interpolate: u32 = 201902;
pub const __cpp_lib_is_constant_evaluated: u32 = 201811;
pub const __cpp_lib_is_nothrow_convertible: u32 = 201806;
pub const __cpp_lib_jthread: u32 = 201911;
pub const __cpp_lib_latch: u32 = 201907;
pub const __cpp_lib_list_remove_return_type: u32 = 201806;
pub const __cpp_lib_math_constants: u32 = 201907;
pub const __cpp_lib_move_iterator_concept: u32 = 202207;
pub const __cpp_lib_polymorphic_allocator: u32 = 201902;
pub const __cpp_lib_remove_cvref: u32 = 201711;
pub const __cpp_lib_semaphore: u32 = 201907;
pub const __cpp_lib_smart_ptr_for_overwrite: u32 = 202002;
pub const __cpp_lib_source_location: u32 = 201907;
pub const __cpp_lib_span: u32 = 202002;
pub const __cpp_lib_ssize: u32 = 201902;
pub const __cpp_lib_starts_ends_with: u32 = 201711;
pub const __cpp_lib_syncbuf: u32 = 201803;
pub const __cpp_lib_three_way_comparison: u32 = 201907;
pub const __cpp_lib_to_address: u32 = 201711;
pub const __cpp_lib_to_array: u32 = 201907;
pub const __cpp_lib_type_identity: u32 = 201806;
pub const __cpp_lib_unwrap_ref: u32 = 201811;
pub const __cpp_lib_adaptor_iterator_pair_constructor: u32 = 202106;
pub const __cpp_lib_allocate_at_least: u32 = 202302;
pub const __cpp_lib_associative_heterogeneous_erasure: u32 = 202110;
pub const __cpp_lib_bind_back: u32 = 202202;
pub const __cpp_lib_byteswap: u32 = 202110;
pub const __cpp_lib_constexpr_bitset: u32 = 202207;
pub const __cpp_lib_constexpr_charconv: u32 = 202207;
pub const __cpp_lib_constexpr_typeinfo: u32 = 202106;
pub const __cpp_lib_containers_ranges: u32 = 202202;
pub const __cpp_lib_expected: u32 = 202211;
pub const __cpp_lib_format_ranges: u32 = 202207;
pub const __cpp_lib_formatters: u32 = 202302;
pub const __cpp_lib_forward_like: u32 = 202207;
pub const __cpp_lib_freestanding_expected: u32 = 202311;
pub const __cpp_lib_freestanding_mdspan: u32 = 202311;
pub const __cpp_lib_generator: u32 = 202207;
pub const __cpp_lib_invoke_r: u32 = 202106;
pub const __cpp_lib_ios_noreplace: u32 = 202207;
pub const __cpp_lib_is_scoped_enum: u32 = 202011;
pub const __cpp_lib_mdspan: u32 = 202207;
pub const __cpp_lib_move_only_function: u32 = 202110;
pub const __cpp_lib_out_ptr: u32 = 202311;
pub const __cpp_lib_print: u32 = 202406;
pub const __cpp_lib_ranges_as_const: u32 = 202311;
pub const __cpp_lib_ranges_as_rvalue: u32 = 202207;
pub const __cpp_lib_ranges_cartesian_product: u32 = 202207;
pub const __cpp_lib_ranges_chunk: u32 = 202202;
pub const __cpp_lib_ranges_chunk_by: u32 = 202202;
pub const __cpp_lib_ranges_contains: u32 = 202207;
pub const __cpp_lib_ranges_enumerate: u32 = 202302;
pub const __cpp_lib_ranges_find_last: u32 = 202207;
pub const __cpp_lib_ranges_fold: u32 = 202207;
pub const __cpp_lib_ranges_iota: u32 = 202202;
pub const __cpp_lib_ranges_join_with: u32 = 202202;
pub const __cpp_lib_ranges_repeat: u32 = 202207;
pub const __cpp_lib_ranges_slide: u32 = 202202;
pub const __cpp_lib_ranges_starts_ends_with: u32 = 202106;
pub const __cpp_lib_ranges_stride: u32 = 202207;
pub const __cpp_lib_ranges_to_container: u32 = 202202;
pub const __cpp_lib_ranges_zip: u32 = 202110;
pub const __cpp_lib_spanstream: u32 = 202106;
pub const __cpp_lib_stacktrace: u32 = 202011;
pub const __cpp_lib_stdatomic_h: u32 = 202011;
pub const __cpp_lib_string_contains: u32 = 202011;
pub const __cpp_lib_string_resize_and_overwrite: u32 = 202110;
pub const __cpp_lib_to_underlying: u32 = 202102;
pub const __cpp_lib_tuple_like: u32 = 202207;
pub const __cpp_lib_unreachable: u32 = 202202;
pub const __cpp_lib_array_constexpr: u32 = 201811;
pub const __cpp_lib_chrono: u32 = 201907;
pub const __cpp_lib_concepts: u32 = 202207;
pub const __cpp_lib_constexpr_memory: u32 = 202202;
pub const __cpp_lib_execution: u32 = 201902;
pub const __cpp_lib_optional: u32 = 202110;
pub const __cpp_lib_ranges: u32 = 202406;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201707;
pub const __cpp_lib_shift: u32 = 202202;
pub const __cpp_lib_variant: u32 = 202106;
pub const __cpp_lib_experimental_filesystem: u32 = 201406;
pub const _USE_EXTERN_CXX_EVERYWHERE_FOR_STL: u32 = 1;
pub const _STL_WIN32_WINNT_VISTA: u32 = 1536;
pub const _STL_WIN32_WINNT_WIN7: u32 = 1537;
pub const _STL_WIN32_WINNT_WIN8: u32 = 1538;
pub const _STL_WIN32_WINNT_WIN10: u32 = 2560;
pub const _STL_WIN32_WINNT: u32 = 1537;
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo();
}
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
unsafe extern "C" {
    pub fn _invoke_watson(
        _Expression: *const u16,
        _FunctionName: *const u16,
        _FileName: *const u16,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
pub type imaxdiv_t = _Lldiv_t;
unsafe extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn _wcstoimax_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn _wcstoumax_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type std_integral_constant_value_type<_Ty> = _Ty;
pub type std_integral_constant_type = u8;
pub type std_bool_constant = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std_enable_if_t = u8;
pub type std_conditional_type<_Ty1> = _Ty1;
pub type std_conditional_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Ty> = _Ty;
pub type std_remove_const_t = std_remove_const;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Ty> = _Ty;
pub type std_remove_volatile_t = std_remove_volatile;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Ty> = _Ty;
pub type std_remove_cv__Apply = u8;
pub type std_remove_cv_t = std_remove_cv;
pub type std__Disjunction_type<_First> = _First;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_disjunction {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Ty> = _Ty;
pub type std_remove_reference__Const_thru_ref_type<_Ty> = _Ty;
pub type std_remove_reference_t = std_remove_reference;
pub type std__Const_thru_ref = std_remove_reference;
pub type std__Remove_cvref_t = std_remove_cv_t;
pub type std_remove_cvref_t = std__Remove_cvref_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_cvref {
    pub _address: u8,
}
pub type std_remove_cvref_type = std_remove_cvref_t;
pub type std_max_align_t = f64;
pub type std_byte = ::std::os::raw::c_uchar;
pub type max_align_t = f64;
unsafe extern "C" {
    pub fn bop_alloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_zalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_calloc(element_size: usize, count: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_alloc_aligned(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_zalloc_aligned(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_realloc(
        p: *mut ::std::os::raw::c_void,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_dealloc(p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn bop_dealloc_sized(p: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    pub fn bop_heap_access(data: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    pub fn bop_malloc_usable_size(data: *const ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    pub fn bop_size_of_shared_ptr() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_buffer_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_buffer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_buffer_new(size: usize) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_free(buf: *mut bop_raft_buffer);
}
unsafe extern "C" {
    pub fn bop_raft_buffer_data(buf: *mut bop_raft_buffer) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_container_size(buf: *mut bop_raft_buffer) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_size(buf: *mut bop_raft_buffer) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_pos(buf: *mut bop_raft_buffer) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_set_pos(buf: *mut bop_raft_buffer, pos: usize);
}
pub type bop_raft_async_bool_when_ready = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        result: bool,
        error: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_async_bool_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_make(
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_bool_when_ready,
    ) -> *mut bop_raft_async_bool_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_delete(self_: *const bop_raft_async_bool_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_get_user_data(
        self_: *const bop_raft_async_bool_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_set_user_data(
        self_: *mut bop_raft_async_bool_ptr,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_get_when_ready(
        self_: *const bop_raft_async_bool_ptr,
    ) -> bop_raft_async_bool_when_ready;
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_set_when_ready(
        self_: *mut bop_raft_async_bool_ptr,
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_bool_when_ready,
    );
}
pub type bop_raft_async_u64_when_ready = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        result: u64,
        error: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_async_u64_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_make(
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_u64_when_ready,
    ) -> *mut bop_raft_async_u64_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_delete(self_: *const bop_raft_async_u64_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_get_user_data(
        self_: *const bop_raft_async_u64_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_set_user_data(
        self_: *mut bop_raft_async_u64_ptr,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_get_when_ready(
        self_: *const bop_raft_async_u64_ptr,
    ) -> bop_raft_async_u64_when_ready;
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_set_when_ready(
        self_: *mut bop_raft_async_u64_ptr,
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_u64_when_ready,
    );
}
#[doc = "\n nuraft::cmd_result<nuraft::ptr<nuraft::buffer>>\n"]
pub type bop_raft_async_buffer_when_ready = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        result: *mut bop_raft_buffer,
        error: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_async_buffer_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_make(
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_buffer_when_ready,
    ) -> *mut bop_raft_async_buffer_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_delete(self_: *const bop_raft_async_buffer_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_get_user_data(
        self_: *const bop_raft_async_buffer_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_set_user_data(
        self_: *mut bop_raft_async_buffer_ptr,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_get_when_ready(
        self_: *const bop_raft_async_buffer_ptr,
    ) -> bop_raft_async_buffer_when_ready;
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_set_when_ready(
        self_: *mut bop_raft_async_buffer_ptr,
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_buffer_when_ready,
    );
}
#[doc = "\n nuraft::snapshot\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_snapshot {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_snapshot_serialize(snapshot: *mut bop_raft_snapshot) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_snapshot_deserialize(buf: *mut bop_raft_buffer) -> *mut bop_raft_snapshot;
}
#[doc = "\n nuraft::cluster_config\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cluster_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cluster_config_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_config {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_new() -> *mut bop_raft_cluster_config;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_ptr_make(
        config: *mut bop_raft_cluster_config,
    ) -> *mut bop_raft_cluster_config_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_free(config: *const bop_raft_cluster_config);
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_ptr_delete(config: *const bop_raft_cluster_config_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_ptr_get(
        conf: *mut bop_raft_cluster_config_ptr,
    ) -> *mut bop_raft_cluster_config;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_serialize(
        conf: *mut bop_raft_cluster_config,
    ) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_deserialize(
        buf: *mut bop_raft_buffer,
    ) -> *mut bop_raft_cluster_config;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_log_idx(cfg: *mut bop_raft_cluster_config) -> u64;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_prev_log_idx(cfg: *mut bop_raft_cluster_config) -> u64;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_is_async_replication(cfg: *mut bop_raft_cluster_config) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_user_ctx(
        cfg: *mut bop_raft_cluster_config,
        out_data: *mut ::std::os::raw::c_char,
        out_data_size: usize,
    );
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_user_ctx_size(cfg: *mut bop_raft_cluster_config) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_servers_size(cfg: *mut bop_raft_cluster_config) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_server(
        cfg: *mut bop_raft_cluster_config,
        idx: i32,
    ) -> *mut bop_raft_srv_config;
}
#[doc = "\n bop_raft_srv_config\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_config_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_config_vec {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_make() -> *mut bop_raft_srv_config_vec;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_delete(vec: *const bop_raft_srv_config_vec);
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_size(vec: *mut bop_raft_srv_config_vec) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_get(
        vec: *mut bop_raft_srv_config_vec,
        idx: usize,
    ) -> *mut bop_raft_srv_config;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_ptr_make(
        config: *mut bop_raft_srv_config,
    ) -> *mut bop_raft_srv_config_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_ptr_delete(config: *const bop_raft_srv_config_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_make(
        id: i32,
        dc_id: i32,
        endpoint: *const ::std::os::raw::c_char,
        endpoint_size: usize,
        aux: *const ::std::os::raw::c_char,
        aux_size: usize,
        learner: bool,
        priority: i32,
    ) -> *mut bop_raft_srv_config;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_delete(config: *const bop_raft_srv_config);
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_id(cfg: *mut bop_raft_srv_config) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_dc_id(cfg: *mut bop_raft_srv_config) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_endpoint(
        cfg: *mut bop_raft_srv_config,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_endpoint_size(cfg: *mut bop_raft_srv_config) -> usize;
}
unsafe extern "C" {
    #[doc = " Custom string given by user.\n WARNING: It SHOULD NOT contain NULL character,\n          as\n it will be stored as a C-style string."]
    pub fn bop_raft_srv_config_aux(cfg: *mut bop_raft_srv_config) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_aux_size(cfg: *mut bop_raft_srv_config) -> usize;
}
unsafe extern "C" {
    #[doc = " `true` if this node is learner.\n Learner will not initiate or participate in leader\n election."]
    pub fn bop_raft_srv_config_is_learner(cfg: *mut bop_raft_srv_config) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_set_is_learner(cfg: *mut bop_raft_srv_config, learner: bool);
}
unsafe extern "C" {
    #[doc = " `true` if this node is a new joiner, but not yet fully synced.\n New joiner will not\n initiate or participate in leader election."]
    pub fn bop_raft_srv_config_is_new_joiner(cfg: *mut bop_raft_srv_config) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_set_new_joiner(cfg: *mut bop_raft_srv_config, new_joiner: bool);
}
unsafe extern "C" {
    #[doc = " Priority of this node.\n 0 will never be a leader."]
    pub fn bop_raft_srv_config_priority(cfg: *mut bop_raft_srv_config) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_set_priority(cfg: *mut bop_raft_srv_config, priority: i32);
}
#[doc = "\n nuraft::svr_state\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_state {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_srv_state_serialize(state: *mut bop_raft_srv_state) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_srv_state_deserialize(buf: *mut bop_raft_buffer) -> *mut bop_raft_srv_state;
}
unsafe extern "C" {
    pub fn bop_raft_srv_state_delete(state: *const bop_raft_srv_state);
}
unsafe extern "C" {
    #[doc = " Term"]
    pub fn bop_raft_srv_state_term(state: *const bop_raft_srv_state) -> u64;
}
unsafe extern "C" {
    #[doc = " Server ID that this server voted for.\n `-1` if not voted."]
    pub fn bop_raft_srv_state_voted_for(state: *const bop_raft_srv_state) -> i32;
}
unsafe extern "C" {
    #[doc = " `true` if election timer is allowed."]
    pub fn bop_raft_srv_state_is_election_timer_allowed(state: *const bop_raft_srv_state) -> bool;
}
unsafe extern "C" {
    #[doc = " true if this server has joined the cluster but has not yet\n fully caught up with the latest\n log. While in the catch-up status,\n this server will not receive normal append_entries\n requests."]
    pub fn bop_raft_srv_state_is_catching_up(state: *const bop_raft_srv_state) -> bool;
}
unsafe extern "C" {
    #[doc = " `true` if this server is receiving a snapshot.\n Same as `catching_up_`, it must be a\n durable flag so as not to be\n reset after restart. While this flag is set, this server will\n neither\n receive normal append_entries requests nor initiate election."]
    pub fn bop_raft_srv_state_is_receiving_snapshot(state: *const bop_raft_srv_state) -> bool;
}
#[doc = "\n nuraft::logger\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_logger_ptr {
    _unused: [u8; 0],
}
#[doc = " Put a log with level, line number, function name,\n and file name.\n\n Log level info:\n\n Trace:    6\n    Debug:    5\n    Info:     4\n    Warning:  3\n    Error:    2\n    Fatal:\n 1\n\n @param level Level of given log.\n @param source_file Name of file where the log is\n located.\n @param func_name Name of function where the log is located.\n @param line_number\n Line number of the log.\n @param log_line Contents of the log."]
pub type bop_raft_logger_put_details_func = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        level: i32,
        source_file: *const ::std::os::raw::c_char,
        func_name: *const ::std::os::raw::c_char,
        line_number: usize,
        log_line: *const ::std::os::raw::c_char,
        log_line_size: usize,
    ),
>;
unsafe extern "C" {
    pub fn bop_raft_logger_make(
        user_data: *mut ::std::os::raw::c_void,
        callback: bop_raft_logger_put_details_func,
    ) -> *mut bop_raft_logger_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_logger_delete(logger: *const bop_raft_logger_ptr);
}
#[doc = "\n nuraft::asio_service\n"]
pub type bop_raft_asio_service_worker_start_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, value: u32)>;
pub type bop_raft_asio_service_worker_stop_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, value: u32)>;
pub type bop_raft_asio_service_verify_sn_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSL_CTX {
    _unused: [u8; 0],
}
pub type bop_raft_asio_service_ssl_ctx_provider_fn = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut SSL_CTX,
>;
pub type bop_raft_asio_service_custom_resolver_response_fn = ::std::option::Option<
    unsafe extern "C" fn(
        response_impl: *mut ::std::os::raw::c_void,
        v1: *const ::std::os::raw::c_char,
        v1_size: usize,
        v2: *const ::std::os::raw::c_char,
        v2_size: usize,
        error_code: i32,
    ),
>;
pub type bop_raft_asio_service_custom_resolver_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        response_impl: *mut ::std::os::raw::c_void,
        v1: *const ::std::os::raw::c_char,
        v1_size: usize,
        v2: *const ::std::os::raw::c_char,
        v2_size: usize,
        response: bop_raft_asio_service_custom_resolver_response_fn,
    ),
>;
pub type bop_raft_asio_service_corrupted_msg_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        header: *mut ::std::os::raw::c_uchar,
        header_size: usize,
        payload: *mut ::std::os::raw::c_uchar,
        payload_size: usize,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_asio_service_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_asio_options {
    pub thread_pool_size: usize,
    pub worker_start_user_data: *mut ::std::os::raw::c_void,
    pub worker_start: bop_raft_asio_service_worker_start_fn,
    pub worker_stop_user_data: *mut ::std::os::raw::c_void,
    pub worker_stop: bop_raft_asio_service_worker_stop_fn,
    pub enable_ssl: bool,
    pub skip_verification: bool,
    pub server_cert_file: *mut ::std::os::raw::c_char,
    pub server_key_file: *mut ::std::os::raw::c_char,
    pub root_cert_file: *mut ::std::os::raw::c_char,
    pub invoke_req_cb_on_empty_meta: bool,
    pub invoke_resp_cb_on_empty_meta: bool,
    pub verify_sn_user_data: *mut ::std::os::raw::c_void,
    pub verify_sn: bop_raft_asio_service_verify_sn_fn,
    pub ssl_context_provider_server_user_data: *mut ::std::os::raw::c_void,
    pub ssl_context_provider_server: bop_raft_asio_service_ssl_ctx_provider_fn,
    pub ssl_context_provider_client_user_data: *mut ::std::os::raw::c_void,
    pub ssl_context_provider_client: bop_raft_asio_service_ssl_ctx_provider_fn,
    pub custom_resolver_user_data: *mut ::std::os::raw::c_void,
    pub custom_resolver: bop_raft_asio_service_custom_resolver_fn,
    pub replicate_log_timestamp: bool,
    pub crc_on_entire_message: bool,
    pub crc_on_payload: bool,
    pub corrupted_msg_handler_user_data: *mut ::std::os::raw::c_void,
    pub corrupted_msg_handler: bop_raft_asio_service_corrupted_msg_handler_fn,
    pub streaming_mode: bool,
}
impl Default for bop_raft_asio_options {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_make(
        options: *mut bop_raft_asio_options,
        logger: *mut bop_raft_logger_ptr,
    ) -> *mut bop_raft_asio_service_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_delete(asio_service: *const bop_raft_asio_service_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_stop(asio_service: *mut bop_raft_asio_service_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_get_active_workers(
        asio_service: *mut bop_raft_asio_service_ptr,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_delayed_task_ptr {
    _unused: [u8; 0],
}
pub type bop_raft_delayed_task_func =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn bop_raft_delayed_task_make(
        user_data: *mut ::std::os::raw::c_void,
        type_: i32,
        exec_func: bop_raft_delayed_task_func,
        deleter_func: bop_raft_delayed_task_func,
    ) -> *mut bop_raft_delayed_task_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_delete(task: *const bop_raft_delayed_task_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_cancel(task: *mut bop_raft_delayed_task_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_reset(task: *mut bop_raft_delayed_task_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_type(task: *mut bop_raft_delayed_task_ptr) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_user_data(
        task: *mut bop_raft_delayed_task_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_schedule(
        asio_service: *mut bop_raft_asio_service_ptr,
        delayed_task: *mut bop_raft_delayed_task_ptr,
        milliseconds: i32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_rpc_listener_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_listener_make(
        asio_service: *mut bop_raft_asio_service_ptr,
        listening_port: u16,
        logger: *mut bop_raft_logger_ptr,
    ) -> *mut bop_raft_rpc_listener_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_listener_delete(rpc_listener: *const bop_raft_rpc_listener_ptr);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_rpc_client_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_client_make(
        asio_service: *mut bop_raft_asio_service_ptr,
        endpoint: *const ::std::os::raw::c_char,
        endpoint_size: usize,
    ) -> *mut bop_raft_rpc_client_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_client_delete(rpc_client: *const bop_raft_rpc_client_ptr);
}
pub const bop_raft_params_locking_method_type_bop_raft_params_locking_method_single_mutex:
    bop_raft_params_locking_method_type = 0;
pub const bop_raft_params_locking_method_type_bop_raft_params_locking_method_dual_mutex:
    bop_raft_params_locking_method_type = 1;
pub const bop_raft_params_locking_method_type_bop_raft_params_locking_method_dual_rw_mutex:
    bop_raft_params_locking_method_type = 2;
#[doc = "\n nuraft::raft_params\n"]
pub type bop_raft_params_locking_method_type = i32;
pub const bop_raft_params_return_method_type_bop_raft_params_return_method_blocking:
    bop_raft_params_return_method_type = 0;
pub const bop_raft_params_return_method_type_bop_raft_params_return_method_async_handler:
    bop_raft_params_return_method_type = 1;
pub type bop_raft_params_return_method_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_params {
    #[doc = " Upper bound of election timer, in millisecond."]
    pub election_timeout_upper_bound: i32,
    #[doc = " Lower bound of election timer, in millisecond."]
    pub election_timeout_lower_bound: i32,
    #[doc = " Heartbeat interval, in millisecond."]
    pub heart_beat_interval: i32,
    #[doc = " Backoff time when RPC failure happens, in millisecond."]
    pub rpc_failure_backoff: i32,
    #[doc = " Max number of logs that can be packed in a RPC\n for catch-up of joining an\n empty node."]
    pub log_sync_batch_size: i32,
    #[doc = " Log gap (the number of logs) to stop catch-up of\n joining a new node. Once this\n condition meets,\n that newly joined node is added to peer list\n and starts to\n receive heartbeat from leader.\n\n If zero, the new node will be added to the peer\n list\n immediately."]
    pub log_sync_stop_gap: i32,
    #[doc = " Log gap (the number of logs) to create a Raft snapshot."]
    pub snapshot_distance: i32,
    #[doc = " (Deprecated)."]
    pub snapshot_block_size: i32,
    #[doc = " Timeout(ms) for snapshot_sync_ctx, if a single snapshot syncing request\n\n exceeds this, it will be considered as timeout and ctx will be released.\n 0 means it\n will be set to the default value\n `heart_beat_interval_ * response_limit_`."]
    pub snapshot_sync_ctx_timeout: i32,
    #[doc = " Enable randomized snapshot creation which will avoid\n simultaneous snapshot\n creation among cluster members.\n It is achieved by randomizing the distance of the\n\n * first snapshot. From the second snapshot, the fixed\n distance given by\n snapshot_distance_ will be used."]
    pub enable_randomized_snapshot_creation: bool,
    #[doc = " Max number of logs that can be packed in a RPC\n for append entry request."]
    pub max_append_size: i32,
    #[doc = " Minimum number of logs that will be preserved\n (i.e., protected from log\n compaction) since the\n last Raft snapshot."]
    pub reserved_log_items: i32,
    #[doc = " Client request timeout in millisecond."]
    pub client_req_timeout: i32,
    #[doc = " Log gap (compared to the leader's latest log)\n for treating this node as\n fresh."]
    pub fresh_log_gap: i32,
    #[doc = " Log gap (compared to the leader's latest log)\n for treating this node as\n stale."]
    pub stale_log_gap: i32,
    #[doc = " Custom quorum size for commit.\n If set to zero, the default quorum size will be\n used."]
    pub custom_commit_quorum_size: i32,
    #[doc = " Custom quorum size for leader election.\n If set to zero, the default quorum\n size will be used."]
    pub custom_election_quorum_size: i32,
    #[doc = " Expiration time of leadership in millisecond.\n If more than quorum nodes do not\n respond within\n this time, the current leader will immediately\n yield its\n leadership and become follower.\n If 0, it is automatically set to `heartbeat * 20`.\n\n * If negative number, leadership will never be expired\n (the same as the original Raft\n logic)."]
    pub leadership_expiry: i32,
    #[doc = " Minimum wait time required for transferring the leadership\n in millisecond. If\n this value is non-zero, and the below\n conditions are met together,\n   - the\n elapsed time since this server became a leader\n     is longer than this number, and\n\n - the current leader's priority is not the highest one, and\n   - all peers are\n responding, and\n   - the log gaps of all peers are smaller than `stale_log_gap_`, and\n\n *   - `allow_leadership_transfer` of the state machine returns true,\n then the current\n leader will transfer its leadership to the peer\n with the highest priority."]
    pub leadership_transfer_min_wait_time: i32,
    #[doc = " If true, zero-priority member can initiate vote\n when leader is not elected\n long time (that can happen\n only the zero-priority member has the latest log).\n\n Once the zero-priority member becomes a leader,\n it will immediately yield leadership\n so that other\n higher priority node can takeover."]
    pub allow_temporary_zero_priority_leader: bool,
    #[doc = " If true, follower node will forward client request\n to the current leader.\n\n * Otherwise, it will return error to client immediately."]
    pub auto_forwarding: bool,
    #[doc = " The maximum number of connections for auto forwarding (if enabled)."]
    pub auto_forwarding_max_connections: i32,
    #[doc = " If true, creating replication (append_entries) requests will be\n done by a\n background thread, instead of doing it in user threads.\n There can be some delay a\n little bit, but it improves reducing\n the lock contention."]
    pub use_bg_thread_for_urgent_commit: bool,
    #[doc = " If true, a server who is currently receiving snapshot will not be\n counted in\n quorum. It is useful when there are only two servers\n in the cluster. Once the follower\n is receiving snapshot, the\n leader cannot make any progress."]
    pub exclude_snp_receiver_from_quorum: bool,
    #[doc = " If `true` and the size of the cluster is 2, the quorum size\n will be adjusted\n to 1 automatically, once one of two nodes\n becomes offline."]
    pub auto_adjust_quorum_for_small_cluster: bool,
    #[doc = " Choose the type of lock that will be used by user threads."]
    pub locking_method_type: bop_raft_params_locking_method_type,
    #[doc = " To choose blocking call or asynchronous call."]
    pub return_method: bop_raft_params_return_method_type,
    #[doc = " Wait ms for response after forwarding request to leader.\n must be larger than\n client_req_timeout_.\n If 0, there will be no timeout for auto forwarding."]
    pub auto_forwarding_req_timeout: i32,
    #[doc = " If non-zero, any server whose state machine's commit index is\n lagging behind\n the last committed log index will not\n initiate vote requests for the given amount of\n time\n in milliseconds.\n\n The purpose of this option is to avoid a server\n (whose state\n machine is still catching up with the committed logs and does\n not\n contain the latest data yet) being a leader."]
    pub grace_period_of_lagging_state_machine: i32,
    #[doc = " If `true`, the new joiner will be added to cluster config as a `new_joiner`\n\n even before syncing all data. The new joiner will not initiate a vote or\n participate\n in leader election.\n\n Once the log gap becomes smaller than `log_sync_stop_gap_`,\n the new joiner\n will be a regular member.\n\n The purpose of this featuer is\n to preserve the new joiner information\n even after leader re-election, in order to let\n the new leader continue\n the sync process without calling `add_srv` again."]
    pub use_new_joiner_type: bool,
    #[doc = " (Experimental)\n If `true`, reading snapshot objects will be done by a\n background thread\n asynchronously instead of synchronous read by Raft worker threads.\n\n * Asynchronous IO will reduce the overall latency of the leader's operations."]
    pub use_bg_thread_for_snapshot_io: bool,
    #[doc = " (Experimental)\n If `true`, it will commit a log upon the agreement of all\n healthy members.\n In other words, with this option, all healthy members have the log at\n the\n moment the leader commits the log. If the number of healthy members is\n\n smaller than the regular (or configured custom) quorum size, the leader\n cannot commit\n the log.\n\n A member becomes \"unhealthy\" if it does not respond to the leader's\n\n * request for a configured time (`response_limit_`)."]
    pub use_full_consensus_among_healthy_members: bool,
    #[doc = " (Experimental)\n If `true`, the leader will track the commit index of each peers' state machine.\n It can be used along with `use_full_consensus_among_healthy_members_`"]
    pub track_peers_sm_commit_idx: bool,
    #[doc = " (Experimental)\n If `true`, users can let the leader append logs parallel with\n their\n replication. To implement parallel log appending, users need to make\n\n `log_store::append`, `log_store::write_at`, or\n `log_store::end_of_append_batch` API\n triggers asynchronous disk writes\n without blocking the thread. Even while the disk\n write is in progress,\n the other read APIs of log store should be able to read the\n log.\n\n The replication and the disk write will be executed in parallel,\n\n and users need to call `raft_server::notify_log_append_completion`\n when the\n asynchronous disk write is done. Also, users need to properly\n implement\n `log_store::last_durable_index` API to return the most recent\n durable log index. The\n leader will commit the log based on the\n result of this API.\n\n   - If the\n disk write is done earlier than the replication,\n     the commit behavior is the same\n as the original protocol.\n\n   - If the replication is done earlier than the disk\n write,\n     the leader will commit the log based on the quorum except\n     for\n the leader itself. The leader can apply the log to\n     the state machine even before\n completing the disk write\n     of the log.\n\n Note that parallel log\n appending is available for the leader only,\n and followers will wait for\n `notify_log_append_completion` call\n before returning the response."]
    pub parallel_log_appending: bool,
    #[doc = " If non-zero, streaming mode is enabled and `append_entries` requests are\n\n dispatched instantly without awaiting the response from the prior request.\n,\n The\n count of logs in-flight will be capped by this value, allowing it\n to function as a\n throttling mechanism, in conjunction with\n `max_bytes_in_flight_in_stream_`."]
    pub max_log_gap_in_stream: i32,
    #[doc = " If non-zero, the volume of data in-flight will be restricted to this\n specified\n byte limit. This limitation is effective only in streaming mode."]
    pub max_bytes_in_flight_in_stream: i64,
}
impl Default for bop_raft_params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_params_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_params_make() -> *mut bop_raft_params;
}
unsafe extern "C" {
    pub fn bop_raft_params_delete(params: *const bop_raft_params);
}
#[doc = "\n nuraft::state_machine\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_fsm_ptr {
    _unused: [u8; 0],
}
pub type bop_raft_fsm_commit = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_idx: u64,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
        result: *mut *mut bop_raft_buffer,
    ),
>;
pub type bop_raft_fsm_cluster_config = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_idx: u64,
        new_conf: *mut ::std::os::raw::c_void,
    ),
>;
pub type bop_raft_fsm_rollback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_idx: u64,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
    ),
>;
pub type bop_raft_fsm_get_next_batch_size_hint_in_bytes =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> i64>;
pub type bop_raft_fsm_snapshot_save = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        last_log_idx: u64,
        last_log_term: u64,
        last_config: *mut bop_raft_cluster_config,
        size: u64,
        type_: u8,
        is_first_obj: bool,
        is_last_obj: bool,
        data: *const ::std::os::raw::c_uchar,
        data_size: usize,
    ),
>;
pub type bop_raft_fsm_snapshot_apply = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        last_log_idx: u64,
        last_log_term: u64,
        last_config: *mut bop_raft_cluster_config,
        size: u64,
        type_: u8,
    ) -> bool,
>;
pub type bop_raft_fsm_snapshot_read = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        user_snapshot_ctx: *mut *mut ::std::os::raw::c_void,
        obj_id: u64,
        data_out: *mut *mut bop_raft_buffer,
        is_last_obj: *mut bool,
    ) -> i32,
>;
pub type bop_raft_fsm_free_user_snapshot_ctx = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        user_snapshot_ctx: *mut *mut ::std::os::raw::c_void,
    ),
>;
pub type bop_raft_fsm_last_snapshot = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_snapshot,
>;
pub type bop_raft_fsm_last_commit_index =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
pub type bop_raft_fsm_create_snapshot = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        snapshot: *mut bop_raft_snapshot,
        snapshot_data: *mut bop_raft_buffer,
        snp_data: *mut ::std::os::raw::c_void,
        snp_data_size: usize,
    ),
>;
pub type bop_raft_fsm_chk_create_snapshot =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> bool>;
pub type bop_raft_fsm_allow_leadership_transfer =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_fsm_adjust_commit_index_params {
    _unused: [u8; 0],
}
pub type bop_raft_fsm_adjust_commit_index = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        current_commit_index: u64,
        expected_commit_index: u64,
        params: *const bop_raft_fsm_adjust_commit_index_params,
    ) -> u64,
>;
unsafe extern "C" {
    pub fn bop_raft_fsm_adjust_commit_index_peer_index(
        params: *mut bop_raft_fsm_adjust_commit_index_params,
        peerID: i32,
    ) -> u64;
}
unsafe extern "C" {
    pub fn bop_raft_fsm_adjust_commit_index_peer_indexes(
        params: *mut bop_raft_fsm_adjust_commit_index_params,
        peers: *mut *mut u64,
    );
}
unsafe extern "C" {
    pub fn bop_raft_fsm_make(
        user_data: *mut ::std::os::raw::c_void,
        current_conf: *mut bop_raft_cluster_config,
        rollback_conf: *mut bop_raft_cluster_config,
        commit: bop_raft_fsm_commit,
        commit_config: bop_raft_fsm_cluster_config,
        pre_commit: bop_raft_fsm_commit,
        rollback: bop_raft_fsm_rollback,
        rollback_config: bop_raft_fsm_cluster_config,
        get_next_batch_size_hint_in_bytes: bop_raft_fsm_get_next_batch_size_hint_in_bytes,
        save_snapshot: bop_raft_fsm_snapshot_save,
        apply_snapshot: bop_raft_fsm_snapshot_apply,
        read_snapshot: bop_raft_fsm_snapshot_read,
        free_snapshot_user_ctx: bop_raft_fsm_free_user_snapshot_ctx,
        last_snapshot: bop_raft_fsm_last_snapshot,
        last_commit_index: bop_raft_fsm_last_commit_index,
        create_snapshot: bop_raft_fsm_create_snapshot,
        chk_create_snapshot: bop_raft_fsm_chk_create_snapshot,
        allow_leadership_transfer: bop_raft_fsm_allow_leadership_transfer,
        adjust_commit_index: bop_raft_fsm_adjust_commit_index,
    ) -> *mut bop_raft_fsm_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_fsm_delete(fsm: *const bop_raft_fsm_ptr);
}
#[doc = "\n nuraft::state_mgr\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_log_store_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_state_mgr_ptr {
    _unused: [u8; 0],
}
pub type bop_raft_state_mgr_load_config = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_cluster_config,
>;
pub type bop_raft_state_mgr_save_config = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        config: *const bop_raft_cluster_config,
    ),
>;
pub type bop_raft_state_mgr_save_state = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, state: *const bop_raft_srv_state),
>;
pub type bop_raft_state_mgr_read_state = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_srv_state,
>;
pub type bop_raft_state_mgr_load_log_store = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_log_store_ptr,
>;
pub type bop_raft_state_mgr_server_id =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> i32>;
pub type bop_raft_state_mgr_system_exit = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, exit_code: i32),
>;
unsafe extern "C" {
    pub fn bop_raft_state_mgr_make(
        user_data: *mut ::std::os::raw::c_void,
        load_config: bop_raft_state_mgr_load_config,
        save_config: bop_raft_state_mgr_save_config,
        read_state: bop_raft_state_mgr_read_state,
        save_state: bop_raft_state_mgr_save_state,
        load_log_store: bop_raft_state_mgr_load_log_store,
        server_id: bop_raft_state_mgr_server_id,
        system_exit: bop_raft_state_mgr_system_exit,
    ) -> *mut bop_raft_state_mgr_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_state_mgr_delete(sm: *const bop_raft_state_mgr_ptr);
}
unsafe extern "C" {
    #[doc = "\n nuraft::log_store\n"]
    pub static BOP_RAFT_LOG_ENTRY_PTR_SIZE: usize;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bop_raft_log_entry_ptr {
    pub data: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_log_entry {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_log_entry_make(
        term: u64,
        data: *mut bop_raft_buffer,
        timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    ) -> *mut bop_raft_log_entry;
}
unsafe extern "C" {
    pub fn bop_raft_log_entry_delete(entry: *const bop_raft_log_entry);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_log_entry_vector {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_log_entry_vec_push(
        vec: *const bop_raft_log_entry_vector,
        term: u64,
        data: *mut bop_raft_buffer,
        timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    );
}
pub type bop_raft_log_store_next_slot =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
pub type bop_raft_log_store_start_index =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
pub type bop_raft_log_store_last_entry = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_log_entry,
>;
pub type bop_raft_log_store_append = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_entry: bop_raft_log_entry_ptr,
        term: u64,
        data: *mut u8,
        data_size: usize,
        log_timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    ) -> u64,
>;
pub type bop_raft_log_store_write_at = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
        term: u64,
        data: *mut u8,
        data_size: usize,
        log_timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    ),
>;
pub type bop_raft_log_store_end_of_append_batch = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, start: u64, cnt: u64),
>;
pub type bop_raft_log_store_log_entries = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        vec: *mut bop_raft_log_entry_vector,
        start: u64,
        end: u64,
    ) -> bool,
>;
pub type bop_raft_log_store_entry_at = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
    ) -> *mut bop_raft_log_entry,
>;
pub type bop_raft_log_store_term_at = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, index: u64) -> u64,
>;
pub type bop_raft_log_store_pack = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
        cnt: i32,
    ) -> *mut bop_raft_buffer,
>;
pub type bop_raft_log_store_apply_pack = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
        pack: *mut bop_raft_buffer,
    ),
>;
pub type bop_raft_log_store_compact = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, last_log_index: u64) -> bool,
>;
pub type bop_raft_log_store_compact_async = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, last_log_index: u64) -> bool,
>;
pub type bop_raft_log_store_flush =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> bool>;
pub type bop_raft_log_store_last_durable_index =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
unsafe extern "C" {
    pub fn bop_raft_log_store_make(
        user_data: *mut ::std::os::raw::c_void,
        next_slot: bop_raft_log_store_next_slot,
        start_index: bop_raft_log_store_start_index,
        last_entry: bop_raft_log_store_last_entry,
        append: bop_raft_log_store_append,
        write_at: bop_raft_log_store_write_at,
        end_of_append_batch: bop_raft_log_store_end_of_append_batch,
        log_entries: bop_raft_log_store_log_entries,
        entry_at: bop_raft_log_store_entry_at,
        term_at: bop_raft_log_store_term_at,
        pack: bop_raft_log_store_pack,
        apply_pack: bop_raft_log_store_apply_pack,
        compact: bop_raft_log_store_compact,
        compact_async: bop_raft_log_store_compact_async,
        flush: bop_raft_log_store_flush,
        last_durable_index: bop_raft_log_store_last_durable_index,
    ) -> *mut bop_raft_log_store_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_log_store_delete(log_store: *const bop_raft_log_store_ptr);
}
#[doc = "\n nuraft::counter\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_counter {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_counter_make(
        name: *const ::std::os::raw::c_char,
        name_size: usize,
    ) -> *mut bop_raft_counter;
}
unsafe extern "C" {
    pub fn bop_raft_counter_delete(counter: *const bop_raft_counter);
}
unsafe extern "C" {
    pub fn bop_raft_counter_name(counter: *const bop_raft_counter)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_counter_value(counter: *const bop_raft_counter) -> u64;
}
#[doc = "\n nuraft::gauge\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_gauge {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_gauge_make(
        name: *const ::std::os::raw::c_char,
        name_size: usize,
    ) -> *mut bop_raft_gauge;
}
unsafe extern "C" {
    pub fn bop_raft_gauge_delete(gauge: *const bop_raft_gauge);
}
unsafe extern "C" {
    pub fn bop_raft_gauge_name(gauge: *const bop_raft_gauge) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_gauge_value(gauge: *const bop_raft_gauge) -> i64;
}
#[doc = "\n nuraft::histogram\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_histogram {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_histogram_make(
        name: *const ::std::os::raw::c_char,
        name_size: usize,
    ) -> *mut bop_raft_histogram;
}
unsafe extern "C" {
    pub fn bop_raft_histogram_delete(histogram: *const bop_raft_histogram);
}
unsafe extern "C" {
    pub fn bop_raft_histogram_name(
        histogram: *const bop_raft_histogram,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_histogram_size(histogram: *const bop_raft_histogram) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_histogram_get(histogram: *const bop_raft_histogram, key: f64) -> u64;
}
#[doc = "\n bop_raft_append_entries_ptr\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_append_entries_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_create() -> *mut bop_raft_append_entries_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_delete(self_: *const bop_raft_append_entries_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_size(self_: *const bop_raft_append_entries_ptr) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_push(
        self_: *mut bop_raft_append_entries_ptr,
        buf: *mut bop_raft_buffer,
    ) -> usize;
}
#[doc = "\n bop_raft_server_peer_info\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bop_raft_server_peer_info {
    #[doc = " Peer ID."]
    pub id: i32,
    #[doc = " The last log index that the peer has, from this server's point of view."]
    pub last_log_idx: u64,
    #[doc = " The elapsed time since the last successful response from this peer, in microseconds."]
    pub last_succ_resp_us: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_server_peer_info_vec {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_make() -> *mut bop_raft_server_peer_info_vec;
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_delete(vec: *const bop_raft_server_peer_info_vec);
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_size(vec: *const bop_raft_server_peer_info_vec) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_get(
        vec: *const bop_raft_server_peer_info_vec,
        idx: usize,
    ) -> *mut bop_raft_server_peer_info;
}
#[doc = "\n bop_raft_server\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_server_ptr {
    _unused: [u8; 0],
}
pub const bop_raft_server_priority_set_result_bop_raft_server_priority_set_result_set:
    bop_raft_server_priority_set_result = 0;
pub const bop_raft_server_priority_set_result_bop_raft_server_priority_set_result_broadcast:
    bop_raft_server_priority_set_result = 1;
pub const bop_raft_server_priority_set_result_bop_raft_server_priority_set_result_ignored:
    bop_raft_server_priority_set_result = 2;
pub type bop_raft_server_priority_set_result = i32;
#[doc = " Got request from peer or client.\n ctx: pointer to request."]
pub const bop_raft_cb_type_bop_raft_cb_type_process_req: bop_raft_cb_type = 1;
#[doc = " Got append entry response from peer.\n ctx: pointer to new matched index\n number."]
pub const bop_raft_cb_type_bop_raft_cb_type_got_append_entry_resp_from_peer: bop_raft_cb_type = 2;
#[doc = " Appended logs and executed pre-commit locally.\n Happens on leader only.\n\n ctx: pointer to last log number."]
pub const bop_raft_cb_type_bop_raft_cb_type_append_logs: bop_raft_cb_type = 3;
#[doc = " Heartbeat timer wakes up.\n Happens on leader only.\n ctx: pointer to last\n log number."]
pub const bop_raft_cb_type_bop_raft_cb_type_heart_beat: bop_raft_cb_type = 4;
#[doc = " Joined a cluster.\n Happens on follower only.\n ctx: pointer to cluster\n config."]
pub const bop_raft_cb_type_bop_raft_cb_type_joined_cluster: bop_raft_cb_type = 5;
#[doc = " Became a leader.\n ctx: pointer to term number."]
pub const bop_raft_cb_type_bop_raft_cb_type_become_leader: bop_raft_cb_type = 6;
#[doc = " Request append entries to followers.\n Happens on leader only."]
pub const bop_raft_cb_type_bop_raft_cb_type_request_append_entries: bop_raft_cb_type = 7;
#[doc = " Save snapshot chunk or object, in receiver's side.\n ctx: snapshot_sync_req."]
pub const bop_raft_cb_type_bop_raft_cb_type_save_snapshot: bop_raft_cb_type = 8;
#[doc = " Committed a new config.\n ctx: pointer to log index of new config."]
pub const bop_raft_cb_type_bop_raft_cb_type_new_config: bop_raft_cb_type = 9;
#[doc = " Removed from a cluster.\n Happens on follower only.\n ctx: null."]
pub const bop_raft_cb_type_bop_raft_cb_type_removed_from_cluster: bop_raft_cb_type = 10;
#[doc = " Became a follower.\n ctx: pointer to term number."]
pub const bop_raft_cb_type_bop_raft_cb_type_become_follower: bop_raft_cb_type = 11;
#[doc = " The difference of committed log index between the follower and the\n master\n became smaller than a user-specified threshold.\n Happens on follower only.\n ctx:\n null."]
pub const bop_raft_cb_type_bop_raft_cb_type_become_fresh: bop_raft_cb_type = 12;
#[doc = " The difference of committed log index between the follower and the\n master\n became larger than a user-specified threshold.\n Happens on follwer only.\n ctx:\n null"]
pub const bop_raft_cb_type_bop_raft_cb_type_become_stale: bop_raft_cb_type = 13;
#[doc = " Got append entry request from leader.\n It will be invoked only for acceptable\n logs.\n ctx: pointer to request."]
pub const bop_raft_cb_type_bop_raft_cb_type_got_append_entry_req_from_leader: bop_raft_cb_type = 14;
#[doc = " This node is out of log range, which means that\n leader has no valid log or\n snapshot to send for this node.\n ctx: pointer to `OutOfLogRangeWarningArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_out_of_log_range_warning: bop_raft_cb_type = 15;
#[doc = " New connection is established.\n Mostly this event happens in below cases:\n 1)\n Leader sends message to follower, then follower will fire\n      this event.\n   2)\n Candidate sends vote request to peer, then the peer (receiver)\n      will fire this\n event.\n ctx: pointer to `ConnectionArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_connection_opened: bop_raft_cb_type = 16;
#[doc = " Connection is closed.\n ctx: pointer to `ConnectionArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_connection_closed: bop_raft_cb_type = 17;
#[doc = " Invoked when a session receives a message from the valid leader\n first time.\n This callback is preceded by `ConnectionOpened`\n event.\n ctx: pointer to\n `ConnectionArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_new_session_from_leader: bop_raft_cb_type = 18;
#[doc = " Executed a log in the state machine.\n ctx: pointer to the log index."]
pub const bop_raft_cb_type_bop_raft_cb_type_state_machine_execution: bop_raft_cb_type = 19;
#[doc = " Just sent an append entries request.\n ctx: pointer to `req_msg` instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_sent_append_entries_req: bop_raft_cb_type = 20;
#[doc = " Just received an append entries request.\n ctx: pointer to `req_msg` instance.\n"]
pub const bop_raft_cb_type_bop_raft_cb_type_received_append_entries_req: bop_raft_cb_type = 21;
#[doc = " Just sent an append entries response.\n ctx: pointer to `resp_msg` instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_sent_append_entries_resp: bop_raft_cb_type = 22;
#[doc = " Just received an append entries response.\n ctx: pointer to `resp_msg`\n instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_received_append_entries_resp: bop_raft_cb_type = 23;
#[doc = " When cluster size is 2 and `auto_adjust_quorum_for_small_cluster_` is on,\n this\n server attempts to adjust the quorum size to 1.\n ctx: null"]
pub const bop_raft_cb_type_bop_raft_cb_type_auto_adjust_quorum: bop_raft_cb_type = 24;
#[doc = " Adding a server failed due to RPC errors and timeout expiry.\n ctx: null"]
pub const bop_raft_cb_type_bop_raft_cb_type_server_join_failed: bop_raft_cb_type = 25;
#[doc = " Snapshot creation begins.\n ctx: pointer to `uint64_t` (committed_idx)."]
pub const bop_raft_cb_type_bop_raft_cb_type_snapshot_creation_begin: bop_raft_cb_type = 26;
#[doc = " Got a resgination request either automatically or manually.\n ctx: null."]
pub const bop_raft_cb_type_bop_raft_cb_type_resignation_from_leader: bop_raft_cb_type = 27;
#[doc = " When a peer RPC errors count exceeds raft_server::limits.warning_limit_, or\n a\n peer doesn't respond for a long time (raft_params::leadership_expiry_),\n the peer is\n considered lost.\n ctx: null."]
pub const bop_raft_cb_type_bop_raft_cb_type_follower_lost: bop_raft_cb_type = 28;
#[doc = " When the server receives a misbehaving message from a peer,\n the callback has\n the ability to either ignore the message\n or respond normally by adjusting ReqResp.resp\n as indicated by ctx.\n\n Furthermore, the callback can opt to terminate\n if\n the situation is deemed critical.\n\n ctx: pointer to `ReqResp` instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_received_misbehaving_message: bop_raft_cb_type = 29;
pub type bop_raft_cb_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_param {
    pub my_id: i32,
    pub leader_id: i32,
    pub peer_id: i32,
    pub ctx: *mut ::std::os::raw::c_void,
}
impl Default for bop_raft_cb_param {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_req_msg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_resp_msg {
    _unused: [u8; 0],
}
pub const bop_raft_cb_return_code_bop_raft_cb_return_code_ok: bop_raft_cb_return_code = 0;
pub const bop_raft_cb_return_code_bop_raft_cb_return_code_return_null: bop_raft_cb_return_code = -1;
pub type bop_raft_cb_return_code = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bop_raft_cb_out_of_log_range_warning_args {
    pub start_idx_of_leader: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_connection_args {
    #[doc = " ID of session."]
    pub session_id: u64,
    #[doc = " Endpoint address."]
    pub address: *const ::std::os::raw::c_char,
    pub address_len: usize,
    #[doc = " Endpoint port."]
    pub port: u32,
    #[doc = " Endpoint server ID if given."]
    pub srv_id: i32,
    #[doc = " `true` if the endpoint server is leader."]
    pub is_leader: bool,
}
impl Default for bop_raft_cb_connection_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bop_raft_msg_type_bop_raft_msg_type_request_vote_request: bop_raft_msg_type = 1;
pub const bop_raft_msg_type_bop_raft_msg_type_request_vote_response: bop_raft_msg_type = 2;
pub const bop_raft_msg_type_bop_raft_msg_type_append_entries_request: bop_raft_msg_type = 3;
pub const bop_raft_msg_type_bop_raft_msg_type_append_entries_response: bop_raft_msg_type = 4;
pub const bop_raft_msg_type_bop_raft_msg_type_client_request: bop_raft_msg_type = 5;
pub const bop_raft_msg_type_bop_raft_msg_type_add_server_request: bop_raft_msg_type = 6;
pub const bop_raft_msg_type_bop_raft_msg_type_add_server_response: bop_raft_msg_type = 7;
pub const bop_raft_msg_type_bop_raft_msg_type_remove_server_request: bop_raft_msg_type = 8;
pub const bop_raft_msg_type_bop_raft_msg_type_remove_server_response: bop_raft_msg_type = 9;
pub const bop_raft_msg_type_bop_raft_msg_type_sync_log_request: bop_raft_msg_type = 10;
pub const bop_raft_msg_type_bop_raft_msg_type_sync_log_response: bop_raft_msg_type = 11;
pub const bop_raft_msg_type_bop_raft_msg_type_join_cluster_request: bop_raft_msg_type = 12;
pub const bop_raft_msg_type_bop_raft_msg_type_join_cluster_response: bop_raft_msg_type = 13;
pub const bop_raft_msg_type_bop_raft_msg_type_leave_cluster_request: bop_raft_msg_type = 14;
pub const bop_raft_msg_type_bop_raft_msg_type_leave_cluster_response: bop_raft_msg_type = 15;
pub const bop_raft_msg_type_bop_raft_msg_type_install_snapshot_request: bop_raft_msg_type = 16;
pub const bop_raft_msg_type_bop_raft_msg_type_install_snapshot_response: bop_raft_msg_type = 17;
pub const bop_raft_msg_type_bop_raft_msg_type_ping_request: bop_raft_msg_type = 18;
pub const bop_raft_msg_type_bop_raft_msg_type_ping_response: bop_raft_msg_type = 19;
pub const bop_raft_msg_type_bop_raft_msg_type_pre_vote_request: bop_raft_msg_type = 20;
pub const bop_raft_msg_type_bop_raft_msg_type_pre_vote_response: bop_raft_msg_type = 21;
pub const bop_raft_msg_type_bop_raft_msg_type_other_request: bop_raft_msg_type = 22;
pub const bop_raft_msg_type_bop_raft_msg_type_other_response: bop_raft_msg_type = 23;
pub const bop_raft_msg_type_bop_raft_msg_type_priority_change_request: bop_raft_msg_type = 24;
pub const bop_raft_msg_type_bop_raft_msg_type_priority_change_response: bop_raft_msg_type = 25;
pub const bop_raft_msg_type_bop_raft_msg_type_reconnect_request: bop_raft_msg_type = 26;
pub const bop_raft_msg_type_bop_raft_msg_type_reconnect_response: bop_raft_msg_type = 27;
pub const bop_raft_msg_type_bop_raft_msg_type_custom_notification_request: bop_raft_msg_type = 28;
pub const bop_raft_msg_type_bop_raft_msg_type_custom_notification_response: bop_raft_msg_type = 29;
pub type bop_raft_msg_type = i32;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_OK: bop_raft_cmd_result_code = 0;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_CANCELLED: bop_raft_cmd_result_code = -1;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_TIMEOUT: bop_raft_cmd_result_code = -2;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_NOT_LEADER: bop_raft_cmd_result_code = -3;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_BAD_REQUEST: bop_raft_cmd_result_code = -4;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_ALREADY_EXISTS:
    bop_raft_cmd_result_code = -5;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_CONFIG_CHANGING: bop_raft_cmd_result_code =
    -6;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_IS_JOINING: bop_raft_cmd_result_code =
    -7;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_NOT_FOUND: bop_raft_cmd_result_code =
    -8;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_CANNOT_REMOVE_LEADER:
    bop_raft_cmd_result_code = -9;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_IS_LEAVING: bop_raft_cmd_result_code =
    -10;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_TERM_MISMATCH: bop_raft_cmd_result_code =
    -11;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_RESULT_NOT_EXIST_YET:
    bop_raft_cmd_result_code = -10000;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_FAILED: bop_raft_cmd_result_code = -32768;
pub type bop_raft_cmd_result_code = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_req_resp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_req_msg {
    pub term: u64,
    pub type_: bop_raft_msg_type,
    pub src: i32,
    pub dst: i32,
    pub last_log_term: u64,
    pub last_log_idx: u64,
    pub commit_idx: u64,
}
impl Default for bop_raft_cb_req_msg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_resp_peer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_resp_msg {
    pub term: u64,
    pub type_: bop_raft_msg_type,
    pub src: i32,
    pub dst: i32,
    pub next_idx: u64,
    pub next_batch_size_hint_in_bytes: i64,
    pub accepted: bool,
    pub ctx: *mut bop_raft_buffer,
    pub peer: *mut bop_raft_cb_resp_peer,
    pub result_code: bop_raft_cmd_result_code,
}
impl Default for bop_raft_cb_resp_msg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_req_msg(
        req_resp: *mut bop_raft_cb_req_resp,
        req_msg: *mut bop_raft_cb_req_msg,
    );
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_req_msg_entries_size(req_resp: *const bop_raft_cb_req_resp) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_req_msg_get_entry(
        req_resp: *const bop_raft_cb_req_resp,
        idx: usize,
    ) -> *mut bop_raft_log_entry;
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_resp_msg(
        req_resp: *mut bop_raft_cb_req_resp,
        resp_msg: *mut bop_raft_cb_resp_msg,
    );
}
pub type bop_raft_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        type_: bop_raft_cb_type,
        param: *mut bop_raft_cb_param,
    ) -> bop_raft_cb_return_code,
>;
pub type bop_raft_inc_term_func = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, current_term: u64) -> u64,
>;
unsafe extern "C" {
    pub fn bop_raft_server_launch(
        user_data: *mut ::std::os::raw::c_void,
        fsm: *mut bop_raft_fsm_ptr,
        state_mgr: *mut bop_raft_state_mgr_ptr,
        logger: *mut bop_raft_logger_ptr,
        port_number: i32,
        asio_service: *const bop_raft_asio_service_ptr,
        params_given: *mut bop_raft_params,
        skip_initial_election_timeout: bool,
        start_server_in_constructor: bool,
        test_mode_flag: bool,
        cb_func: bop_raft_cb_func,
    ) -> *mut bop_raft_server_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_server_stop(server: *mut bop_raft_server_ptr, time_limit_sec: usize) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_server_get(s: *mut bop_raft_server_ptr) -> *mut bop_raft_server;
}
unsafe extern "C" {
    #[doc = " Check if this server is ready to serve operation.\n\n @return `true` if it is ready."]
    pub fn bop_raft_server_is_initialized(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is catching up the current leader\n to join the cluster.\n\n @return\n `true` if it is in catch-up mode."]
    pub fn bop_raft_server_is_catching_up(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is receiving snapshot from leader.\n\n @return `true` if it is\n receiving snapshot."]
    pub fn bop_raft_server_is_receiving_snapshot(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Add a new server to the current cluster. Only leader will accept this operation.\n Note that this is an asynchronous task so that needs more network communications.\n Returning this function does not guarantee adding the server.\n\n @param srv Configuration of server to add.\n @return `get_accepted()` will be true on success."]
    pub fn bop_raft_server_add_srv(
        rs: *mut bop_raft_server,
        srv: *const bop_raft_srv_config_ptr,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Remove a server from the current cluster. Only leader will accept this operation.\n The same as `add_srv`, this is also an asynchronous task.\n\n @param srv_id ID of server to remove.\n @return `get_accepted()` will be true on success."]
    pub fn bop_raft_server_remove_srv(
        rs: *mut bop_raft_server,
        srv_id: i32,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Flip learner flag of given server. Learner will be excluded from the quorum. Only\n leader will accept this operation. This is also an asynchronous task.\n\n @param srv_id ID of the server to set as a learner.\n @param to If `true`, set the server as a learner, otherwise, clear learner flag.\n @return `ret->get_result_code()` will be OK on success."]
    pub fn bop_raft_server_flip_learner_flag(
        rs: *mut bop_raft_server,
        srv_id: i32,
        to: bool,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Append and replicate the given logs. Only leader will accept this operation.\n\n @param entries Set of logs to replicate.\n @return\n     In blocking mode, it will be blocked during replication, and\n     return `cmd_result` instance which contains the commit results from\n     the state machine.\n\n     In async mode, this function will return immediately, and the commit\n     results will be set to returned `cmd_result` instance later."]
    pub fn bop_raft_server_append_entries(
        rs: *mut bop_raft_server,
        entries: *mut bop_raft_append_entries_ptr,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Update the priority of given server.\n\n @param rs local bop_raft_server instance\n @param srv_id ID of server to update priority.\n @param new_priority Priority value, greater than or equal to 0.\n        If priority is set to 0, this server will never be a leader.\n @param broadcast_when_leader_exists If we're not a leader and a\n        leader exists, broadcast priority change to other peers.\n        If false, set_priority does nothing. Please note that\n        setting this option to true may possibly cause cluster config\n        to diverge.\n @return SET If we're a leader and we have committed priority change.\n @return BROADCAST\n     If either there's no\n         live leader now, or we're a leader, and we want to set our priority to 0,\n\n         or we're not a leader and broadcast_when_leader_exists = true.\n         We have sent messages to other peers about priority change but haven't\n         committed this change.\n @return IGNORED If we're not a leader and broadcast_when_leader_exists = false.\n"]
    pub fn bop_raft_server_set_priority(
        rs: *mut bop_raft_server,
        srv_id: i32,
        new_priority: i32,
        broadcast_when_leader_exists: bool,
    ) -> bop_raft_server_priority_set_result;
}
unsafe extern "C" {
    #[doc = " Broadcast the priority change of given server to all peers. This function should be used\n only when there is no live leader and leader election is blocked by priorities of live\n followers. In that case, we are not able to change priority by using normal `set_priority`\n operation.\n\n @param rs local bop_raft_server instance\n @param srv_id ID of server to update\n priority.\n @param new_priority New priority."]
    pub fn bop_raft_server_broadcast_priority_change(
        rs: *mut bop_raft_server,
        srv_id: i32,
        new_priority: i32,
    );
}
unsafe extern "C" {
    #[doc = " Yield current leadership and becomes a follower. Only a leader will accept this\n\n If given `immediate_yield` flag is `true`, it will become a follower immediately.\n The subsequent leader election will be totally random so that there is always a\n chance that this server becomes the next leader again.\n\n Otherwise, this server will pause write operations first, wait until the successor\n (except for this server) finishes the catch-up of the latest log, and then resign.\n In such a case, the next leader will be much more predictable.\n\n Users can designate the successor. If not given, this API will automatically choose\n the highest priority server as a successor.\n\n @param rs local bop_raft_server instance\n @param immediate_yield If `true`, yield immediately.\n @param successor_id The server ID of the successor.\n                     If `-1`, the successor will be chosen automatically."]
    pub fn bop_raft_server_yield_leadership(
        rs: *mut bop_raft_server,
        immediate_yield: bool,
        successor_id: i32,
    );
}
unsafe extern "C" {
    #[doc = " Send a request to the current leader to yield its leadership,\n and become the next leader.\n\n *\n @return `true` on success. But it does not guarantee to become\n         the next leader due to various failures."]
    pub fn bop_raft_server_request_leadership(rs: *mut bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Start the election timer on this server, if this server is a follower. It will\n allow the election timer permanently, if it was disabled by state manager."]
    pub fn bop_raft_server_restart_election_timer(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Set custom context to Raft cluster config. It will create a new configuration log and\n replicate it.\n\n @param ctx Custom context."]
    pub fn bop_raft_server_set_user_ctx(
        rs: *mut bop_raft_server,
        data: *const ::std::os::raw::c_char,
        size: usize,
    );
}
unsafe extern "C" {
    #[doc = " Get custom context from the current cluster config.\n\n @return Custom context."]
    pub fn bop_raft_server_get_user_ctx(rs: *mut bop_raft_server) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    #[doc = " Get timeout for snapshot_sync_ctx\n\n @return snapshot_sync_ctx_timeout."]
    pub fn bop_raft_server_get_snapshot_sync_ctx_timeout(rs: *const bop_raft_server) -> i32;
}
unsafe extern "C" {
    #[doc = " Get ID of this server.\n\n @return Server ID."]
    pub fn bop_raft_server_get_id(rs: *const bop_raft_server) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the current term of this server.\n\n @return Term."]
    pub fn bop_raft_server_get_term(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the term of given log index number.\n\n @param log_idx Log index number\n @return Term of given log."]
    pub fn bop_raft_server_get_log_term(rs: *const bop_raft_server, log_idx: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the term of the last log.\n\n @return Term of the last log."]
    pub fn bop_raft_server_get_last_log_term(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the last log index number.\n\n @return Last log index number."]
    pub fn bop_raft_server_get_last_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the last committed log index number of state machine.\n\n @return Last committed log index number of state machine."]
    pub fn bop_raft_server_get_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the target log index number we are required to commit.\n\n @return Target committed log index number."]
    pub fn bop_raft_server_get_target_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the leader's last committed log index number.\n\n @return The leader's last committed log index number."]
    pub fn bop_raft_server_get_leader_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the log index of the first config when this server became a leader.\n This API can be used for checking if the state machine is fully caught up\n with the latest log after a leader election, so that the new leader can\n guarantee strong consistency.\n\n It will return 0 if this server is not a leader.\n\n @return The log index of the first config when this server became a leader."]
    pub fn bop_raft_server_get_log_idx_at_becoming_leader(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Calculate the log index to be committed from current peers' matched indexes.\n\n @return Expected committed log index."]
    pub fn bop_raft_server_get_expected_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the current Raft cluster config.\n\n @param rs raft server instance\n @param cluster_config Wrapper for holding nuraft::ptr<nuraft::cluster_config>"]
    pub fn bop_raft_server_get_config(
        rs: *const bop_raft_server,
        cluster_config: *mut bop_raft_cluster_config_ptr,
    );
}
unsafe extern "C" {
    #[doc = " Get data center ID of the given server.\n\n @param srv_id Server ID.\n @return -1 if given server ID does not exist.\n          0 if data center ID was not assigned."]
    pub fn bop_raft_server_get_dc_id(rs: *const bop_raft_server, srv_id: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " Get auxiliary context stored in the server config.\n\n @param srv_id Server ID.\n @return\n Auxiliary context."]
    pub fn bop_raft_server_get_aux(rs: *const bop_raft_server, srv_id: i32)
    -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    #[doc = " Get the ID of current leader.\n\n @return Leader ID\n         -1 if there is no live leader."]
    pub fn bop_raft_server_get_leader(rs: *const bop_raft_server) -> i32;
}
unsafe extern "C" {
    #[doc = " Check if this server is leader.\n\n @return `true` if it is leader."]
    pub fn bop_raft_server_is_leader(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if there is live leader in the current cluster.\n\n @return `true` if live leader exists."]
    pub fn bop_raft_server_is_leader_alive(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the configuration of given server.\n\n @param srv_id Server ID.\n @return Server configuration."]
    pub fn bop_raft_server_get_srv_config(
        rs: *const bop_raft_server,
        svr_config: *mut bop_raft_srv_config_ptr,
        srv_id: i32,
    );
}
unsafe extern "C" {
    #[doc = " Get the configuration of all servers.\n\n @param[out] configs_out Set of server configurations."]
    pub fn bop_raft_server_get_srv_config_all(
        rs: *const bop_raft_server,
        configs_out: *mut bop_raft_srv_config_vec,
    );
}
unsafe extern "C" {
    #[doc = " Update the server configuration, only leader will accept this operation.\n This function will update the current cluster config and replicate it to all peers.\n\n We don't allow changing multiple server configurations at once, due to safety reason.\n\n Change on endpoint will not be accepted (should be removed and then re-added).\n If the server is in new joiner state, it will be rejected.\n If the server ID does not exist, it will also be rejected.\n\n @param new_config Server configuration to update.\n @return `true` on success, `false` if rejected."]
    pub fn bop_raft_server_update_srv_config(
        rs: *mut bop_raft_server,
        new_config: *mut bop_raft_srv_config_ptr,
    );
}
unsafe extern "C" {
    #[doc = " Get the peer info of the given ID. Only leader will return peer info.\n\n @param srv_id Server ID\n @return Peer info"]
    pub fn bop_raft_server_get_peer_info(
        rs: *mut bop_raft_server,
        srv_id: i32,
        peer: *mut bop_raft_server_peer_info,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the info of all peers. Only leader will return peer info.\n\n @return Vector of peer\n info."]
    pub fn bop_raft_server_get_peer_info_all(
        rs: *const bop_raft_server,
        peers_out: *mut bop_raft_server_peer_info_vec,
    );
}
unsafe extern "C" {
    #[doc = " Shut down server instance."]
    pub fn bop_raft_server_shutdown(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = "  Start internal background threads, initialize election"]
    pub fn bop_raft_server_start_server(
        rs: *mut bop_raft_server,
        skip_initial_election_timeout: bool,
    );
}
unsafe extern "C" {
    #[doc = " Stop background commit thread."]
    pub fn bop_raft_server_stop_server(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Send reconnect request to leader. Leader will re-establish the connection to this server\n in a few seconds. Only follower will accept this operation."]
    pub fn bop_raft_server_send_reconnect_request(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Update Raft parameters.\n\n @param new_params Parameters to set."]
    pub fn bop_raft_server_update_params(rs: *mut bop_raft_server, params: *mut bop_raft_params);
}
unsafe extern "C" {
    #[doc = " Get the current Raft parameters. Returned instance is the clone of the original one,\n so that user can modify its contents.\n\n @return Clone of Raft parameters."]
    pub fn bop_raft_server_get_current_params(
        rs: *const bop_raft_server,
        params: *mut bop_raft_params,
    );
}
unsafe extern "C" {
    #[doc = " Get the counter number of given stat name.\n\n @param name Stat name to retrieve.\n\n @return Counter value."]
    pub fn bop_raft_server_get_stat_counter(
        rs: *mut bop_raft_server,
        counter: *mut bop_raft_counter,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the gauge number of given stat name.\n\n @param name Stat name to retrieve.\n @return Gauge value."]
    pub fn bop_raft_server_get_stat_gauge(
        rs: *mut bop_raft_server,
        gauge: *mut bop_raft_gauge,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the histogram of given stat name.\n\n @param name Stat name to retrieve.\n @param[out] histogram_out Histogram as a map. Key is the upper bound of a bucket, and\n             value is the counter of that bucket.\n @return `true` on success.\n         `false` if stat does not exist, or is not histogram type."]
    pub fn bop_raft_server_get_stat_histogram(
        rs: *mut bop_raft_server,
        histogram: *mut bop_raft_histogram,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Reset given stat to zero.\n\n @param name Stat name to reset."]
    pub fn bop_raft_server_reset_counter(rs: *mut bop_raft_server, counter: *mut bop_raft_counter);
}
unsafe extern "C" {
    #[doc = " Reset given stat to zero.\n\n @param name Stat name to reset."]
    pub fn bop_raft_server_reset_gauge(rs: *mut bop_raft_server, gauge: *mut bop_raft_gauge);
}
unsafe extern "C" {
    #[doc = " Reset given stat to zero.\n\n @param name Stat name to reset."]
    pub fn bop_raft_server_reset_histogram(
        rs: *mut bop_raft_server,
        histogram: *mut bop_raft_histogram,
    );
}
unsafe extern "C" {
    #[doc = " Reset all existing stats to zero."]
    pub fn bop_raft_server_reset_all_stats(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Set a custom callback function for increasing term."]
    pub fn bop_raft_server_set_inc_term_func(
        rs: *mut bop_raft_server,
        user_data: *mut ::std::os::raw::c_void,
        func: bop_raft_inc_term_func,
    );
}
unsafe extern "C" {
    #[doc = " Pause the background execution of the state machine. If an operation execution is\n currently happening, the state machine may not be paused immediately.\n\n @param timeout_ms If non-zero, this function will be blocked until\n                   either it completely pauses the state machine execution\n                   or reaches the given time limit in milliseconds.\n                   Otherwise, this function will return immediately, and there\n                   is a possibility that the state machine execution\n                   is still happening."]
    pub fn bop_raft_server_pause_state_machine_execution(
        rs: *mut bop_raft_server,
        timeout_ms: usize,
    );
}
unsafe extern "C" {
    #[doc = " Resume the background execution of state machine."]
    pub fn bop_raft_server_resume_state_machine_execution(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Check if the state machine execution is paused.\n\n @return `true` if paused."]
    pub fn bop_raft_server_is_state_machine_execution_paused(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Block the current thread and wake it up when the state machine execution is paused.\n\n @param timeout_ms If non-zero, wake up after the given amount of time\n                   even though the state machine is not paused yet.\n @return `true` if the state machine is paused."]
    pub fn bop_raft_server_wait_for_state_machine_pause(
        rs: *mut bop_raft_server,
        timeout_ms: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " (Experimental)\n This API is used when `raft_params::parallel_log_appending_` is set.\n\n Everytime an asynchronous log appending job is done, users should call this API to notify\n Raft server to handle the log. Note that calling this API once for multiple logs is acceptable\n and recommended.\n\n @param ok `true` if appending succeeded."]
    pub fn bop_raft_server_notify_log_append_completion(rs: *mut bop_raft_server, ok: bool);
}
unsafe extern "C" {
    #[doc = " Manually create a snapshot based on the latest committed log index of the state machine.\n\n Note that snapshot creation will fail immediately if the previous snapshot task is still\n running.\n\n @param serialize_commit\n        If `true`, the background commit will be blocked until `create_snapshot`\n        returns. However, it will not block the commit for the entire duration\n        of the snapshot creation process, as long as your state machine creates\n        the snapshot asynchronously. The purpose of this flag is to ensure that\n        the log index used for the snapshot creation is the most recent one.\n\n @return Log index number of the created snapshot or`0` if failed."]
    pub fn bop_raft_server_create_snapshot(rs: *mut bop_raft_server, serialize_commit: bool)
    -> u64;
}
unsafe extern "C" {
    #[doc = " Manually and asynchronously create a snapshot on the next earliest available commited\n log index.\n\n Unlike `create_snapshot`, if the previous snapshot task is running, it will wait\n until the previous task is done. Once the snapshot creation is finished, it will be\n notified via the returned `cmd_result` with the log index number of the snapshot.\n\n @param `cmd_result` instance.\n        `nullptr` if there is already a scheduled snapshot creation."]
    pub fn bop_raft_server_schedule_snapshot_creation(
        rs: *mut bop_raft_server,
        result_handler: *mut bop_raft_async_u64_ptr,
    );
}
unsafe extern "C" {
    #[doc = " Get the log index number of the last snapshot.\n\n @return Log index number of the last snapshot. `0` if snapshot does not exist."]
    pub fn bop_raft_server_get_last_snapshot_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Set the self mark down flag of this server.\n\n @return The self mark down flag before the update."]
    pub fn bop_raft_server_set_self_mark_down(rs: *mut bop_raft_server, to: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is the part of the quorum of full consensus.\n What it means is that, as long as the return value is `true`, this server\n has the latest committed log at the moment that `true` was returned.\n\n @return `true` if this server is the part of the full consensus."]
    pub fn bop_raft_server_is_part_of_full_consensus(rs: *mut bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is excluded from the quorum by the leader,\n when it runs in full consensus mode.\n\n @return `true` if this server is excluded by the current leader and\n         not the part of the full consensus."]
    pub fn bop_raft_server_is_excluded_by_leader(rs: *mut bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Wait for the state machine to commit the log at the given index.\n This function will return immediately, and the commit results will be\n set to the returned `cmd_result` instance later.\n\n @return `cmd_result` instance. It will contain `true` if the commit\n         has been invoked, and `false` if not."]
    pub fn bop_raft_server_wait_for_state_machine_commit(
        rs: *mut bop_raft_server,
        result: *mut bop_raft_async_bool_ptr,
        target_idx: u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_mdbx_state_mgr_open(
        my_srv_config: *mut bop_raft_srv_config_ptr,
        dir: *const ::std::os::raw::c_char,
        dir_size: usize,
        logger: *mut bop_raft_logger_ptr,
        size_lower: usize,
        size_now: usize,
        size_upper: usize,
        growth_step: usize,
        shrink_threshold: usize,
        pagesize: usize,
        flags: u32,
        mode: u16,
        log_store: *mut bop_raft_log_store_ptr,
    ) -> *mut bop_raft_state_mgr_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_mdbx_log_store_open(
        path: *const ::std::os::raw::c_char,
        path_size: usize,
        logger: *mut bop_raft_logger_ptr,
        size_lower: usize,
        size_now: usize,
        size_upper: usize,
        growth_step: usize,
        shrink_threshold: usize,
        pagesize: usize,
        flags: u32,
        mode: u16,
        compact_batch_size: usize,
    ) -> *mut bop_raft_log_store_ptr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_producer_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_consumer_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_blocking {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_blocking_producer_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_blocking_consumer_token {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_mpmc_create() -> *mut bop_mpmc;
}
unsafe extern "C" {
    pub fn bop_mpmc_destroy(queue: *mut bop_mpmc);
}
unsafe extern "C" {
    pub fn bop_mpmc_create_producer_token(queue: *mut bop_mpmc) -> *mut bop_mpmc_producer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_destroy_producer_token(token: *mut bop_mpmc_producer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_create_consumer_token(queue: *mut bop_mpmc) -> *mut bop_mpmc_consumer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_destroy_consumer_token(token: *mut bop_mpmc_consumer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_size_approx(queue: *mut bop_mpmc) -> usize;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue(queue: *mut bop_mpmc, item: u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue_token(token: *mut bop_mpmc_producer_token, item: u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue_bulk(token: *mut bop_mpmc, items: *mut u64, size: usize) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue_bulk_token(
        queue: *mut bop_mpmc_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_try_enqueue_bulk(queue: *mut bop_mpmc, items: *mut u64, size: usize) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_try_enqueue_bulk_token(
        queue: *mut bop_mpmc_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue(queue: *mut bop_mpmc, item: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue_token(queue: *mut bop_mpmc_consumer_token, item: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue_bulk(queue: *mut bop_mpmc, items: *mut u64, max_size: usize) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue_bulk_token(
        queue: *mut bop_mpmc_consumer_token,
        items: *mut u64,
        max_size: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_create() -> *mut bop_mpmc_blocking;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_destroy(queue: *mut bop_mpmc_blocking);
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_create_producer_token(
        queue: *mut bop_mpmc_blocking,
    ) -> *mut bop_mpmc_blocking_producer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_destroy_producer_token(token: *mut bop_mpmc_blocking_producer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_create_consumer_token(
        queue: *mut bop_mpmc_blocking,
    ) -> *mut bop_mpmc_blocking_consumer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_destroy_consumer_token(token: *mut bop_mpmc_blocking_consumer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_size_approx(queue: *mut bop_mpmc_blocking) -> usize;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue(queue: *mut bop_mpmc_blocking, item: u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue_token(
        token: *mut bop_mpmc_blocking_producer_token,
        item: u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue_bulk(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue_bulk_token(
        token: *mut bop_mpmc_blocking_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_try_enqueue_bulk(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_try_enqueue_bulk_token(
        token: *mut bop_mpmc_blocking_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue(queue: *mut bop_mpmc_blocking, item: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        item: *mut u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_wait(
        queue: *mut bop_mpmc_blocking,
        item: *mut u64,
        timeout_micros: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_wait_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        item: *mut u64,
        timeout_micros: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        max_size: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        items: *mut u64,
        max_size: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk_wait(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        max_size: usize,
        timeout_micros: i64,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk_wait_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        items: *mut u64,
        max_size: usize,
        timeout_micros: i64,
    ) -> i64;
}
#[doc = " The app type."]
pub type uws_app_t = *mut ::std::os::raw::c_void;
#[doc = " The response type."]
pub type uws_res_t = *mut ::std::os::raw::c_void;
#[doc = " The request type."]
pub type uws_req_t = *mut ::std::os::raw::c_void;
#[doc = " The web socket type."]
pub type uws_web_socket_t = *mut ::std::os::raw::c_void;
#[doc = " The loop type."]
pub type uws_loop_t = *mut ::std::os::raw::c_void;
#[doc = " The client app type."]
pub type uws_client_app_t = *mut ::std::os::raw::c_void;
#[doc = " The client connection type."]
pub type uws_client_conn_t = *mut ::std::os::raw::c_void;
#[doc = " The client request type."]
pub type uws_client_req_t = *mut ::std::os::raw::c_void;
#[doc = " The client response type."]
pub type uws_client_res_t = *mut ::std::os::raw::c_void;
#[doc = " The TCP client app type."]
pub type uws_tcp_client_app_t = *mut ::std::os::raw::c_void;
#[doc = " The TCP server app type."]
pub type uws_tcp_server_app_t = *mut ::std::os::raw::c_void;
#[doc = " The TCP connection type."]
pub type uws_tcp_conn_t = *mut ::std::os::raw::c_void;
#[doc = " The SSL options type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_ssl_options_s {
    pub key_file_name: *const ::std::os::raw::c_char,
    pub cert_file_name: *const ::std::os::raw::c_char,
    pub passphrase: *const ::std::os::raw::c_char,
    pub dh_params_file_name: *const ::std::os::raw::c_char,
    pub ca_file_name: *const ::std::os::raw::c_char,
    pub ssl_prefer_low_memory: ::std::os::raw::c_int,
}
impl Default for uws_ssl_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The SSL options type."]
pub type uws_ssl_options_t = uws_ssl_options_s;
unsafe extern "C" {
    #[doc = " Creates an app."]
    pub fn uws_create_app() -> uws_app_t;
}
unsafe extern "C" {
    #[doc = " Creates an SSL app."]
    pub fn uws_create_ssl_app(options: uws_ssl_options_t) -> uws_app_t;
}
unsafe extern "C" {
    #[doc = " Destroys an app."]
    pub fn uws_app_destroy(app: uws_app_t);
}
unsafe extern "C" {
    #[doc = " Checks if an app is SSL."]
    pub fn uws_app_is_ssl(app: uws_app_t) -> bool;
}
pub type uws_http_handler_t = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, res: uws_res_t, req: uws_req_t),
>;
unsafe extern "C" {
    #[doc = " Adds a GET route to the app."]
    pub fn uws_app_get(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a POST route to the app."]
    pub fn uws_app_post(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a PUT route to the app."]
    pub fn uws_app_put(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a DELETE route to the app."]
    pub fn uws_app_del(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a PATCH route to the app."]
    pub fn uws_app_patch(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a OPTIONS route to the app."]
    pub fn uws_app_options(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a ANY route to the app."]
    pub fn uws_app_any(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
pub const uws_opcode_t_UWS_OPCODE_CONTINUE: uws_opcode_t = 0;
pub const uws_opcode_t_UWS_OPCODE_TEXT: uws_opcode_t = 1;
pub const uws_opcode_t_UWS_OPCODE_BINARY: uws_opcode_t = 2;
pub const uws_opcode_t_UWS_OPCODE_CLOSE: uws_opcode_t = 8;
pub const uws_opcode_t_UWS_OPCODE_PING: uws_opcode_t = 9;
pub const uws_opcode_t_UWS_OPCODE_PONG: uws_opcode_t = 10;
#[doc = " The WebSocket opcode."]
pub type uws_opcode_t = ::std::os::raw::c_int;
#[doc = " The WebSocket behavior."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_ws_behavior_s {
    pub compression: u16,
    pub idle_timeout: u16,
    pub max_payload_length: u32,
    pub max_backpressure: u32,
    pub max_lifetime: u16,
    pub close_on_backpressure_limit: bool,
    pub reset_idle_timeout_on_send: bool,
    pub send_pings_automatically: bool,
    pub reserved: bool,
    pub reserved_2: u16,
    pub reserved_3: u32,
    pub upgrade: ::std::option::Option<
        unsafe extern "C" fn(
            res: uws_res_t,
            req: uws_req_t,
            context: *mut ::std::os::raw::c_void,
            per_pattern_user_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub create_user_data: ::std::option::Option<
        unsafe extern "C" fn(
            per_pattern_user_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(ws: uws_web_socket_t, user_data: *mut ::std::os::raw::c_void),
    >,
    pub message: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
            opcode: uws_opcode_t,
        ),
    >,
    pub dropped: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
            opcode: uws_opcode_t,
        ),
    >,
    pub drain: ::std::option::Option<
        unsafe extern "C" fn(ws: uws_web_socket_t, user_data: *mut ::std::os::raw::c_void),
    >,
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            code: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub subscription: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            topic: *const ::std::os::raw::c_char,
            subscriptions: ::std::os::raw::c_int,
            old_subscriptions: ::std::os::raw::c_int,
        ),
    >,
    pub destroy_user_data:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub per_pattern_user_data: *mut ::std::os::raw::c_void,
}
impl Default for uws_ws_behavior_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The WebSocket behavior."]
pub type uws_ws_behavior_t = uws_ws_behavior_s;
unsafe extern "C" {
    pub fn uws_app_ws(
        app: uws_app_t,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        behavior: uws_ws_behavior_t,
    );
}
unsafe extern "C" {
    pub fn uws_app_listen(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        host_length: usize,
        port: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                listen_socket: *mut ::std::os::raw::c_void,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn uws_app_listen_unix(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
        path_length: usize,
        options: ::std::os::raw::c_int,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                listen_socket: *mut ::std::os::raw::c_void,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn uws_app_loop(app: uws_app_t) -> uws_loop_t;
}
unsafe extern "C" {
    pub fn uws_app_run(app: uws_app_t);
}
unsafe extern "C" {
    pub fn uws_loop_defer(
        loop_: uws_loop_t,
        user_data: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(loop_: uws_loop_t, user_data: *mut ::std::os::raw::c_void),
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_socket_context_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Upgrades the response to a WebSocket.\n\n @param res The response.\n @param user_data The user data.\n @param sec_web_socket_key The sec web socket key.\n @param sec_web_socket_key_length The sec web socket key length.\n @param sec_web_socket_protocol The sec web socket protocol.\n @param sec_web_socket_protocol_length The sec web socket protocol length.\n @param sec_web_socket_extensions The sec web socket extensions.\n @param sec_web_socket_extensions_length The sec web socket extensions length.\n @param web_socket_context The web socket context."]
    pub fn uws_res_upgrade(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        sec_web_socket_key: *const ::std::os::raw::c_char,
        sec_web_socket_key_length: usize,
        sec_web_socket_protocol: *const ::std::os::raw::c_char,
        sec_web_socket_protocol_length: usize,
        sec_web_socket_extensions: *const ::std::os::raw::c_char,
        sec_web_socket_extensions_length: usize,
        web_socket_context: *mut us_socket_context_t,
    );
}
unsafe extern "C" {
    #[doc = " Gets the loop of the response.\n\n @param res The response.\n @return The loop."]
    pub fn uws_res_loop(res: uws_res_t) -> uws_loop_t;
}
unsafe extern "C" {
    #[doc = " Defers a handler for the response.\n\n @param res The response.\n @param user_data The user data.\n @param callback The callback."]
    pub fn uws_res_defer(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                loop_: uws_loop_t,
                res: uws_res_t,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    #[doc = " Closes the response.\n\n @param res The response."]
    pub fn uws_res_close(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Pauses the response.\n\n @param res The response."]
    pub fn uws_res_pause(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Resumes the response.\n\n @param res The response."]
    pub fn uws_res_resume(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Gets the native handle of the response.\n\n @param res The response.\n @return The native handle."]
    pub fn uws_res_native_handle(res: uws_res_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Gets the remote address of the response.\n\n @param res The response.\n @param length The length of the remote address.\n @return The remote address."]
    pub fn uws_res_remote_address(
        res: uws_res_t,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Writes a continue to the response.\n\n @param res The response."]
    pub fn uws_res_write_continue(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Writes a status to the response.\n\n @param res The response.\n @param status The status.\n @param status_length The length of the status."]
    pub fn uws_res_write_status(
        res: uws_res_t,
        status: *const ::std::os::raw::c_char,
        status_length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Writes a header to the response.\n\n @param res The response.\n @param key The key.\n @param key_length The length of the key.\n @param value The value.\n @param value_length The length of the value."]
    pub fn uws_res_write_header(
        res: uws_res_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Writes a header to the response.\n\n @param res The response.\n @param key The key.\n @param key_length The length of the key.\n @param value The value."]
    pub fn uws_res_write_header_int(
        res: uws_res_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
        value: u64,
    );
}
unsafe extern "C" {
    #[doc = " Writes data to the response.\n\n @param res The response.\n @param data The data.\n @param length The length of the data."]
    pub fn uws_res_write(res: uws_res_t, data: *const ::std::os::raw::c_char, length: usize);
}
unsafe extern "C" {
    #[doc = " Ends the response without a body.\n\n @param res The response.\n @param reported_content_length The reported content length.\n @param reported_content_length_is_set The reported content length is set.\n @param close_connection The close connection."]
    pub fn uws_res_end_without_body(
        res: uws_res_t,
        reported_content_length: usize,
        reported_content_length_is_set: bool,
        close_connection: bool,
    );
}
unsafe extern "C" {
    #[doc = " Ends the response.\n\n @param res The response.\n @param data The data.\n @param length The length of the data.\n @param close_connection The close connection."]
    pub fn uws_res_end(
        res: uws_res_t,
        data: *const ::std::os::raw::c_char,
        length: usize,
        close_connection: bool,
    );
}
unsafe extern "C" {
    #[doc = " Tries to end the response.\n\n @param res The response.\n @param data The data.\n @param length The length of the data.\n @param total_size The total size.\n @param close_connection The close connection.\n @param has_responded The has responded."]
    pub fn uws_res_try_end(
        res: uws_res_t,
        data: *const ::std::os::raw::c_char,
        length: usize,
        total_size: usize,
        close_connection: bool,
        has_responded: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Writes the offset of the response.\n\n @param res The response.\n @return The offset."]
    pub fn uws_res_write_offset(res: uws_res_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Overwrites the offset of the response.\n\n @param res The response.\n @param offset The offset."]
    pub fn uws_res_override_write_offset(res: uws_res_t, offset: usize);
}
unsafe extern "C" {
    #[doc = " Checks if the response has responded.\n\n @param res The response.\n @return The has responded."]
    pub fn uws_res_has_responded(res: uws_res_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Corks the response.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_cork(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(res: uws_res_t, user_data: *mut ::std::os::raw::c_void),
        >,
    );
}
unsafe extern "C" {
    #[doc = " On writable.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_on_writable(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                res: uws_res_t,
                user_data: *mut ::std::os::raw::c_void,
                m: u64,
            ) -> bool,
        >,
    );
}
unsafe extern "C" {
    #[doc = " On aborted.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_on_aborted(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(res: uws_res_t, user_data: *mut ::std::os::raw::c_void),
        >,
    );
}
unsafe extern "C" {
    #[doc = " On data.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_on_data(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                res: uws_res_t,
                user_data: *mut ::std::os::raw::c_void,
                data: *const ::std::os::raw::c_char,
                data_length: usize,
                fin: bool,
            ),
        >,
    );
}
unsafe extern "C" {
    #[doc = " Gets the method of the request.\n\n @param req The request.\n @param length The length of the method.\n @return The method."]
    pub fn uws_req_get_method(req: uws_req_t, length: *mut usize) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the URL of the request.\n\n @param req The request.\n @param length The length of the URL.\n @return The URL."]
    pub fn uws_req_get_url(req: uws_req_t, length: *mut usize) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the query of the request.\n\n @param req The request.\n @param length The length of the query.\n @return The query."]
    pub fn uws_req_get_query(req: uws_req_t, length: *mut usize) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the header of the request.\n\n @param req The request.\n @param lower_case_name The lower case name of the header.\n @param length The length of the header.\n @return The header."]
    pub fn uws_req_get_header(
        req: uws_req_t,
        lower_case_name: *const ::std::os::raw::c_char,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the header count of the request.\n\n @param req The request.\n @return The header count."]
    pub fn uws_req_get_header_count(req: uws_req_t) -> usize;
}
#[doc = " A string view.\n\n @param data The data.\n @param length The length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_string_view_t {
    pub data: *const ::std::os::raw::c_char,
    pub length: usize,
}
impl Default for uws_string_view_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The HTTP header.\n\n @param key The key.\n @param value The value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_http_header_t {
    pub key: uws_string_view_t,
    pub value: uws_string_view_t,
}
impl Default for uws_http_header_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Gets the header at the index of the request.\n\n @param req The request.\n @param index The index.\n @param header The header."]
    pub fn uws_req_get_header_at(req: uws_req_t, index: usize, header: *mut uws_http_header_t);
}
unsafe extern "C" {
    #[doc = " Gets the headers of the request.\n\n @param req The request.\n @param headers The headers.\n @param max_headers The maximum headers."]
    pub fn uws_req_get_headers(
        req: uws_req_t,
        headers: *mut uws_http_header_t,
        max_headers: usize,
    ) -> usize;
}
pub const uws_ws_send_status_BACKPRESSURE: uws_ws_send_status = 0;
pub const uws_ws_send_status_SUCCESS: uws_ws_send_status = 1;
pub const uws_ws_send_status_DROPPED: uws_ws_send_status = 2;
#[doc = " The WebSocket send status."]
pub type uws_ws_send_status = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Gets the loop of the web socket.\n\n @param ws The web socket.\n @return The loop."]
    pub fn uws_ws_loop(ws: uws_web_socket_t) -> uws_loop_t;
}
unsafe extern "C" {
    #[doc = " Sends a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param opcode The opcode.\n @param compress The compress.\n @param fin The fin."]
    pub fn uws_ws_send(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        opcode: uws_opcode_t,
        compress: bool,
        fin: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Sends the first fragment of a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param opcode The opcode.\n @param compress The compress."]
    pub fn uws_ws_send_first_fragment(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        opcode: uws_opcode_t,
        compress: bool,
    ) -> uws_ws_send_status;
}
unsafe extern "C" {
    #[doc = " Sends a fragment of a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param compress The compress."]
    pub fn uws_ws_send_fragment(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        compress: bool,
    ) -> uws_ws_send_status;
}
unsafe extern "C" {
    #[doc = " Sends the last fragment of a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param compress The compress."]
    pub fn uws_ws_send_last_fragment(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        compress: bool,
    ) -> uws_ws_send_status;
}
unsafe extern "C" {
    #[doc = " Checks if the web socket has negotiated compression.\n\n @param ws The web socket.\n @return The compression status."]
    pub fn uws_ws_has_negotiated_compression(ws: uws_web_socket_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Ends the web socket.\n\n @param ws The web socket.\n @param code The code.\n @param message The message.\n @param length The length of the message."]
    pub fn uws_ws_end(
        ws: uws_web_socket_t,
        code: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Closes the web socket.\n\n @param ws The web socket.\n @param code The code.\n @param message The message.\n @param length The length of the message."]
    pub fn uws_ws_close(
        ws: uws_web_socket_t,
        code: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Gets the user data of the web socket.\n\n @param ws The web socket.\n @return The user data."]
    pub fn uws_ws_get_user_data(ws: uws_web_socket_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " The cork handler type."]
pub type uws_ws_cork_handler_t = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, ws: uws_web_socket_t),
>;
unsafe extern "C" {
    #[doc = " Corks the web socket.\n\n @param ws The web socket.\n @param user_data The user data.\n @param handler The cork handler."]
    pub fn uws_ws_cork(
        ws: uws_web_socket_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: uws_ws_cork_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Subscribes to a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic."]
    pub fn uws_ws_subscribe(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Unsubscribes from a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic."]
    pub fn uws_ws_unsubscribe(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if the web socket is subscribed to a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic."]
    pub fn uws_ws_is_subscribed(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Publishes a message to a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic.\n @param message The message.\n @param message_length The length of the message.\n @param opcode The opcode.\n @param compress The compress."]
    pub fn uws_ws_publish(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
        message: *const ::std::os::raw::c_char,
        message_length: usize,
        opcode: uws_opcode_t,
        compress: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the buffered amount of the web socket.\n\n @param ws The web socket.\n @return The buffered amount."]
    pub fn uws_ws_get_buffered_amount(ws: uws_web_socket_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Gets the remote address of the web socket.\n\n @param ws The web socket.\n @param length The length of the remote address.\n @return The remote address."]
    pub fn uws_ws_get_remote_address(
        ws: uws_web_socket_t,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Publishes a message to a topic.\n\n @param app The app.\n @param topic The topic.\n @param message The message.\n @param length The length of the message.\n @param opcode The opcode.\n @param compress The compress."]
    pub fn uws_app_publish(
        app: uws_app_t,
        topic: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        length: usize,
        opcode: uws_opcode_t,
        compress: bool,
    ) -> bool;
}
#[doc = " The TCP behavior type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uws_tcp_behavior_s {
    pub idle_timeout_seconds: u32,
    pub long_timeout_minutes: u32,
    pub max_backpressure_bytes: u32,
    pub conn_user_data_size: u16,
    pub close_on_backpressure_limit: bool,
    pub reset_idle_timeout_on_send: bool,
    pub on_open: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_close: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            code: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub on_connect_error: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            code: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub on_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            data: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub on_writable:
        ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t, remaining: u64)>,
    pub on_drain: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_dropped: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            data: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub on_end: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_timeout: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_long_timeout: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_server_name: ::std::option::Option<
        unsafe extern "C" fn(conn: uws_tcp_conn_t, server_name: *const ::std::os::raw::c_char),
    >,
}
#[doc = " The TCP behavior type."]
pub type uws_tcp_behavior_t = uws_tcp_behavior_s;
unsafe extern "C" {
    #[doc = " Creates a TCP server app.\n\n @param behavior The behavior of the TCP server.\n @param listener_host The host to listen on.\n @param listener_host_length The length of the listener host.\n @param listener_port The port to listen on.\n @param listener_options The options for the listener."]
    pub fn uws_create_tcp_server_app(
        behavior: uws_tcp_behavior_t,
        listener_host: *const ::std::os::raw::c_char,
        listener_host_length: usize,
        listener_port: ::std::os::raw::c_int,
        listener_options: ::std::os::raw::c_int,
    ) -> uws_tcp_server_app_t;
}
unsafe extern "C" {
    #[doc = " Creates a TCP server SSL app.\n\n @param behavior The behavior of the TCP server.\n @param listener_host The host to listen on.\n @param listener_host_length The length of the listener host.\n @param listener_port The port to listen on.\n @param listener_options The options for the listener.\n @param ssl_options The SSL options.\n @param server_names The server names.\n @param server_names_length The length of the server names."]
    pub fn uws_create_tcp_server_ssl_app(
        behavior: uws_tcp_behavior_t,
        listener_host: *const ::std::os::raw::c_char,
        listener_host_length: usize,
        listener_port: ::std::os::raw::c_int,
        listener_options: ::std::os::raw::c_int,
        ssl_options: uws_ssl_options_t,
        server_names: *mut *const ::std::os::raw::c_char,
        server_names_length: usize,
    ) -> uws_tcp_server_app_t;
}
unsafe extern "C" {
    #[doc = " Creates a TCP client app.\n\n @param behavior The behavior of the TCP client."]
    pub fn uws_create_tcp_client_app(behavior: uws_tcp_behavior_t) -> uws_tcp_client_app_t;
}
unsafe extern "C" {
    #[doc = " Creates a TCP client SSL app.\n\n @param behavior The behavior of the TCP client.\n @param ssl_options The SSL options."]
    pub fn uws_create_tcp_client_ssl_app(
        behavior: uws_tcp_behavior_t,
        ssl_options: uws_ssl_options_t,
    ) -> uws_tcp_client_app_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
