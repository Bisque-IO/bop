/* automatically generated by rust-bindgen 0.72.1 */

pub const LIBUS_RECV_BUFFER_LENGTH: u32 = 524288;
pub const LIBUS_TIMEOUT_GRANULARITY: u32 = 4;
pub const LIBUS_RECV_BUFFER_PADDING: u32 = 32;
pub const LIBUS_EXT_ALIGNMENT: u32 = 16;
pub const MDBX_VERSION_MAJOR: u32 = 0;
pub const MDBX_VERSION_MINOR: u32 = 13;
pub const MDBX_MANUAL_MODULE_HANDLER: u32 = 0;
pub const MDBX_LOCKNAME_W: &[u8; 10] = b"\\mdbx.lck\0";
pub const MDBX_LOCKNAME_A: &[u8; 10] = b"\\mdbx.lck\0";
pub const MDBX_LOCKNAME: &[u8; 10] = b"\\mdbx.lck\0";
pub const MDBX_DATANAME_W: &[u8; 10] = b"\\mdbx.dat\0";
pub const MDBX_DATANAME_A: &[u8; 10] = b"\\mdbx.dat\0";
pub const MDBX_DATANAME: &[u8; 10] = b"\\mdbx.dat\0";
pub const MDBX_LOCK_SUFFIX_W: &[u8; 5] = b"-lck\0";
pub const MDBX_LOCK_SUFFIX_A: &[u8; 5] = b"-lck\0";
pub const MDBX_LOCK_SUFFIX: &[u8; 5] = b"-lck\0";
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn bop_alloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_zalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_calloc(element_size: usize, count: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_alloc_aligned(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_zalloc_aligned(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_realloc(
        p: *mut ::std::os::raw::c_void,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_dealloc(p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn bop_dealloc_sized(p: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    pub fn bop_heap_access(data: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    pub fn bop_malloc_usable_size(data: *const ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    pub fn bop_size_of_shared_ptr() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_buffer_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_buffer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_buffer_new(size: usize) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_free(buf: *mut bop_raft_buffer);
}
unsafe extern "C" {
    pub fn bop_raft_buffer_data(buf: *mut bop_raft_buffer) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_container_size(buf: *mut bop_raft_buffer) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_size(buf: *mut bop_raft_buffer) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_pos(buf: *mut bop_raft_buffer) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_buffer_set_pos(buf: *mut bop_raft_buffer, pos: usize);
}
pub type bop_raft_async_bool_when_ready = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        result: bool,
        error: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_async_bool_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_make(
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_bool_when_ready,
    ) -> *mut bop_raft_async_bool_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_delete(self_: *const bop_raft_async_bool_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_get_user_data(
        self_: *const bop_raft_async_bool_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_set_user_data(
        self_: *mut bop_raft_async_bool_ptr,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_get_when_ready(
        self_: *const bop_raft_async_bool_ptr,
    ) -> bop_raft_async_bool_when_ready;
}
unsafe extern "C" {
    pub fn bop_raft_async_bool_set_when_ready(
        self_: *mut bop_raft_async_bool_ptr,
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_bool_when_ready,
    );
}
pub type bop_raft_async_u64_when_ready = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        result: u64,
        error: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_async_u64_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_make(
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_u64_when_ready,
    ) -> *mut bop_raft_async_u64_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_delete(self_: *const bop_raft_async_u64_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_get_user_data(
        self_: *const bop_raft_async_u64_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_set_user_data(
        self_: *mut bop_raft_async_u64_ptr,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_get_when_ready(
        self_: *const bop_raft_async_u64_ptr,
    ) -> bop_raft_async_u64_when_ready;
}
unsafe extern "C" {
    pub fn bop_raft_async_u64_set_when_ready(
        self_: *mut bop_raft_async_u64_ptr,
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_u64_when_ready,
    );
}
#[doc = "\n nuraft::cmd_result<nuraft::ptr<nuraft::buffer>>\n"]
pub type bop_raft_async_buffer_when_ready = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        result: *mut bop_raft_buffer,
        error: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_async_buffer_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_make(
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_buffer_when_ready,
    ) -> *mut bop_raft_async_buffer_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_delete(self_: *const bop_raft_async_buffer_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_get_user_data(
        self_: *const bop_raft_async_buffer_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_set_user_data(
        self_: *mut bop_raft_async_buffer_ptr,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_get_when_ready(
        self_: *const bop_raft_async_buffer_ptr,
    ) -> bop_raft_async_buffer_when_ready;
}
unsafe extern "C" {
    pub fn bop_raft_async_buffer_set_when_ready(
        self_: *mut bop_raft_async_buffer_ptr,
        user_data: *mut ::std::os::raw::c_void,
        when_ready: bop_raft_async_buffer_when_ready,
    );
}
#[doc = "\n nuraft::snapshot\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_snapshot {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_snapshot_serialize(snapshot: *mut bop_raft_snapshot) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_snapshot_deserialize(buf: *mut bop_raft_buffer) -> *mut bop_raft_snapshot;
}
#[doc = "\n nuraft::cluster_config\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cluster_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cluster_config_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_config {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_new() -> *mut bop_raft_cluster_config;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_ptr_make(
        config: *mut bop_raft_cluster_config,
    ) -> *mut bop_raft_cluster_config_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_free(config: *const bop_raft_cluster_config);
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_ptr_delete(config: *const bop_raft_cluster_config_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_ptr_get(
        conf: *mut bop_raft_cluster_config_ptr,
    ) -> *mut bop_raft_cluster_config;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_serialize(
        conf: *mut bop_raft_cluster_config,
    ) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_deserialize(
        buf: *mut bop_raft_buffer,
    ) -> *mut bop_raft_cluster_config;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_log_idx(cfg: *mut bop_raft_cluster_config) -> u64;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_prev_log_idx(cfg: *mut bop_raft_cluster_config) -> u64;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_is_async_replication(cfg: *mut bop_raft_cluster_config) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_user_ctx(
        cfg: *mut bop_raft_cluster_config,
        out_data: *mut ::std::os::raw::c_char,
        out_data_size: usize,
    );
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_user_ctx_size(cfg: *mut bop_raft_cluster_config) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_servers_size(cfg: *mut bop_raft_cluster_config) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_cluster_config_server(
        cfg: *mut bop_raft_cluster_config,
        idx: i32,
    ) -> *mut bop_raft_srv_config;
}
#[doc = "\n bop_raft_srv_config\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_config_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_config_vec {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_make() -> *mut bop_raft_srv_config_vec;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_delete(vec: *const bop_raft_srv_config_vec);
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_size(vec: *mut bop_raft_srv_config_vec) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_vec_get(
        vec: *mut bop_raft_srv_config_vec,
        idx: usize,
    ) -> *mut bop_raft_srv_config;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_ptr_make(
        config: *mut bop_raft_srv_config,
    ) -> *mut bop_raft_srv_config_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_ptr_delete(config: *const bop_raft_srv_config_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_make(
        id: i32,
        dc_id: i32,
        endpoint: *const ::std::os::raw::c_char,
        endpoint_size: usize,
        aux: *const ::std::os::raw::c_char,
        aux_size: usize,
        learner: bool,
        priority: i32,
    ) -> *mut bop_raft_srv_config;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_delete(config: *const bop_raft_srv_config);
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_id(cfg: *mut bop_raft_srv_config) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_dc_id(cfg: *mut bop_raft_srv_config) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_endpoint(
        cfg: *mut bop_raft_srv_config,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_endpoint_size(cfg: *mut bop_raft_srv_config) -> usize;
}
unsafe extern "C" {
    #[doc = " Custom string given by user.\n WARNING: It SHOULD NOT contain NULL character,\n          as\n it will be stored as a C-style string."]
    pub fn bop_raft_srv_config_aux(cfg: *mut bop_raft_srv_config) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_aux_size(cfg: *mut bop_raft_srv_config) -> usize;
}
unsafe extern "C" {
    #[doc = " `true` if this node is learner.\n Learner will not initiate or participate in leader\n election."]
    pub fn bop_raft_srv_config_is_learner(cfg: *mut bop_raft_srv_config) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_set_is_learner(cfg: *mut bop_raft_srv_config, learner: bool);
}
unsafe extern "C" {
    #[doc = " `true` if this node is a new joiner, but not yet fully synced.\n New joiner will not\n initiate or participate in leader election."]
    pub fn bop_raft_srv_config_is_new_joiner(cfg: *mut bop_raft_srv_config) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_set_new_joiner(cfg: *mut bop_raft_srv_config, new_joiner: bool);
}
unsafe extern "C" {
    #[doc = " Priority of this node.\n 0 will never be a leader."]
    pub fn bop_raft_srv_config_priority(cfg: *mut bop_raft_srv_config) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_srv_config_set_priority(cfg: *mut bop_raft_srv_config, priority: i32);
}
#[doc = "\n nuraft::svr_state\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_srv_state {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_srv_state_serialize(state: *mut bop_raft_srv_state) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    pub fn bop_raft_srv_state_deserialize(buf: *mut bop_raft_buffer) -> *mut bop_raft_srv_state;
}
unsafe extern "C" {
    pub fn bop_raft_srv_state_delete(state: *const bop_raft_srv_state);
}
unsafe extern "C" {
    #[doc = " Term"]
    pub fn bop_raft_srv_state_term(state: *const bop_raft_srv_state) -> u64;
}
unsafe extern "C" {
    #[doc = " Server ID that this server voted for.\n `-1` if not voted."]
    pub fn bop_raft_srv_state_voted_for(state: *const bop_raft_srv_state) -> i32;
}
unsafe extern "C" {
    #[doc = " `true` if election timer is allowed."]
    pub fn bop_raft_srv_state_is_election_timer_allowed(state: *const bop_raft_srv_state) -> bool;
}
unsafe extern "C" {
    #[doc = " true if this server has joined the cluster but has not yet\n fully caught up with the latest\n log. While in the catch-up status,\n this server will not receive normal append_entries\n requests."]
    pub fn bop_raft_srv_state_is_catching_up(state: *const bop_raft_srv_state) -> bool;
}
unsafe extern "C" {
    #[doc = " `true` if this server is receiving a snapshot.\n Same as `catching_up_`, it must be a\n durable flag so as not to be\n reset after restart. While this flag is set, this server will\n neither\n receive normal append_entries requests nor initiate election."]
    pub fn bop_raft_srv_state_is_receiving_snapshot(state: *const bop_raft_srv_state) -> bool;
}
#[doc = "\n nuraft::logger\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_logger_ptr {
    _unused: [u8; 0],
}
#[doc = " Put a log with level, line number, function name,\n and file name.\n\n Log level info:\n\n Trace:    6\n    Debug:    5\n    Info:     4\n    Warning:  3\n    Error:    2\n    Fatal:\n 1\n\n @param level Level of given log.\n @param source_file Name of file where the log is\n located.\n @param func_name Name of function where the log is located.\n @param line_number\n Line number of the log.\n @param log_line Contents of the log."]
pub type bop_raft_logger_put_details_func = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        level: i32,
        source_file: *const ::std::os::raw::c_char,
        func_name: *const ::std::os::raw::c_char,
        line_number: usize,
        log_line: *const ::std::os::raw::c_char,
        log_line_size: usize,
    ),
>;
unsafe extern "C" {
    pub fn bop_raft_logger_make(
        user_data: *mut ::std::os::raw::c_void,
        callback: bop_raft_logger_put_details_func,
    ) -> *mut bop_raft_logger_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_logger_delete(logger: *const bop_raft_logger_ptr);
}
#[doc = "\n nuraft::asio_service\n"]
pub type bop_raft_asio_service_worker_start_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, value: u32)>;
pub type bop_raft_asio_service_worker_stop_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, value: u32)>;
pub type bop_raft_asio_service_verify_sn_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSL_CTX {
    _unused: [u8; 0],
}
pub type bop_raft_asio_service_ssl_ctx_provider_fn = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut SSL_CTX,
>;
pub type bop_raft_asio_service_custom_resolver_response_fn = ::std::option::Option<
    unsafe extern "C" fn(
        response_impl: *mut ::std::os::raw::c_void,
        v1: *const ::std::os::raw::c_char,
        v1_size: usize,
        v2: *const ::std::os::raw::c_char,
        v2_size: usize,
        error_code: i32,
    ),
>;
pub type bop_raft_asio_service_custom_resolver_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        response_impl: *mut ::std::os::raw::c_void,
        v1: *const ::std::os::raw::c_char,
        v1_size: usize,
        v2: *const ::std::os::raw::c_char,
        v2_size: usize,
        response: bop_raft_asio_service_custom_resolver_response_fn,
    ),
>;
pub type bop_raft_asio_service_corrupted_msg_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        header: *mut ::std::os::raw::c_uchar,
        header_size: usize,
        payload: *mut ::std::os::raw::c_uchar,
        payload_size: usize,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_asio_service_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_asio_options {
    pub thread_pool_size: usize,
    pub worker_start_user_data: *mut ::std::os::raw::c_void,
    pub worker_start: bop_raft_asio_service_worker_start_fn,
    pub worker_stop_user_data: *mut ::std::os::raw::c_void,
    pub worker_stop: bop_raft_asio_service_worker_stop_fn,
    pub enable_ssl: bool,
    pub skip_verification: bool,
    pub server_cert_file: *mut ::std::os::raw::c_char,
    pub server_key_file: *mut ::std::os::raw::c_char,
    pub root_cert_file: *mut ::std::os::raw::c_char,
    pub invoke_req_cb_on_empty_meta: bool,
    pub invoke_resp_cb_on_empty_meta: bool,
    pub verify_sn_user_data: *mut ::std::os::raw::c_void,
    pub verify_sn: bop_raft_asio_service_verify_sn_fn,
    pub ssl_context_provider_server_user_data: *mut ::std::os::raw::c_void,
    pub ssl_context_provider_server: bop_raft_asio_service_ssl_ctx_provider_fn,
    pub ssl_context_provider_client_user_data: *mut ::std::os::raw::c_void,
    pub ssl_context_provider_client: bop_raft_asio_service_ssl_ctx_provider_fn,
    pub custom_resolver_user_data: *mut ::std::os::raw::c_void,
    pub custom_resolver: bop_raft_asio_service_custom_resolver_fn,
    pub replicate_log_timestamp: bool,
    pub crc_on_entire_message: bool,
    pub crc_on_payload: bool,
    pub corrupted_msg_handler_user_data: *mut ::std::os::raw::c_void,
    pub corrupted_msg_handler: bop_raft_asio_service_corrupted_msg_handler_fn,
    pub streaming_mode: bool,
}
impl Default for bop_raft_asio_options {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_make(
        options: *mut bop_raft_asio_options,
        logger: *mut bop_raft_logger_ptr,
    ) -> *mut bop_raft_asio_service_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_delete(asio_service: *const bop_raft_asio_service_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_stop(asio_service: *mut bop_raft_asio_service_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_get_active_workers(
        asio_service: *mut bop_raft_asio_service_ptr,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_delayed_task_ptr {
    _unused: [u8; 0],
}
pub type bop_raft_delayed_task_func =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn bop_raft_delayed_task_make(
        user_data: *mut ::std::os::raw::c_void,
        type_: i32,
        exec_func: bop_raft_delayed_task_func,
        deleter_func: bop_raft_delayed_task_func,
    ) -> *mut bop_raft_delayed_task_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_delete(task: *const bop_raft_delayed_task_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_cancel(task: *mut bop_raft_delayed_task_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_reset(task: *mut bop_raft_delayed_task_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_type(task: *mut bop_raft_delayed_task_ptr) -> i32;
}
unsafe extern "C" {
    pub fn bop_raft_delayed_task_user_data(
        task: *mut bop_raft_delayed_task_ptr,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn bop_raft_asio_service_schedule(
        asio_service: *mut bop_raft_asio_service_ptr,
        delayed_task: *mut bop_raft_delayed_task_ptr,
        milliseconds: i32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_rpc_listener_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_listener_make(
        asio_service: *mut bop_raft_asio_service_ptr,
        listening_port: u16,
        logger: *mut bop_raft_logger_ptr,
    ) -> *mut bop_raft_rpc_listener_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_listener_delete(rpc_listener: *const bop_raft_rpc_listener_ptr);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_rpc_client_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_client_make(
        asio_service: *mut bop_raft_asio_service_ptr,
        endpoint: *const ::std::os::raw::c_char,
        endpoint_size: usize,
    ) -> *mut bop_raft_rpc_client_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_asio_rpc_client_delete(rpc_client: *const bop_raft_rpc_client_ptr);
}
pub const bop_raft_params_locking_method_type_bop_raft_params_locking_method_single_mutex:
    bop_raft_params_locking_method_type = 0;
pub const bop_raft_params_locking_method_type_bop_raft_params_locking_method_dual_mutex:
    bop_raft_params_locking_method_type = 1;
pub const bop_raft_params_locking_method_type_bop_raft_params_locking_method_dual_rw_mutex:
    bop_raft_params_locking_method_type = 2;
#[doc = "\n nuraft::raft_params\n"]
pub type bop_raft_params_locking_method_type = i32;
pub const bop_raft_params_return_method_type_bop_raft_params_return_method_blocking:
    bop_raft_params_return_method_type = 0;
pub const bop_raft_params_return_method_type_bop_raft_params_return_method_async_handler:
    bop_raft_params_return_method_type = 1;
pub type bop_raft_params_return_method_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_params {
    #[doc = " Upper bound of election timer, in millisecond."]
    pub election_timeout_upper_bound: i32,
    #[doc = " Lower bound of election timer, in millisecond."]
    pub election_timeout_lower_bound: i32,
    #[doc = " Heartbeat interval, in millisecond."]
    pub heart_beat_interval: i32,
    #[doc = " Backoff time when RPC failure happens, in millisecond."]
    pub rpc_failure_backoff: i32,
    #[doc = " Max number of logs that can be packed in a RPC\n for catch-up of joining an\n empty node."]
    pub log_sync_batch_size: i32,
    #[doc = " Log gap (the number of logs) to stop catch-up of\n joining a new node. Once this\n condition meets,\n that newly joined node is added to peer list\n and starts to\n receive heartbeat from leader.\n\n If zero, the new node will be added to the peer\n list\n immediately."]
    pub log_sync_stop_gap: i32,
    #[doc = " Log gap (the number of logs) to create a Raft snapshot."]
    pub snapshot_distance: i32,
    #[doc = " (Deprecated)."]
    pub snapshot_block_size: i32,
    #[doc = " Timeout(ms) for snapshot_sync_ctx, if a single snapshot syncing request\n\n exceeds this, it will be considered as timeout and ctx will be released.\n 0 means it\n will be set to the default value\n `heart_beat_interval_ * response_limit_`."]
    pub snapshot_sync_ctx_timeout: i32,
    #[doc = " Enable randomized snapshot creation which will avoid\n simultaneous snapshot\n creation among cluster members.\n It is achieved by randomizing the distance of the\n\n * first snapshot. From the second snapshot, the fixed\n distance given by\n snapshot_distance_ will be used."]
    pub enable_randomized_snapshot_creation: bool,
    #[doc = " Max number of logs that can be packed in a RPC\n for append entry request."]
    pub max_append_size: i32,
    #[doc = " Minimum number of logs that will be preserved\n (i.e., protected from log\n compaction) since the\n last Raft snapshot."]
    pub reserved_log_items: i32,
    #[doc = " Client request timeout in millisecond."]
    pub client_req_timeout: i32,
    #[doc = " Log gap (compared to the leader's latest log)\n for treating this node as\n fresh."]
    pub fresh_log_gap: i32,
    #[doc = " Log gap (compared to the leader's latest log)\n for treating this node as\n stale."]
    pub stale_log_gap: i32,
    #[doc = " Custom quorum size for commit.\n If set to zero, the default quorum size will be\n used."]
    pub custom_commit_quorum_size: i32,
    #[doc = " Custom quorum size for leader election.\n If set to zero, the default quorum\n size will be used."]
    pub custom_election_quorum_size: i32,
    #[doc = " Expiration time of leadership in millisecond.\n If more than quorum nodes do not\n respond within\n this time, the current leader will immediately\n yield its\n leadership and become follower.\n If 0, it is automatically set to `heartbeat * 20`.\n\n * If negative number, leadership will never be expired\n (the same as the original Raft\n logic)."]
    pub leadership_expiry: i32,
    #[doc = " Minimum wait time required for transferring the leadership\n in millisecond. If\n this value is non-zero, and the below\n conditions are met together,\n   - the\n elapsed time since this server became a leader\n     is longer than this number, and\n\n - the current leader's priority is not the highest one, and\n   - all peers are\n responding, and\n   - the log gaps of all peers are smaller than `stale_log_gap_`, and\n\n *   - `allow_leadership_transfer` of the state machine returns true,\n then the current\n leader will transfer its leadership to the peer\n with the highest priority."]
    pub leadership_transfer_min_wait_time: i32,
    #[doc = " If true, zero-priority member can initiate vote\n when leader is not elected\n long time (that can happen\n only the zero-priority member has the latest log).\n\n Once the zero-priority member becomes a leader,\n it will immediately yield leadership\n so that other\n higher priority node can takeover."]
    pub allow_temporary_zero_priority_leader: bool,
    #[doc = " If true, follower node will forward client request\n to the current leader.\n\n * Otherwise, it will return error to client immediately."]
    pub auto_forwarding: bool,
    #[doc = " The maximum number of connections for auto forwarding (if enabled)."]
    pub auto_forwarding_max_connections: i32,
    #[doc = " If true, creating replication (append_entries) requests will be\n done by a\n background thread, instead of doing it in user threads.\n There can be some delay a\n little bit, but it improves reducing\n the lock contention."]
    pub use_bg_thread_for_urgent_commit: bool,
    #[doc = " If true, a server who is currently receiving snapshot will not be\n counted in\n quorum. It is useful when there are only two servers\n in the cluster. Once the follower\n is receiving snapshot, the\n leader cannot make any progress."]
    pub exclude_snp_receiver_from_quorum: bool,
    #[doc = " If `true` and the size of the cluster is 2, the quorum size\n will be adjusted\n to 1 automatically, once one of two nodes\n becomes offline."]
    pub auto_adjust_quorum_for_small_cluster: bool,
    #[doc = " Choose the type of lock that will be used by user threads."]
    pub locking_method_type: bop_raft_params_locking_method_type,
    #[doc = " To choose blocking call or asynchronous call."]
    pub return_method: bop_raft_params_return_method_type,
    #[doc = " Wait ms for response after forwarding request to leader.\n must be larger than\n client_req_timeout_.\n If 0, there will be no timeout for auto forwarding."]
    pub auto_forwarding_req_timeout: i32,
    #[doc = " If non-zero, any server whose state machine's commit index is\n lagging behind\n the last committed log index will not\n initiate vote requests for the given amount of\n time\n in milliseconds.\n\n The purpose of this option is to avoid a server\n (whose state\n machine is still catching up with the committed logs and does\n not\n contain the latest data yet) being a leader."]
    pub grace_period_of_lagging_state_machine: i32,
    #[doc = " If `true`, the new joiner will be added to cluster config as a `new_joiner`\n\n even before syncing all data. The new joiner will not initiate a vote or\n participate\n in leader election.\n\n Once the log gap becomes smaller than `log_sync_stop_gap_`,\n the new joiner\n will be a regular member.\n\n The purpose of this featuer is\n to preserve the new joiner information\n even after leader re-election, in order to let\n the new leader continue\n the sync process without calling `add_srv` again."]
    pub use_new_joiner_type: bool,
    #[doc = " (Experimental)\n If `true`, reading snapshot objects will be done by a\n background thread\n asynchronously instead of synchronous read by Raft worker threads.\n\n * Asynchronous IO will reduce the overall latency of the leader's operations."]
    pub use_bg_thread_for_snapshot_io: bool,
    #[doc = " (Experimental)\n If `true`, it will commit a log upon the agreement of all\n healthy members.\n In other words, with this option, all healthy members have the log at\n the\n moment the leader commits the log. If the number of healthy members is\n\n smaller than the regular (or configured custom) quorum size, the leader\n cannot commit\n the log.\n\n A member becomes \"unhealthy\" if it does not respond to the leader's\n\n * request for a configured time (`response_limit_`)."]
    pub use_full_consensus_among_healthy_members: bool,
    #[doc = " (Experimental)\n If `true`, the leader will track the commit index of each peers' state machine.\n It can be used along with `use_full_consensus_among_healthy_members_`"]
    pub track_peers_sm_commit_idx: bool,
    #[doc = " (Experimental)\n If `true`, users can let the leader append logs parallel with\n their\n replication. To implement parallel log appending, users need to make\n\n `log_store::append`, `log_store::write_at`, or\n `log_store::end_of_append_batch` API\n triggers asynchronous disk writes\n without blocking the thread. Even while the disk\n write is in progress,\n the other read APIs of log store should be able to read the\n log.\n\n The replication and the disk write will be executed in parallel,\n\n and users need to call `raft_server::notify_log_append_completion`\n when the\n asynchronous disk write is done. Also, users need to properly\n implement\n `log_store::last_durable_index` API to return the most recent\n durable log index. The\n leader will commit the log based on the\n result of this API.\n\n   - If the\n disk write is done earlier than the replication,\n     the commit behavior is the same\n as the original protocol.\n\n   - If the replication is done earlier than the disk\n write,\n     the leader will commit the log based on the quorum except\n     for\n the leader itself. The leader can apply the log to\n     the state machine even before\n completing the disk write\n     of the log.\n\n Note that parallel log\n appending is available for the leader only,\n and followers will wait for\n `notify_log_append_completion` call\n before returning the response."]
    pub parallel_log_appending: bool,
    #[doc = " If non-zero, streaming mode is enabled and `append_entries` requests are\n\n dispatched instantly without awaiting the response from the prior request.\n,\n The\n count of logs in-flight will be capped by this value, allowing it\n to function as a\n throttling mechanism, in conjunction with\n `max_bytes_in_flight_in_stream_`."]
    pub max_log_gap_in_stream: i32,
    #[doc = " If non-zero, the volume of data in-flight will be restricted to this\n specified\n byte limit. This limitation is effective only in streaming mode."]
    pub max_bytes_in_flight_in_stream: i64,
}
impl Default for bop_raft_params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_params_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_params_make() -> *mut bop_raft_params;
}
unsafe extern "C" {
    pub fn bop_raft_params_delete(params: *const bop_raft_params);
}
#[doc = "\n nuraft::state_machine\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_fsm_ptr {
    _unused: [u8; 0],
}
pub type bop_raft_fsm_commit = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_idx: u64,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
        result: *mut *mut bop_raft_buffer,
    ),
>;
pub type bop_raft_fsm_cluster_config = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_idx: u64,
        new_conf: *mut ::std::os::raw::c_void,
    ),
>;
pub type bop_raft_fsm_rollback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_idx: u64,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
    ),
>;
pub type bop_raft_fsm_get_next_batch_size_hint_in_bytes =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> i64>;
pub type bop_raft_fsm_snapshot_save = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        last_log_idx: u64,
        last_log_term: u64,
        last_config: *mut bop_raft_cluster_config,
        size: u64,
        type_: u8,
        is_first_obj: bool,
        is_last_obj: bool,
        data: *const ::std::os::raw::c_uchar,
        data_size: usize,
    ),
>;
pub type bop_raft_fsm_snapshot_apply = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        last_log_idx: u64,
        last_log_term: u64,
        last_config: *mut bop_raft_cluster_config,
        size: u64,
        type_: u8,
    ) -> bool,
>;
pub type bop_raft_fsm_snapshot_read = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        user_snapshot_ctx: *mut *mut ::std::os::raw::c_void,
        obj_id: u64,
        data_out: *mut *mut bop_raft_buffer,
        is_last_obj: *mut bool,
    ) -> i32,
>;
pub type bop_raft_fsm_free_user_snapshot_ctx = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        user_snapshot_ctx: *mut *mut ::std::os::raw::c_void,
    ),
>;
pub type bop_raft_fsm_last_snapshot = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_snapshot,
>;
pub type bop_raft_fsm_last_commit_index =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
pub type bop_raft_fsm_create_snapshot = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        snapshot: *mut bop_raft_snapshot,
        snapshot_data: *mut bop_raft_buffer,
        snp_data: *mut ::std::os::raw::c_void,
        snp_data_size: usize,
    ),
>;
pub type bop_raft_fsm_chk_create_snapshot =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> bool>;
pub type bop_raft_fsm_allow_leadership_transfer =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_fsm_adjust_commit_index_params {
    _unused: [u8; 0],
}
pub type bop_raft_fsm_adjust_commit_index = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        current_commit_index: u64,
        expected_commit_index: u64,
        params: *const bop_raft_fsm_adjust_commit_index_params,
    ) -> u64,
>;
unsafe extern "C" {
    pub fn bop_raft_fsm_adjust_commit_index_peer_index(
        params: *mut bop_raft_fsm_adjust_commit_index_params,
        peerID: i32,
    ) -> u64;
}
unsafe extern "C" {
    pub fn bop_raft_fsm_adjust_commit_index_peer_indexes(
        params: *mut bop_raft_fsm_adjust_commit_index_params,
        peers: *mut *mut u64,
    );
}
unsafe extern "C" {
    pub fn bop_raft_fsm_make(
        user_data: *mut ::std::os::raw::c_void,
        current_conf: *mut bop_raft_cluster_config,
        rollback_conf: *mut bop_raft_cluster_config,
        commit: bop_raft_fsm_commit,
        commit_config: bop_raft_fsm_cluster_config,
        pre_commit: bop_raft_fsm_commit,
        rollback: bop_raft_fsm_rollback,
        rollback_config: bop_raft_fsm_cluster_config,
        get_next_batch_size_hint_in_bytes: bop_raft_fsm_get_next_batch_size_hint_in_bytes,
        save_snapshot: bop_raft_fsm_snapshot_save,
        apply_snapshot: bop_raft_fsm_snapshot_apply,
        read_snapshot: bop_raft_fsm_snapshot_read,
        free_snapshot_user_ctx: bop_raft_fsm_free_user_snapshot_ctx,
        last_snapshot: bop_raft_fsm_last_snapshot,
        last_commit_index: bop_raft_fsm_last_commit_index,
        create_snapshot: bop_raft_fsm_create_snapshot,
        chk_create_snapshot: bop_raft_fsm_chk_create_snapshot,
        allow_leadership_transfer: bop_raft_fsm_allow_leadership_transfer,
        adjust_commit_index: bop_raft_fsm_adjust_commit_index,
    ) -> *mut bop_raft_fsm_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_fsm_delete(fsm: *const bop_raft_fsm_ptr);
}
#[doc = "\n nuraft::state_mgr\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_log_store_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_state_mgr_ptr {
    _unused: [u8; 0],
}
pub type bop_raft_state_mgr_load_config = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_cluster_config,
>;
pub type bop_raft_state_mgr_save_config = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        config: *const bop_raft_cluster_config,
    ),
>;
pub type bop_raft_state_mgr_save_state = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, state: *const bop_raft_srv_state),
>;
pub type bop_raft_state_mgr_read_state = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_srv_state,
>;
pub type bop_raft_state_mgr_load_log_store = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_log_store_ptr,
>;
pub type bop_raft_state_mgr_server_id =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> i32>;
pub type bop_raft_state_mgr_system_exit = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, exit_code: i32),
>;
unsafe extern "C" {
    pub fn bop_raft_state_mgr_make(
        user_data: *mut ::std::os::raw::c_void,
        load_config: bop_raft_state_mgr_load_config,
        save_config: bop_raft_state_mgr_save_config,
        read_state: bop_raft_state_mgr_read_state,
        save_state: bop_raft_state_mgr_save_state,
        load_log_store: bop_raft_state_mgr_load_log_store,
        server_id: bop_raft_state_mgr_server_id,
        system_exit: bop_raft_state_mgr_system_exit,
    ) -> *mut bop_raft_state_mgr_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_state_mgr_delete(sm: *const bop_raft_state_mgr_ptr);
}
unsafe extern "C" {
    #[doc = "\n nuraft::log_store\n"]
    pub static BOP_RAFT_LOG_ENTRY_PTR_SIZE: usize;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bop_raft_log_entry_ptr {
    pub data: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_log_entry {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_log_entry_make(
        term: u64,
        data: *mut bop_raft_buffer,
        timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    ) -> *mut bop_raft_log_entry;
}
unsafe extern "C" {
    pub fn bop_raft_log_entry_delete(entry: *const bop_raft_log_entry);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_log_entry_vector {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_log_entry_vec_push(
        vec: *const bop_raft_log_entry_vector,
        term: u64,
        data: *mut bop_raft_buffer,
        timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    );
}
pub type bop_raft_log_store_next_slot =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
pub type bop_raft_log_store_start_index =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
pub type bop_raft_log_store_last_entry = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut bop_raft_log_entry,
>;
pub type bop_raft_log_store_append = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        log_entry: bop_raft_log_entry_ptr,
        term: u64,
        data: *mut u8,
        data_size: usize,
        log_timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    ) -> u64,
>;
pub type bop_raft_log_store_write_at = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
        term: u64,
        data: *mut u8,
        data_size: usize,
        log_timestamp: u64,
        has_crc32: bool,
        crc32: u32,
    ),
>;
pub type bop_raft_log_store_end_of_append_batch = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, start: u64, cnt: u64),
>;
pub type bop_raft_log_store_log_entries = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        vec: *mut bop_raft_log_entry_vector,
        start: u64,
        end: u64,
    ) -> bool,
>;
pub type bop_raft_log_store_entry_at = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
    ) -> *mut bop_raft_log_entry,
>;
pub type bop_raft_log_store_term_at = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, index: u64) -> u64,
>;
pub type bop_raft_log_store_pack = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
        cnt: i32,
    ) -> *mut bop_raft_buffer,
>;
pub type bop_raft_log_store_apply_pack = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        index: u64,
        pack: *mut bop_raft_buffer,
    ),
>;
pub type bop_raft_log_store_compact = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, last_log_index: u64) -> bool,
>;
pub type bop_raft_log_store_compact_async = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, last_log_index: u64) -> bool,
>;
pub type bop_raft_log_store_flush =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> bool>;
pub type bop_raft_log_store_last_durable_index =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
unsafe extern "C" {
    pub fn bop_raft_log_store_make(
        user_data: *mut ::std::os::raw::c_void,
        next_slot: bop_raft_log_store_next_slot,
        start_index: bop_raft_log_store_start_index,
        last_entry: bop_raft_log_store_last_entry,
        append: bop_raft_log_store_append,
        write_at: bop_raft_log_store_write_at,
        end_of_append_batch: bop_raft_log_store_end_of_append_batch,
        log_entries: bop_raft_log_store_log_entries,
        entry_at: bop_raft_log_store_entry_at,
        term_at: bop_raft_log_store_term_at,
        pack: bop_raft_log_store_pack,
        apply_pack: bop_raft_log_store_apply_pack,
        compact: bop_raft_log_store_compact,
        compact_async: bop_raft_log_store_compact_async,
        flush: bop_raft_log_store_flush,
        last_durable_index: bop_raft_log_store_last_durable_index,
    ) -> *mut bop_raft_log_store_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_log_store_delete(log_store: *const bop_raft_log_store_ptr);
}
#[doc = "\n nuraft::counter\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_counter {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_counter_make(
        name: *const ::std::os::raw::c_char,
        name_size: usize,
    ) -> *mut bop_raft_counter;
}
unsafe extern "C" {
    pub fn bop_raft_counter_delete(counter: *const bop_raft_counter);
}
unsafe extern "C" {
    pub fn bop_raft_counter_name(counter: *const bop_raft_counter)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_counter_value(counter: *const bop_raft_counter) -> u64;
}
#[doc = "\n nuraft::gauge\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_gauge {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_gauge_make(
        name: *const ::std::os::raw::c_char,
        name_size: usize,
    ) -> *mut bop_raft_gauge;
}
unsafe extern "C" {
    pub fn bop_raft_gauge_delete(gauge: *const bop_raft_gauge);
}
unsafe extern "C" {
    pub fn bop_raft_gauge_name(gauge: *const bop_raft_gauge) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_gauge_value(gauge: *const bop_raft_gauge) -> i64;
}
#[doc = "\n nuraft::histogram\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_histogram {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_histogram_make(
        name: *const ::std::os::raw::c_char,
        name_size: usize,
    ) -> *mut bop_raft_histogram;
}
unsafe extern "C" {
    pub fn bop_raft_histogram_delete(histogram: *const bop_raft_histogram);
}
unsafe extern "C" {
    pub fn bop_raft_histogram_name(
        histogram: *const bop_raft_histogram,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bop_raft_histogram_size(histogram: *const bop_raft_histogram) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_histogram_get(histogram: *const bop_raft_histogram, key: f64) -> u64;
}
#[doc = "\n bop_raft_append_entries_ptr\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_append_entries_ptr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_create() -> *mut bop_raft_append_entries_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_delete(self_: *const bop_raft_append_entries_ptr);
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_size(self_: *const bop_raft_append_entries_ptr) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_append_entries_push(
        self_: *mut bop_raft_append_entries_ptr,
        buf: *mut bop_raft_buffer,
    ) -> usize;
}
#[doc = "\n bop_raft_server_peer_info\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bop_raft_server_peer_info {
    #[doc = " Peer ID."]
    pub id: i32,
    #[doc = " The last log index that the peer has, from this server's point of view."]
    pub last_log_idx: u64,
    #[doc = " The elapsed time since the last successful response from this peer, in microseconds."]
    pub last_succ_resp_us: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_server_peer_info_vec {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_make() -> *mut bop_raft_server_peer_info_vec;
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_delete(vec: *const bop_raft_server_peer_info_vec);
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_size(vec: *const bop_raft_server_peer_info_vec) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_server_peer_info_vec_get(
        vec: *const bop_raft_server_peer_info_vec,
        idx: usize,
    ) -> *mut bop_raft_server_peer_info;
}
#[doc = "\n bop_raft_server\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_server_ptr {
    _unused: [u8; 0],
}
pub const bop_raft_server_priority_set_result_bop_raft_server_priority_set_result_set:
    bop_raft_server_priority_set_result = 0;
pub const bop_raft_server_priority_set_result_bop_raft_server_priority_set_result_broadcast:
    bop_raft_server_priority_set_result = 1;
pub const bop_raft_server_priority_set_result_bop_raft_server_priority_set_result_ignored:
    bop_raft_server_priority_set_result = 2;
pub type bop_raft_server_priority_set_result = i32;
#[doc = " Got request from peer or client.\n ctx: pointer to request."]
pub const bop_raft_cb_type_bop_raft_cb_type_process_req: bop_raft_cb_type = 1;
#[doc = " Got append entry response from peer.\n ctx: pointer to new matched index\n number."]
pub const bop_raft_cb_type_bop_raft_cb_type_got_append_entry_resp_from_peer: bop_raft_cb_type = 2;
#[doc = " Appended logs and executed pre-commit locally.\n Happens on leader only.\n\n ctx: pointer to last log number."]
pub const bop_raft_cb_type_bop_raft_cb_type_append_logs: bop_raft_cb_type = 3;
#[doc = " Heartbeat timer wakes up.\n Happens on leader only.\n ctx: pointer to last\n log number."]
pub const bop_raft_cb_type_bop_raft_cb_type_heart_beat: bop_raft_cb_type = 4;
#[doc = " Joined a cluster.\n Happens on follower only.\n ctx: pointer to cluster\n config."]
pub const bop_raft_cb_type_bop_raft_cb_type_joined_cluster: bop_raft_cb_type = 5;
#[doc = " Became a leader.\n ctx: pointer to term number."]
pub const bop_raft_cb_type_bop_raft_cb_type_become_leader: bop_raft_cb_type = 6;
#[doc = " Request append entries to followers.\n Happens on leader only."]
pub const bop_raft_cb_type_bop_raft_cb_type_request_append_entries: bop_raft_cb_type = 7;
#[doc = " Save snapshot chunk or object, in receiver's side.\n ctx: snapshot_sync_req."]
pub const bop_raft_cb_type_bop_raft_cb_type_save_snapshot: bop_raft_cb_type = 8;
#[doc = " Committed a new config.\n ctx: pointer to log index of new config."]
pub const bop_raft_cb_type_bop_raft_cb_type_new_config: bop_raft_cb_type = 9;
#[doc = " Removed from a cluster.\n Happens on follower only.\n ctx: null."]
pub const bop_raft_cb_type_bop_raft_cb_type_removed_from_cluster: bop_raft_cb_type = 10;
#[doc = " Became a follower.\n ctx: pointer to term number."]
pub const bop_raft_cb_type_bop_raft_cb_type_become_follower: bop_raft_cb_type = 11;
#[doc = " The difference of committed log index between the follower and the\n master\n became smaller than a user-specified threshold.\n Happens on follower only.\n ctx:\n null."]
pub const bop_raft_cb_type_bop_raft_cb_type_become_fresh: bop_raft_cb_type = 12;
#[doc = " The difference of committed log index between the follower and the\n master\n became larger than a user-specified threshold.\n Happens on follwer only.\n ctx:\n null"]
pub const bop_raft_cb_type_bop_raft_cb_type_become_stale: bop_raft_cb_type = 13;
#[doc = " Got append entry request from leader.\n It will be invoked only for acceptable\n logs.\n ctx: pointer to request."]
pub const bop_raft_cb_type_bop_raft_cb_type_got_append_entry_req_from_leader: bop_raft_cb_type = 14;
#[doc = " This node is out of log range, which means that\n leader has no valid log or\n snapshot to send for this node.\n ctx: pointer to `OutOfLogRangeWarningArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_out_of_log_range_warning: bop_raft_cb_type = 15;
#[doc = " New connection is established.\n Mostly this event happens in below cases:\n 1)\n Leader sends message to follower, then follower will fire\n      this event.\n   2)\n Candidate sends vote request to peer, then the peer (receiver)\n      will fire this\n event.\n ctx: pointer to `ConnectionArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_connection_opened: bop_raft_cb_type = 16;
#[doc = " Connection is closed.\n ctx: pointer to `ConnectionArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_connection_closed: bop_raft_cb_type = 17;
#[doc = " Invoked when a session receives a message from the valid leader\n first time.\n This callback is preceded by `ConnectionOpened`\n event.\n ctx: pointer to\n `ConnectionArgs`."]
pub const bop_raft_cb_type_bop_raft_cb_type_new_session_from_leader: bop_raft_cb_type = 18;
#[doc = " Executed a log in the state machine.\n ctx: pointer to the log index."]
pub const bop_raft_cb_type_bop_raft_cb_type_state_machine_execution: bop_raft_cb_type = 19;
#[doc = " Just sent an append entries request.\n ctx: pointer to `req_msg` instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_sent_append_entries_req: bop_raft_cb_type = 20;
#[doc = " Just received an append entries request.\n ctx: pointer to `req_msg` instance.\n"]
pub const bop_raft_cb_type_bop_raft_cb_type_received_append_entries_req: bop_raft_cb_type = 21;
#[doc = " Just sent an append entries response.\n ctx: pointer to `resp_msg` instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_sent_append_entries_resp: bop_raft_cb_type = 22;
#[doc = " Just received an append entries response.\n ctx: pointer to `resp_msg`\n instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_received_append_entries_resp: bop_raft_cb_type = 23;
#[doc = " When cluster size is 2 and `auto_adjust_quorum_for_small_cluster_` is on,\n this\n server attempts to adjust the quorum size to 1.\n ctx: null"]
pub const bop_raft_cb_type_bop_raft_cb_type_auto_adjust_quorum: bop_raft_cb_type = 24;
#[doc = " Adding a server failed due to RPC errors and timeout expiry.\n ctx: null"]
pub const bop_raft_cb_type_bop_raft_cb_type_server_join_failed: bop_raft_cb_type = 25;
#[doc = " Snapshot creation begins.\n ctx: pointer to `uint64_t` (committed_idx)."]
pub const bop_raft_cb_type_bop_raft_cb_type_snapshot_creation_begin: bop_raft_cb_type = 26;
#[doc = " Got a resgination request either automatically or manually.\n ctx: null."]
pub const bop_raft_cb_type_bop_raft_cb_type_resignation_from_leader: bop_raft_cb_type = 27;
#[doc = " When a peer RPC errors count exceeds raft_server::limits.warning_limit_, or\n a\n peer doesn't respond for a long time (raft_params::leadership_expiry_),\n the peer is\n considered lost.\n ctx: null."]
pub const bop_raft_cb_type_bop_raft_cb_type_follower_lost: bop_raft_cb_type = 28;
#[doc = " When the server receives a misbehaving message from a peer,\n the callback has\n the ability to either ignore the message\n or respond normally by adjusting ReqResp.resp\n as indicated by ctx.\n\n Furthermore, the callback can opt to terminate\n if\n the situation is deemed critical.\n\n ctx: pointer to `ReqResp` instance."]
pub const bop_raft_cb_type_bop_raft_cb_type_received_misbehaving_message: bop_raft_cb_type = 29;
pub type bop_raft_cb_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_param {
    pub my_id: i32,
    pub leader_id: i32,
    pub peer_id: i32,
    pub ctx: *mut ::std::os::raw::c_void,
}
impl Default for bop_raft_cb_param {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_req_msg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_resp_msg {
    _unused: [u8; 0],
}
pub const bop_raft_cb_return_code_bop_raft_cb_return_code_ok: bop_raft_cb_return_code = 0;
pub const bop_raft_cb_return_code_bop_raft_cb_return_code_return_null: bop_raft_cb_return_code = -1;
pub type bop_raft_cb_return_code = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bop_raft_cb_out_of_log_range_warning_args {
    pub start_idx_of_leader: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_connection_args {
    #[doc = " ID of session."]
    pub session_id: u64,
    #[doc = " Endpoint address."]
    pub address: *const ::std::os::raw::c_char,
    pub address_len: usize,
    #[doc = " Endpoint port."]
    pub port: u32,
    #[doc = " Endpoint server ID if given."]
    pub srv_id: i32,
    #[doc = " `true` if the endpoint server is leader."]
    pub is_leader: bool,
}
impl Default for bop_raft_cb_connection_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const bop_raft_msg_type_bop_raft_msg_type_request_vote_request: bop_raft_msg_type = 1;
pub const bop_raft_msg_type_bop_raft_msg_type_request_vote_response: bop_raft_msg_type = 2;
pub const bop_raft_msg_type_bop_raft_msg_type_append_entries_request: bop_raft_msg_type = 3;
pub const bop_raft_msg_type_bop_raft_msg_type_append_entries_response: bop_raft_msg_type = 4;
pub const bop_raft_msg_type_bop_raft_msg_type_client_request: bop_raft_msg_type = 5;
pub const bop_raft_msg_type_bop_raft_msg_type_add_server_request: bop_raft_msg_type = 6;
pub const bop_raft_msg_type_bop_raft_msg_type_add_server_response: bop_raft_msg_type = 7;
pub const bop_raft_msg_type_bop_raft_msg_type_remove_server_request: bop_raft_msg_type = 8;
pub const bop_raft_msg_type_bop_raft_msg_type_remove_server_response: bop_raft_msg_type = 9;
pub const bop_raft_msg_type_bop_raft_msg_type_sync_log_request: bop_raft_msg_type = 10;
pub const bop_raft_msg_type_bop_raft_msg_type_sync_log_response: bop_raft_msg_type = 11;
pub const bop_raft_msg_type_bop_raft_msg_type_join_cluster_request: bop_raft_msg_type = 12;
pub const bop_raft_msg_type_bop_raft_msg_type_join_cluster_response: bop_raft_msg_type = 13;
pub const bop_raft_msg_type_bop_raft_msg_type_leave_cluster_request: bop_raft_msg_type = 14;
pub const bop_raft_msg_type_bop_raft_msg_type_leave_cluster_response: bop_raft_msg_type = 15;
pub const bop_raft_msg_type_bop_raft_msg_type_install_snapshot_request: bop_raft_msg_type = 16;
pub const bop_raft_msg_type_bop_raft_msg_type_install_snapshot_response: bop_raft_msg_type = 17;
pub const bop_raft_msg_type_bop_raft_msg_type_ping_request: bop_raft_msg_type = 18;
pub const bop_raft_msg_type_bop_raft_msg_type_ping_response: bop_raft_msg_type = 19;
pub const bop_raft_msg_type_bop_raft_msg_type_pre_vote_request: bop_raft_msg_type = 20;
pub const bop_raft_msg_type_bop_raft_msg_type_pre_vote_response: bop_raft_msg_type = 21;
pub const bop_raft_msg_type_bop_raft_msg_type_other_request: bop_raft_msg_type = 22;
pub const bop_raft_msg_type_bop_raft_msg_type_other_response: bop_raft_msg_type = 23;
pub const bop_raft_msg_type_bop_raft_msg_type_priority_change_request: bop_raft_msg_type = 24;
pub const bop_raft_msg_type_bop_raft_msg_type_priority_change_response: bop_raft_msg_type = 25;
pub const bop_raft_msg_type_bop_raft_msg_type_reconnect_request: bop_raft_msg_type = 26;
pub const bop_raft_msg_type_bop_raft_msg_type_reconnect_response: bop_raft_msg_type = 27;
pub const bop_raft_msg_type_bop_raft_msg_type_custom_notification_request: bop_raft_msg_type = 28;
pub const bop_raft_msg_type_bop_raft_msg_type_custom_notification_response: bop_raft_msg_type = 29;
pub type bop_raft_msg_type = i32;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_OK: bop_raft_cmd_result_code = 0;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_CANCELLED: bop_raft_cmd_result_code = -1;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_TIMEOUT: bop_raft_cmd_result_code = -2;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_NOT_LEADER: bop_raft_cmd_result_code = -3;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_BAD_REQUEST: bop_raft_cmd_result_code = -4;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_ALREADY_EXISTS:
    bop_raft_cmd_result_code = -5;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_CONFIG_CHANGING: bop_raft_cmd_result_code =
    -6;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_IS_JOINING: bop_raft_cmd_result_code =
    -7;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_NOT_FOUND: bop_raft_cmd_result_code =
    -8;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_CANNOT_REMOVE_LEADER:
    bop_raft_cmd_result_code = -9;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_SERVER_IS_LEAVING: bop_raft_cmd_result_code =
    -10;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_TERM_MISMATCH: bop_raft_cmd_result_code =
    -11;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_RESULT_NOT_EXIST_YET:
    bop_raft_cmd_result_code = -10000;
pub const bop_raft_cmd_result_code_BOP_RAFT_CMD_RESULT_FAILED: bop_raft_cmd_result_code = -32768;
pub type bop_raft_cmd_result_code = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_req_resp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_req_msg {
    pub term: u64,
    pub type_: bop_raft_msg_type,
    pub src: i32,
    pub dst: i32,
    pub last_log_term: u64,
    pub last_log_idx: u64,
    pub commit_idx: u64,
}
impl Default for bop_raft_cb_req_msg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_resp_peer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_raft_cb_resp_msg {
    pub term: u64,
    pub type_: bop_raft_msg_type,
    pub src: i32,
    pub dst: i32,
    pub next_idx: u64,
    pub next_batch_size_hint_in_bytes: i64,
    pub accepted: bool,
    pub ctx: *mut bop_raft_buffer,
    pub peer: *mut bop_raft_cb_resp_peer,
    pub result_code: bop_raft_cmd_result_code,
}
impl Default for bop_raft_cb_resp_msg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_req_msg(
        req_resp: *mut bop_raft_cb_req_resp,
        req_msg: *mut bop_raft_cb_req_msg,
    );
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_req_msg_entries_size(req_resp: *const bop_raft_cb_req_resp) -> usize;
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_req_msg_get_entry(
        req_resp: *const bop_raft_cb_req_resp,
        idx: usize,
    ) -> *mut bop_raft_log_entry;
}
unsafe extern "C" {
    pub fn bop_raft_cb_get_resp_msg(
        req_resp: *mut bop_raft_cb_req_resp,
        resp_msg: *mut bop_raft_cb_resp_msg,
    );
}
pub type bop_raft_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        type_: bop_raft_cb_type,
        param: *mut bop_raft_cb_param,
    ) -> bop_raft_cb_return_code,
>;
pub type bop_raft_inc_term_func = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, current_term: u64) -> u64,
>;
unsafe extern "C" {
    pub fn bop_raft_server_launch(
        user_data: *mut ::std::os::raw::c_void,
        fsm: *mut bop_raft_fsm_ptr,
        state_mgr: *mut bop_raft_state_mgr_ptr,
        logger: *mut bop_raft_logger_ptr,
        port_number: i32,
        asio_service: *const bop_raft_asio_service_ptr,
        params_given: *mut bop_raft_params,
        skip_initial_election_timeout: bool,
        start_server_in_constructor: bool,
        test_mode_flag: bool,
        cb_func: bop_raft_cb_func,
    ) -> *mut bop_raft_server_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_server_stop(server: *mut bop_raft_server_ptr, time_limit_sec: usize) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_server_get(s: *mut bop_raft_server_ptr) -> *mut bop_raft_server;
}
unsafe extern "C" {
    #[doc = " Check if this server is ready to serve operation.\n\n @return `true` if it is ready."]
    pub fn bop_raft_server_is_initialized(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is catching up the current leader\n to join the cluster.\n\n @return\n `true` if it is in catch-up mode."]
    pub fn bop_raft_server_is_catching_up(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is receiving snapshot from leader.\n\n @return `true` if it is\n receiving snapshot."]
    pub fn bop_raft_server_is_receiving_snapshot(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Add a new server to the current cluster. Only leader will accept this operation.\n Note that this is an asynchronous task so that needs more network communications.\n Returning this function does not guarantee adding the server.\n\n @param srv Configuration of server to add.\n @return `get_accepted()` will be true on success."]
    pub fn bop_raft_server_add_srv(
        rs: *mut bop_raft_server,
        srv: *const bop_raft_srv_config_ptr,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Remove a server from the current cluster. Only leader will accept this operation.\n The same as `add_srv`, this is also an asynchronous task.\n\n @param srv_id ID of server to remove.\n @return `get_accepted()` will be true on success."]
    pub fn bop_raft_server_remove_srv(
        rs: *mut bop_raft_server,
        srv_id: i32,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Flip learner flag of given server. Learner will be excluded from the quorum. Only\n leader will accept this operation. This is also an asynchronous task.\n\n @param srv_id ID of the server to set as a learner.\n @param to If `true`, set the server as a learner, otherwise, clear learner flag.\n @return `ret->get_result_code()` will be OK on success."]
    pub fn bop_raft_server_flip_learner_flag(
        rs: *mut bop_raft_server,
        srv_id: i32,
        to: bool,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Append and replicate the given logs. Only leader will accept this operation.\n\n @param entries Set of logs to replicate.\n @return\n     In blocking mode, it will be blocked during replication, and\n     return `cmd_result` instance which contains the commit results from\n     the state machine.\n\n     In async mode, this function will return immediately, and the commit\n     results will be set to returned `cmd_result` instance later."]
    pub fn bop_raft_server_append_entries(
        rs: *mut bop_raft_server,
        entries: *mut bop_raft_append_entries_ptr,
        handler: *mut bop_raft_async_buffer_ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Update the priority of given server.\n\n @param rs local bop_raft_server instance\n @param srv_id ID of server to update priority.\n @param new_priority Priority value, greater than or equal to 0.\n        If priority is set to 0, this server will never be a leader.\n @param broadcast_when_leader_exists If we're not a leader and a\n        leader exists, broadcast priority change to other peers.\n        If false, set_priority does nothing. Please note that\n        setting this option to true may possibly cause cluster config\n        to diverge.\n @return SET If we're a leader and we have committed priority change.\n @return BROADCAST\n     If either there's no\n         live leader now, or we're a leader, and we want to set our priority to 0,\n\n         or we're not a leader and broadcast_when_leader_exists = true.\n         We have sent messages to other peers about priority change but haven't\n         committed this change.\n @return IGNORED If we're not a leader and broadcast_when_leader_exists = false.\n"]
    pub fn bop_raft_server_set_priority(
        rs: *mut bop_raft_server,
        srv_id: i32,
        new_priority: i32,
        broadcast_when_leader_exists: bool,
    ) -> bop_raft_server_priority_set_result;
}
unsafe extern "C" {
    #[doc = " Broadcast the priority change of given server to all peers. This function should be used\n only when there is no live leader and leader election is blocked by priorities of live\n followers. In that case, we are not able to change priority by using normal `set_priority`\n operation.\n\n @param rs local bop_raft_server instance\n @param srv_id ID of server to update\n priority.\n @param new_priority New priority."]
    pub fn bop_raft_server_broadcast_priority_change(
        rs: *mut bop_raft_server,
        srv_id: i32,
        new_priority: i32,
    );
}
unsafe extern "C" {
    #[doc = " Yield current leadership and becomes a follower. Only a leader will accept this\n\n If given `immediate_yield` flag is `true`, it will become a follower immediately.\n The subsequent leader election will be totally random so that there is always a\n chance that this server becomes the next leader again.\n\n Otherwise, this server will pause write operations first, wait until the successor\n (except for this server) finishes the catch-up of the latest log, and then resign.\n In such a case, the next leader will be much more predictable.\n\n Users can designate the successor. If not given, this API will automatically choose\n the highest priority server as a successor.\n\n @param rs local bop_raft_server instance\n @param immediate_yield If `true`, yield immediately.\n @param successor_id The server ID of the successor.\n                     If `-1`, the successor will be chosen automatically."]
    pub fn bop_raft_server_yield_leadership(
        rs: *mut bop_raft_server,
        immediate_yield: bool,
        successor_id: i32,
    );
}
unsafe extern "C" {
    #[doc = " Send a request to the current leader to yield its leadership,\n and become the next leader.\n\n *\n @return `true` on success. But it does not guarantee to become\n         the next leader due to various failures."]
    pub fn bop_raft_server_request_leadership(rs: *mut bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Start the election timer on this server, if this server is a follower. It will\n allow the election timer permanently, if it was disabled by state manager."]
    pub fn bop_raft_server_restart_election_timer(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Set custom context to Raft cluster config. It will create a new configuration log and\n replicate it.\n\n @param ctx Custom context."]
    pub fn bop_raft_server_set_user_ctx(
        rs: *mut bop_raft_server,
        data: *const ::std::os::raw::c_char,
        size: usize,
    );
}
unsafe extern "C" {
    #[doc = " Get custom context from the current cluster config.\n\n @return Custom context."]
    pub fn bop_raft_server_get_user_ctx(rs: *mut bop_raft_server) -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    #[doc = " Get timeout for snapshot_sync_ctx\n\n @return snapshot_sync_ctx_timeout."]
    pub fn bop_raft_server_get_snapshot_sync_ctx_timeout(rs: *const bop_raft_server) -> i32;
}
unsafe extern "C" {
    #[doc = " Get ID of this server.\n\n @return Server ID."]
    pub fn bop_raft_server_get_id(rs: *const bop_raft_server) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the current term of this server.\n\n @return Term."]
    pub fn bop_raft_server_get_term(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the term of given log index number.\n\n @param log_idx Log index number\n @return Term of given log."]
    pub fn bop_raft_server_get_log_term(rs: *const bop_raft_server, log_idx: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the term of the last log.\n\n @return Term of the last log."]
    pub fn bop_raft_server_get_last_log_term(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the last log index number.\n\n @return Last log index number."]
    pub fn bop_raft_server_get_last_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the last committed log index number of state machine.\n\n @return Last committed log index number of state machine."]
    pub fn bop_raft_server_get_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the target log index number we are required to commit.\n\n @return Target committed log index number."]
    pub fn bop_raft_server_get_target_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the leader's last committed log index number.\n\n @return The leader's last committed log index number."]
    pub fn bop_raft_server_get_leader_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the log index of the first config when this server became a leader.\n This API can be used for checking if the state machine is fully caught up\n with the latest log after a leader election, so that the new leader can\n guarantee strong consistency.\n\n It will return 0 if this server is not a leader.\n\n @return The log index of the first config when this server became a leader."]
    pub fn bop_raft_server_get_log_idx_at_becoming_leader(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Calculate the log index to be committed from current peers' matched indexes.\n\n @return Expected committed log index."]
    pub fn bop_raft_server_get_expected_committed_log_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the current Raft cluster config.\n\n @param rs raft server instance\n @param cluster_config Wrapper for holding nuraft::ptr<nuraft::cluster_config>"]
    pub fn bop_raft_server_get_config(
        rs: *const bop_raft_server,
        cluster_config: *mut bop_raft_cluster_config_ptr,
    );
}
unsafe extern "C" {
    #[doc = " Get data center ID of the given server.\n\n @param srv_id Server ID.\n @return -1 if given server ID does not exist.\n          0 if data center ID was not assigned."]
    pub fn bop_raft_server_get_dc_id(rs: *const bop_raft_server, srv_id: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " Get auxiliary context stored in the server config.\n\n @param srv_id Server ID.\n @return\n Auxiliary context."]
    pub fn bop_raft_server_get_aux(rs: *const bop_raft_server, srv_id: i32)
    -> *mut bop_raft_buffer;
}
unsafe extern "C" {
    #[doc = " Get the ID of current leader.\n\n @return Leader ID\n         -1 if there is no live leader."]
    pub fn bop_raft_server_get_leader(rs: *const bop_raft_server) -> i32;
}
unsafe extern "C" {
    #[doc = " Check if this server is leader.\n\n @return `true` if it is leader."]
    pub fn bop_raft_server_is_leader(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if there is live leader in the current cluster.\n\n @return `true` if live leader exists."]
    pub fn bop_raft_server_is_leader_alive(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the configuration of given server.\n\n @param srv_id Server ID.\n @return Server configuration."]
    pub fn bop_raft_server_get_srv_config(
        rs: *const bop_raft_server,
        svr_config: *mut bop_raft_srv_config_ptr,
        srv_id: i32,
    );
}
unsafe extern "C" {
    #[doc = " Get the configuration of all servers.\n\n @param[out] configs_out Set of server configurations."]
    pub fn bop_raft_server_get_srv_config_all(
        rs: *const bop_raft_server,
        configs_out: *mut bop_raft_srv_config_vec,
    );
}
unsafe extern "C" {
    #[doc = " Update the server configuration, only leader will accept this operation.\n This function will update the current cluster config and replicate it to all peers.\n\n We don't allow changing multiple server configurations at once, due to safety reason.\n\n Change on endpoint will not be accepted (should be removed and then re-added).\n If the server is in new joiner state, it will be rejected.\n If the server ID does not exist, it will also be rejected.\n\n @param new_config Server configuration to update.\n @return `true` on success, `false` if rejected."]
    pub fn bop_raft_server_update_srv_config(
        rs: *mut bop_raft_server,
        new_config: *mut bop_raft_srv_config_ptr,
    );
}
unsafe extern "C" {
    #[doc = " Get the peer info of the given ID. Only leader will return peer info.\n\n @param srv_id Server ID\n @return Peer info"]
    pub fn bop_raft_server_get_peer_info(
        rs: *mut bop_raft_server,
        srv_id: i32,
        peer: *mut bop_raft_server_peer_info,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the info of all peers. Only leader will return peer info.\n\n @return Vector of peer\n info."]
    pub fn bop_raft_server_get_peer_info_all(
        rs: *const bop_raft_server,
        peers_out: *mut bop_raft_server_peer_info_vec,
    );
}
unsafe extern "C" {
    #[doc = " Shut down server instance."]
    pub fn bop_raft_server_shutdown(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = "  Start internal background threads, initialize election"]
    pub fn bop_raft_server_start_server(
        rs: *mut bop_raft_server,
        skip_initial_election_timeout: bool,
    );
}
unsafe extern "C" {
    #[doc = " Stop background commit thread."]
    pub fn bop_raft_server_stop_server(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Send reconnect request to leader. Leader will re-establish the connection to this server\n in a few seconds. Only follower will accept this operation."]
    pub fn bop_raft_server_send_reconnect_request(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Update Raft parameters.\n\n @param new_params Parameters to set."]
    pub fn bop_raft_server_update_params(rs: *mut bop_raft_server, params: *mut bop_raft_params);
}
unsafe extern "C" {
    #[doc = " Get the current Raft parameters. Returned instance is the clone of the original one,\n so that user can modify its contents.\n\n @return Clone of Raft parameters."]
    pub fn bop_raft_server_get_current_params(
        rs: *const bop_raft_server,
        params: *mut bop_raft_params,
    );
}
unsafe extern "C" {
    #[doc = " Get the counter number of given stat name.\n\n @param name Stat name to retrieve.\n\n @return Counter value."]
    pub fn bop_raft_server_get_stat_counter(
        rs: *mut bop_raft_server,
        counter: *mut bop_raft_counter,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the gauge number of given stat name.\n\n @param name Stat name to retrieve.\n @return Gauge value."]
    pub fn bop_raft_server_get_stat_gauge(
        rs: *mut bop_raft_server,
        gauge: *mut bop_raft_gauge,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the histogram of given stat name.\n\n @param name Stat name to retrieve.\n @param[out] histogram_out Histogram as a map. Key is the upper bound of a bucket, and\n             value is the counter of that bucket.\n @return `true` on success.\n         `false` if stat does not exist, or is not histogram type."]
    pub fn bop_raft_server_get_stat_histogram(
        rs: *mut bop_raft_server,
        histogram: *mut bop_raft_histogram,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Reset given stat to zero.\n\n @param name Stat name to reset."]
    pub fn bop_raft_server_reset_counter(rs: *mut bop_raft_server, counter: *mut bop_raft_counter);
}
unsafe extern "C" {
    #[doc = " Reset given stat to zero.\n\n @param name Stat name to reset."]
    pub fn bop_raft_server_reset_gauge(rs: *mut bop_raft_server, gauge: *mut bop_raft_gauge);
}
unsafe extern "C" {
    #[doc = " Reset given stat to zero.\n\n @param name Stat name to reset."]
    pub fn bop_raft_server_reset_histogram(
        rs: *mut bop_raft_server,
        histogram: *mut bop_raft_histogram,
    );
}
unsafe extern "C" {
    #[doc = " Reset all existing stats to zero."]
    pub fn bop_raft_server_reset_all_stats(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Set a custom callback function for increasing term."]
    pub fn bop_raft_server_set_inc_term_func(
        rs: *mut bop_raft_server,
        user_data: *mut ::std::os::raw::c_void,
        func: bop_raft_inc_term_func,
    );
}
unsafe extern "C" {
    #[doc = " Pause the background execution of the state machine. If an operation execution is\n currently happening, the state machine may not be paused immediately.\n\n @param timeout_ms If non-zero, this function will be blocked until\n                   either it completely pauses the state machine execution\n                   or reaches the given time limit in milliseconds.\n                   Otherwise, this function will return immediately, and there\n                   is a possibility that the state machine execution\n                   is still happening."]
    pub fn bop_raft_server_pause_state_machine_execution(
        rs: *mut bop_raft_server,
        timeout_ms: usize,
    );
}
unsafe extern "C" {
    #[doc = " Resume the background execution of state machine."]
    pub fn bop_raft_server_resume_state_machine_execution(rs: *mut bop_raft_server);
}
unsafe extern "C" {
    #[doc = " Check if the state machine execution is paused.\n\n @return `true` if paused."]
    pub fn bop_raft_server_is_state_machine_execution_paused(rs: *const bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Block the current thread and wake it up when the state machine execution is paused.\n\n @param timeout_ms If non-zero, wake up after the given amount of time\n                   even though the state machine is not paused yet.\n @return `true` if the state machine is paused."]
    pub fn bop_raft_server_wait_for_state_machine_pause(
        rs: *mut bop_raft_server,
        timeout_ms: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " (Experimental)\n This API is used when `raft_params::parallel_log_appending_` is set.\n\n Everytime an asynchronous log appending job is done, users should call this API to notify\n Raft server to handle the log. Note that calling this API once for multiple logs is acceptable\n and recommended.\n\n @param ok `true` if appending succeeded."]
    pub fn bop_raft_server_notify_log_append_completion(rs: *mut bop_raft_server, ok: bool);
}
unsafe extern "C" {
    #[doc = " Manually create a snapshot based on the latest committed log index of the state machine.\n\n Note that snapshot creation will fail immediately if the previous snapshot task is still\n running.\n\n @param serialize_commit\n        If `true`, the background commit will be blocked until `create_snapshot`\n        returns. However, it will not block the commit for the entire duration\n        of the snapshot creation process, as long as your state machine creates\n        the snapshot asynchronously. The purpose of this flag is to ensure that\n        the log index used for the snapshot creation is the most recent one.\n\n @return Log index number of the created snapshot or`0` if failed."]
    pub fn bop_raft_server_create_snapshot(rs: *mut bop_raft_server, serialize_commit: bool)
    -> u64;
}
unsafe extern "C" {
    #[doc = " Manually and asynchronously create a snapshot on the next earliest available commited\n log index.\n\n Unlike `create_snapshot`, if the previous snapshot task is running, it will wait\n until the previous task is done. Once the snapshot creation is finished, it will be\n notified via the returned `cmd_result` with the log index number of the snapshot.\n\n @param `cmd_result` instance.\n        `nullptr` if there is already a scheduled snapshot creation."]
    pub fn bop_raft_server_schedule_snapshot_creation(
        rs: *mut bop_raft_server,
        result_handler: *mut bop_raft_async_u64_ptr,
    );
}
unsafe extern "C" {
    #[doc = " Get the log index number of the last snapshot.\n\n @return Log index number of the last snapshot. `0` if snapshot does not exist."]
    pub fn bop_raft_server_get_last_snapshot_idx(rs: *const bop_raft_server) -> u64;
}
unsafe extern "C" {
    #[doc = " Set the self mark down flag of this server.\n\n @return The self mark down flag before the update."]
    pub fn bop_raft_server_set_self_mark_down(rs: *mut bop_raft_server, to: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is the part of the quorum of full consensus.\n What it means is that, as long as the return value is `true`, this server\n has the latest committed log at the moment that `true` was returned.\n\n @return `true` if this server is the part of the full consensus."]
    pub fn bop_raft_server_is_part_of_full_consensus(rs: *mut bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if this server is excluded from the quorum by the leader,\n when it runs in full consensus mode.\n\n @return `true` if this server is excluded by the current leader and\n         not the part of the full consensus."]
    pub fn bop_raft_server_is_excluded_by_leader(rs: *mut bop_raft_server) -> bool;
}
unsafe extern "C" {
    #[doc = " Wait for the state machine to commit the log at the given index.\n This function will return immediately, and the commit results will be\n set to the returned `cmd_result` instance later.\n\n @return `cmd_result` instance. It will contain `true` if the commit\n         has been invoked, and `false` if not."]
    pub fn bop_raft_server_wait_for_state_machine_commit(
        rs: *mut bop_raft_server,
        result: *mut bop_raft_async_bool_ptr,
        target_idx: u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_raft_mdbx_state_mgr_open(
        my_srv_config: *mut bop_raft_srv_config_ptr,
        dir: *const ::std::os::raw::c_char,
        dir_size: usize,
        logger: *mut bop_raft_logger_ptr,
        size_lower: usize,
        size_now: usize,
        size_upper: usize,
        growth_step: usize,
        shrink_threshold: usize,
        pagesize: usize,
        flags: u32,
        mode: u16,
        log_store: *mut bop_raft_log_store_ptr,
    ) -> *mut bop_raft_state_mgr_ptr;
}
unsafe extern "C" {
    pub fn bop_raft_mdbx_log_store_open(
        path: *const ::std::os::raw::c_char,
        path_size: usize,
        logger: *mut bop_raft_logger_ptr,
        size_lower: usize,
        size_now: usize,
        size_upper: usize,
        growth_step: usize,
        shrink_threshold: usize,
        pagesize: usize,
        flags: u32,
        mode: u16,
        compact_batch_size: usize,
    ) -> *mut bop_raft_log_store_ptr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_producer_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_consumer_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_blocking {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_blocking_producer_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bop_mpmc_blocking_consumer_token {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bop_mpmc_create() -> *mut bop_mpmc;
}
unsafe extern "C" {
    pub fn bop_mpmc_destroy(queue: *mut bop_mpmc);
}
unsafe extern "C" {
    pub fn bop_mpmc_create_producer_token(queue: *mut bop_mpmc) -> *mut bop_mpmc_producer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_destroy_producer_token(token: *mut bop_mpmc_producer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_create_consumer_token(queue: *mut bop_mpmc) -> *mut bop_mpmc_consumer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_destroy_consumer_token(token: *mut bop_mpmc_consumer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_size_approx(queue: *mut bop_mpmc) -> usize;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue(queue: *mut bop_mpmc, item: u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue_token(token: *mut bop_mpmc_producer_token, item: u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue_bulk(token: *mut bop_mpmc, items: *mut u64, size: usize) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_enqueue_bulk_token(
        queue: *mut bop_mpmc_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_try_enqueue_bulk(queue: *mut bop_mpmc, items: *mut u64, size: usize) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_try_enqueue_bulk_token(
        queue: *mut bop_mpmc_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue(queue: *mut bop_mpmc, item: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue_token(queue: *mut bop_mpmc_consumer_token, item: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue_bulk(queue: *mut bop_mpmc, items: *mut u64, max_size: usize) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_dequeue_bulk_token(
        queue: *mut bop_mpmc_consumer_token,
        items: *mut u64,
        max_size: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_create() -> *mut bop_mpmc_blocking;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_destroy(queue: *mut bop_mpmc_blocking);
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_create_producer_token(
        queue: *mut bop_mpmc_blocking,
    ) -> *mut bop_mpmc_blocking_producer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_destroy_producer_token(token: *mut bop_mpmc_blocking_producer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_create_consumer_token(
        queue: *mut bop_mpmc_blocking,
    ) -> *mut bop_mpmc_blocking_consumer_token;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_destroy_consumer_token(token: *mut bop_mpmc_blocking_consumer_token);
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_size_approx(queue: *mut bop_mpmc_blocking) -> usize;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue(queue: *mut bop_mpmc_blocking, item: u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue_token(
        token: *mut bop_mpmc_blocking_producer_token,
        item: u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue_bulk(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_enqueue_bulk_token(
        token: *mut bop_mpmc_blocking_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_try_enqueue_bulk(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_try_enqueue_bulk_token(
        token: *mut bop_mpmc_blocking_producer_token,
        items: *mut u64,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue(queue: *mut bop_mpmc_blocking, item: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        item: *mut u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_wait(
        queue: *mut bop_mpmc_blocking,
        item: *mut u64,
        timeout_micros: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_wait_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        item: *mut u64,
        timeout_micros: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        max_size: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        items: *mut u64,
        max_size: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk_wait(
        queue: *mut bop_mpmc_blocking,
        items: *mut u64,
        max_size: usize,
        timeout_micros: i64,
    ) -> i64;
}
unsafe extern "C" {
    pub fn bop_mpmc_blocking_dequeue_bulk_wait_token(
        token: *mut bop_mpmc_blocking_consumer_token,
        items: *mut u64,
        max_size: usize,
        timeout_micros: i64,
    ) -> i64;
}
#[doc = " The app type."]
pub type uws_app_t = *mut ::std::os::raw::c_void;
#[doc = " The response type."]
pub type uws_res_t = *mut ::std::os::raw::c_void;
#[doc = " The request type."]
pub type uws_req_t = *mut ::std::os::raw::c_void;
#[doc = " The web socket type."]
pub type uws_web_socket_t = *mut ::std::os::raw::c_void;
#[doc = " The loop type."]
pub type uws_loop_t = *mut ::std::os::raw::c_void;
#[doc = " The client app type."]
pub type uws_client_app_t = *mut ::std::os::raw::c_void;
#[doc = " The client connection type."]
pub type uws_client_conn_t = *mut ::std::os::raw::c_void;
#[doc = " The client request type."]
pub type uws_client_req_t = *mut ::std::os::raw::c_void;
#[doc = " The client response type."]
pub type uws_client_res_t = *mut ::std::os::raw::c_void;
#[doc = " The TCP client app type."]
pub type uws_tcp_client_app_t = *mut ::std::os::raw::c_void;
#[doc = " The TCP server app type."]
pub type uws_tcp_server_app_t = *mut ::std::os::raw::c_void;
#[doc = " The TCP connection type."]
pub type uws_tcp_conn_t = *mut ::std::os::raw::c_void;
#[doc = " The SSL options type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_ssl_options_s {
    pub key_file_name: *const ::std::os::raw::c_char,
    pub cert_file_name: *const ::std::os::raw::c_char,
    pub passphrase: *const ::std::os::raw::c_char,
    pub dh_params_file_name: *const ::std::os::raw::c_char,
    pub ca_file_name: *const ::std::os::raw::c_char,
    pub ssl_prefer_low_memory: ::std::os::raw::c_int,
}
impl Default for uws_ssl_options_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The SSL options type."]
pub type uws_ssl_options_t = uws_ssl_options_s;
unsafe extern "C" {
    #[doc = " Creates an app."]
    pub fn uws_create_app() -> uws_app_t;
}
unsafe extern "C" {
    #[doc = " Creates an SSL app."]
    pub fn uws_create_ssl_app(options: uws_ssl_options_t) -> uws_app_t;
}
unsafe extern "C" {
    #[doc = " Destroys an app."]
    pub fn uws_app_destroy(app: uws_app_t);
}
unsafe extern "C" {
    #[doc = " Checks if an app is SSL."]
    pub fn uws_app_is_ssl(app: uws_app_t) -> bool;
}
pub type uws_http_handler_t = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, res: uws_res_t, req: uws_req_t),
>;
unsafe extern "C" {
    #[doc = " Adds a GET route to the app."]
    pub fn uws_app_get(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a POST route to the app."]
    pub fn uws_app_post(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a PUT route to the app."]
    pub fn uws_app_put(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a DELETE route to the app."]
    pub fn uws_app_del(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a PATCH route to the app."]
    pub fn uws_app_patch(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a OPTIONS route to the app."]
    pub fn uws_app_options(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Adds a ANY route to the app."]
    pub fn uws_app_any(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        handler: uws_http_handler_t,
    );
}
pub const uws_opcode_t_UWS_OPCODE_CONTINUE: uws_opcode_t = 0;
pub const uws_opcode_t_UWS_OPCODE_TEXT: uws_opcode_t = 1;
pub const uws_opcode_t_UWS_OPCODE_BINARY: uws_opcode_t = 2;
pub const uws_opcode_t_UWS_OPCODE_CLOSE: uws_opcode_t = 8;
pub const uws_opcode_t_UWS_OPCODE_PING: uws_opcode_t = 9;
pub const uws_opcode_t_UWS_OPCODE_PONG: uws_opcode_t = 10;
#[doc = " The WebSocket opcode."]
pub type uws_opcode_t = ::std::os::raw::c_int;
#[doc = " The WebSocket behavior."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_ws_behavior_s {
    pub compression: u16,
    pub idle_timeout: u16,
    pub max_payload_length: u32,
    pub max_backpressure: u32,
    pub max_lifetime: u16,
    pub close_on_backpressure_limit: bool,
    pub reset_idle_timeout_on_send: bool,
    pub send_pings_automatically: bool,
    pub reserved: bool,
    pub reserved_2: u16,
    pub reserved_3: u32,
    pub upgrade: ::std::option::Option<
        unsafe extern "C" fn(
            res: uws_res_t,
            req: uws_req_t,
            context: *mut ::std::os::raw::c_void,
            per_pattern_user_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub create_user_data: ::std::option::Option<
        unsafe extern "C" fn(
            per_pattern_user_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(ws: uws_web_socket_t, user_data: *mut ::std::os::raw::c_void),
    >,
    pub message: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
            opcode: uws_opcode_t,
        ),
    >,
    pub dropped: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
            opcode: uws_opcode_t,
        ),
    >,
    pub drain: ::std::option::Option<
        unsafe extern "C" fn(ws: uws_web_socket_t, user_data: *mut ::std::os::raw::c_void),
    >,
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            code: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub subscription: ::std::option::Option<
        unsafe extern "C" fn(
            ws: uws_web_socket_t,
            user_data: *mut ::std::os::raw::c_void,
            topic: *const ::std::os::raw::c_char,
            subscriptions: ::std::os::raw::c_int,
            old_subscriptions: ::std::os::raw::c_int,
        ),
    >,
    pub destroy_user_data:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub per_pattern_user_data: *mut ::std::os::raw::c_void,
}
impl Default for uws_ws_behavior_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The WebSocket behavior."]
pub type uws_ws_behavior_t = uws_ws_behavior_s;
unsafe extern "C" {
    pub fn uws_app_ws(
        app: uws_app_t,
        pattern: *const ::std::os::raw::c_char,
        pattern_length: usize,
        behavior: uws_ws_behavior_t,
    );
}
unsafe extern "C" {
    pub fn uws_app_listen(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        host_length: usize,
        port: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                listen_socket: *mut ::std::os::raw::c_void,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn uws_app_listen_unix(
        app: uws_app_t,
        user_data: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
        path_length: usize,
        options: ::std::os::raw::c_int,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                listen_socket: *mut ::std::os::raw::c_void,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn uws_app_loop(app: uws_app_t) -> uws_loop_t;
}
unsafe extern "C" {
    pub fn uws_app_run(app: uws_app_t);
}
unsafe extern "C" {
    pub fn uws_loop_defer(
        loop_: uws_loop_t,
        user_data: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(loop_: uws_loop_t, user_data: *mut ::std::os::raw::c_void),
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_socket_context_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Upgrades the response to a WebSocket.\n\n @param res The response.\n @param user_data The user data.\n @param sec_web_socket_key The sec web socket key.\n @param sec_web_socket_key_length The sec web socket key length.\n @param sec_web_socket_protocol The sec web socket protocol.\n @param sec_web_socket_protocol_length The sec web socket protocol length.\n @param sec_web_socket_extensions The sec web socket extensions.\n @param sec_web_socket_extensions_length The sec web socket extensions length.\n @param web_socket_context The web socket context."]
    pub fn uws_res_upgrade(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        sec_web_socket_key: *const ::std::os::raw::c_char,
        sec_web_socket_key_length: usize,
        sec_web_socket_protocol: *const ::std::os::raw::c_char,
        sec_web_socket_protocol_length: usize,
        sec_web_socket_extensions: *const ::std::os::raw::c_char,
        sec_web_socket_extensions_length: usize,
        web_socket_context: *mut us_socket_context_t,
    );
}
unsafe extern "C" {
    #[doc = " Gets the loop of the response.\n\n @param res The response.\n @return The loop."]
    pub fn uws_res_loop(res: uws_res_t) -> uws_loop_t;
}
unsafe extern "C" {
    #[doc = " Defers a handler for the response.\n\n @param res The response.\n @param user_data The user data.\n @param callback The callback."]
    pub fn uws_res_defer(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                loop_: uws_loop_t,
                res: uws_res_t,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    #[doc = " Closes the response.\n\n @param res The response."]
    pub fn uws_res_close(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Pauses the response.\n\n @param res The response."]
    pub fn uws_res_pause(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Resumes the response.\n\n @param res The response."]
    pub fn uws_res_resume(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Gets the native handle of the response.\n\n @param res The response.\n @return The native handle."]
    pub fn uws_res_native_handle(res: uws_res_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Gets the remote address of the response.\n\n @param res The response.\n @param length The length of the remote address.\n @return The remote address."]
    pub fn uws_res_remote_address(
        res: uws_res_t,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Writes a continue to the response.\n\n @param res The response."]
    pub fn uws_res_write_continue(res: uws_res_t);
}
unsafe extern "C" {
    #[doc = " Writes a status to the response.\n\n @param res The response.\n @param status The status.\n @param status_length The length of the status."]
    pub fn uws_res_write_status(
        res: uws_res_t,
        status: *const ::std::os::raw::c_char,
        status_length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Writes a header to the response.\n\n @param res The response.\n @param key The key.\n @param key_length The length of the key.\n @param value The value.\n @param value_length The length of the value."]
    pub fn uws_res_write_header(
        res: uws_res_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Writes a header to the response.\n\n @param res The response.\n @param key The key.\n @param key_length The length of the key.\n @param value The value."]
    pub fn uws_res_write_header_int(
        res: uws_res_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
        value: u64,
    );
}
unsafe extern "C" {
    #[doc = " Writes data to the response.\n\n @param res The response.\n @param data The data.\n @param length The length of the data."]
    pub fn uws_res_write(res: uws_res_t, data: *const ::std::os::raw::c_char, length: usize);
}
unsafe extern "C" {
    #[doc = " Ends the response without a body.\n\n @param res The response.\n @param reported_content_length The reported content length.\n @param reported_content_length_is_set The reported content length is set.\n @param close_connection The close connection."]
    pub fn uws_res_end_without_body(
        res: uws_res_t,
        reported_content_length: usize,
        reported_content_length_is_set: bool,
        close_connection: bool,
    );
}
unsafe extern "C" {
    #[doc = " Ends the response.\n\n @param res The response.\n @param data The data.\n @param length The length of the data.\n @param close_connection The close connection."]
    pub fn uws_res_end(
        res: uws_res_t,
        data: *const ::std::os::raw::c_char,
        length: usize,
        close_connection: bool,
    );
}
unsafe extern "C" {
    #[doc = " Tries to end the response.\n\n @param res The response.\n @param data The data.\n @param length The length of the data.\n @param total_size The total size.\n @param close_connection The close connection.\n @param has_responded The has responded."]
    pub fn uws_res_try_end(
        res: uws_res_t,
        data: *const ::std::os::raw::c_char,
        length: usize,
        total_size: usize,
        close_connection: bool,
        has_responded: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Writes the offset of the response.\n\n @param res The response.\n @return The offset."]
    pub fn uws_res_write_offset(res: uws_res_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Overwrites the offset of the response.\n\n @param res The response.\n @param offset The offset."]
    pub fn uws_res_override_write_offset(res: uws_res_t, offset: usize);
}
unsafe extern "C" {
    #[doc = " Checks if the response has responded.\n\n @param res The response.\n @return The has responded."]
    pub fn uws_res_has_responded(res: uws_res_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Corks the response.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_cork(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(res: uws_res_t, user_data: *mut ::std::os::raw::c_void),
        >,
    );
}
unsafe extern "C" {
    #[doc = " On writable.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_on_writable(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                res: uws_res_t,
                user_data: *mut ::std::os::raw::c_void,
                m: u64,
            ) -> bool,
        >,
    );
}
unsafe extern "C" {
    #[doc = " On aborted.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_on_aborted(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(res: uws_res_t, user_data: *mut ::std::os::raw::c_void),
        >,
    );
}
unsafe extern "C" {
    #[doc = " On data.\n\n @param res The response.\n @param user_data The user data.\n @param handler The handler."]
    pub fn uws_res_on_data(
        res: uws_res_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                res: uws_res_t,
                user_data: *mut ::std::os::raw::c_void,
                data: *const ::std::os::raw::c_char,
                data_length: usize,
                fin: bool,
            ),
        >,
    );
}
unsafe extern "C" {
    #[doc = " Gets the method of the request.\n\n @param req The request.\n @param length The length of the method.\n @return The method."]
    pub fn uws_req_get_method(req: uws_req_t, length: *mut usize) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the URL of the request.\n\n @param req The request.\n @param length The length of the URL.\n @return The URL."]
    pub fn uws_req_get_url(req: uws_req_t, length: *mut usize) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the query of the request.\n\n @param req The request.\n @param length The length of the query.\n @return The query."]
    pub fn uws_req_get_query(req: uws_req_t, length: *mut usize) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the header of the request.\n\n @param req The request.\n @param lower_case_name The lower case name of the header.\n @param length The length of the header.\n @return The header."]
    pub fn uws_req_get_header(
        req: uws_req_t,
        lower_case_name: *const ::std::os::raw::c_char,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the header count of the request.\n\n @param req The request.\n @return The header count."]
    pub fn uws_req_get_header_count(req: uws_req_t) -> usize;
}
#[doc = " A string view.\n\n @param data The data.\n @param length The length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_string_view_t {
    pub data: *const ::std::os::raw::c_char,
    pub length: usize,
}
impl Default for uws_string_view_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The HTTP header.\n\n @param key The key.\n @param value The value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uws_http_header_t {
    pub key: uws_string_view_t,
    pub value: uws_string_view_t,
}
impl Default for uws_http_header_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Gets the header at the index of the request.\n\n @param req The request.\n @param index The index.\n @param header The header."]
    pub fn uws_req_get_header_at(req: uws_req_t, index: usize, header: *mut uws_http_header_t);
}
unsafe extern "C" {
    #[doc = " Gets the headers of the request.\n\n @param req The request.\n @param headers The headers.\n @param max_headers The maximum headers."]
    pub fn uws_req_get_headers(
        req: uws_req_t,
        headers: *mut uws_http_header_t,
        max_headers: usize,
    ) -> usize;
}
pub const uws_ws_send_status_BACKPRESSURE: uws_ws_send_status = 0;
pub const uws_ws_send_status_SUCCESS: uws_ws_send_status = 1;
pub const uws_ws_send_status_DROPPED: uws_ws_send_status = 2;
#[doc = " The WebSocket send status."]
pub type uws_ws_send_status = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Gets the loop of the web socket.\n\n @param ws The web socket.\n @return The loop."]
    pub fn uws_ws_loop(ws: uws_web_socket_t) -> uws_loop_t;
}
unsafe extern "C" {
    #[doc = " Sends a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param opcode The opcode.\n @param compress The compress.\n @param fin The fin."]
    pub fn uws_ws_send(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        opcode: uws_opcode_t,
        compress: bool,
        fin: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Sends the first fragment of a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param opcode The opcode.\n @param compress The compress."]
    pub fn uws_ws_send_first_fragment(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        opcode: uws_opcode_t,
        compress: bool,
    ) -> uws_ws_send_status;
}
unsafe extern "C" {
    #[doc = " Sends a fragment of a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param compress The compress."]
    pub fn uws_ws_send_fragment(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        compress: bool,
    ) -> uws_ws_send_status;
}
unsafe extern "C" {
    #[doc = " Sends the last fragment of a message to the web socket.\n\n @param ws The web socket.\n @param message The message.\n @param length The length of the message.\n @param compress The compress."]
    pub fn uws_ws_send_last_fragment(
        ws: uws_web_socket_t,
        message: *const ::std::os::raw::c_char,
        length: usize,
        compress: bool,
    ) -> uws_ws_send_status;
}
unsafe extern "C" {
    #[doc = " Checks if the web socket has negotiated compression.\n\n @param ws The web socket.\n @return The compression status."]
    pub fn uws_ws_has_negotiated_compression(ws: uws_web_socket_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Ends the web socket.\n\n @param ws The web socket.\n @param code The code.\n @param message The message.\n @param length The length of the message."]
    pub fn uws_ws_end(
        ws: uws_web_socket_t,
        code: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Closes the web socket.\n\n @param ws The web socket.\n @param code The code.\n @param message The message.\n @param length The length of the message."]
    pub fn uws_ws_close(
        ws: uws_web_socket_t,
        code: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Gets the user data of the web socket.\n\n @param ws The web socket.\n @return The user data."]
    pub fn uws_ws_get_user_data(ws: uws_web_socket_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " The cork handler type."]
pub type uws_ws_cork_handler_t = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, ws: uws_web_socket_t),
>;
unsafe extern "C" {
    #[doc = " Corks the web socket.\n\n @param ws The web socket.\n @param user_data The user data.\n @param handler The cork handler."]
    pub fn uws_ws_cork(
        ws: uws_web_socket_t,
        user_data: *mut ::std::os::raw::c_void,
        handler: uws_ws_cork_handler_t,
    );
}
unsafe extern "C" {
    #[doc = " Subscribes to a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic."]
    pub fn uws_ws_subscribe(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Unsubscribes from a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic."]
    pub fn uws_ws_unsubscribe(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if the web socket is subscribed to a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic."]
    pub fn uws_ws_is_subscribed(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Publishes a message to a topic.\n\n @param ws The web socket.\n @param topic The topic.\n @param topic_length The length of the topic.\n @param message The message.\n @param message_length The length of the message.\n @param opcode The opcode.\n @param compress The compress."]
    pub fn uws_ws_publish(
        ws: uws_web_socket_t,
        topic: *const ::std::os::raw::c_char,
        topic_length: usize,
        message: *const ::std::os::raw::c_char,
        message_length: usize,
        opcode: uws_opcode_t,
        compress: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the buffered amount of the web socket.\n\n @param ws The web socket.\n @return The buffered amount."]
    pub fn uws_ws_get_buffered_amount(ws: uws_web_socket_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Gets the remote address of the web socket.\n\n @param ws The web socket.\n @param length The length of the remote address.\n @return The remote address."]
    pub fn uws_ws_get_remote_address(
        ws: uws_web_socket_t,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Publishes a message to a topic.\n\n @param app The app.\n @param topic The topic.\n @param message The message.\n @param length The length of the message.\n @param opcode The opcode.\n @param compress The compress."]
    pub fn uws_app_publish(
        app: uws_app_t,
        topic: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        length: usize,
        opcode: uws_opcode_t,
        compress: bool,
    ) -> bool;
}
#[doc = " The TCP behavior type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uws_tcp_behavior_s {
    pub idle_timeout_seconds: u32,
    pub long_timeout_minutes: u32,
    pub max_backpressure_bytes: u32,
    pub conn_user_data_size: u16,
    pub close_on_backpressure_limit: bool,
    pub reset_idle_timeout_on_send: bool,
    pub on_open: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_close: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            code: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub on_connect_error: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            code: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub on_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            data: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub on_writable:
        ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t, remaining: u64)>,
    pub on_drain: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_dropped: ::std::option::Option<
        unsafe extern "C" fn(
            conn: uws_tcp_conn_t,
            data: *const ::std::os::raw::c_char,
            length: usize,
        ),
    >,
    pub on_end: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_timeout: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_long_timeout: ::std::option::Option<unsafe extern "C" fn(conn: uws_tcp_conn_t)>,
    pub on_server_name: ::std::option::Option<
        unsafe extern "C" fn(conn: uws_tcp_conn_t, server_name: *const ::std::os::raw::c_char),
    >,
}
#[doc = " The TCP behavior type."]
pub type uws_tcp_behavior_t = uws_tcp_behavior_s;
unsafe extern "C" {
    #[doc = " Creates a TCP server app.\n\n @param behavior The behavior of the TCP server.\n @param listener_host The host to listen on.\n @param listener_host_length The length of the listener host.\n @param listener_port The port to listen on.\n @param listener_options The options for the listener."]
    pub fn uws_create_tcp_server_app(
        behavior: uws_tcp_behavior_t,
        listener_host: *const ::std::os::raw::c_char,
        listener_host_length: usize,
        listener_port: ::std::os::raw::c_int,
        listener_options: ::std::os::raw::c_int,
    ) -> uws_tcp_server_app_t;
}
unsafe extern "C" {
    #[doc = " Creates a TCP server SSL app.\n\n @param behavior The behavior of the TCP server.\n @param listener_host The host to listen on.\n @param listener_host_length The length of the listener host.\n @param listener_port The port to listen on.\n @param listener_options The options for the listener.\n @param ssl_options The SSL options.\n @param server_names The server names.\n @param server_names_length The length of the server names."]
    pub fn uws_create_tcp_server_ssl_app(
        behavior: uws_tcp_behavior_t,
        listener_host: *const ::std::os::raw::c_char,
        listener_host_length: usize,
        listener_port: ::std::os::raw::c_int,
        listener_options: ::std::os::raw::c_int,
        ssl_options: uws_ssl_options_t,
        server_names: *mut *const ::std::os::raw::c_char,
        server_names_length: usize,
    ) -> uws_tcp_server_app_t;
}
unsafe extern "C" {
    #[doc = " Creates a TCP client app.\n\n @param behavior The behavior of the TCP client."]
    pub fn uws_create_tcp_client_app(behavior: uws_tcp_behavior_t) -> uws_tcp_client_app_t;
}
unsafe extern "C" {
    #[doc = " Creates a TCP client SSL app.\n\n @param behavior The behavior of the TCP client.\n @param ssl_options The SSL options."]
    pub fn uws_create_tcp_client_ssl_app(
        behavior: uws_tcp_behavior_t,
        ssl_options: uws_ssl_options_t,
    ) -> uws_tcp_client_app_t;
}
pub type DWORD = ::std::os::raw::c_ulong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type SOCKET = UINT_PTR;
pub const LIBUS_LISTEN_DEFAULT: _bindgen_ty_3 = 0;
pub const LIBUS_LISTEN_EXCLUSIVE_PORT: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_socket_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_timer_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_loop_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_poll_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_udp_socket_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_udp_packet_buffer_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn us_socket_send_buffer(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn us_udp_packet_buffer_payload(
        buf: *mut us_udp_packet_buffer_t,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn us_udp_packet_buffer_payload_length(
        buf: *mut us_udp_packet_buffer_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_udp_packet_buffer_local_ip(
        buf: *mut us_udp_packet_buffer_t,
        index: ::std::os::raw::c_int,
        ip: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_udp_socket_bound_port(s: *mut us_udp_socket_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_udp_packet_buffer_peer(
        buf: *mut us_udp_packet_buffer_t,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn us_udp_packet_buffer_ecn(
        buf: *mut us_udp_packet_buffer_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_udp_socket_receive(
        s: *mut us_udp_socket_t,
        buf: *mut us_udp_packet_buffer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_udp_buffer_set_packet_payload(
        send_buf: *mut us_udp_packet_buffer_t,
        index: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
        payload: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_int,
        peer_addr: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn us_udp_socket_send(
        s: *mut us_udp_socket_t,
        buf: *mut us_udp_packet_buffer_t,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_create_udp_packet_buffer() -> *mut us_udp_packet_buffer_t;
}
unsafe extern "C" {
    pub fn us_create_udp_socket(
        loop_: *mut us_loop_t,
        buf: *mut us_udp_packet_buffer_t,
        data_cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut us_udp_socket_t,
                arg2: *mut us_udp_packet_buffer_t,
                arg3: ::std::os::raw::c_int,
            ),
        >,
        drain_cb: ::std::option::Option<unsafe extern "C" fn(arg1: *mut us_udp_socket_t)>,
        host: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
        user: *mut ::std::os::raw::c_void,
    ) -> *mut us_udp_socket_t;
}
unsafe extern "C" {
    pub fn us_udp_socket_user(s: *mut us_udp_socket_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_udp_socket_bind(
        s: *mut us_udp_socket_t,
        hostname: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_create_timer(
        loop_: *mut us_loop_t,
        fallthrough: ::std::os::raw::c_int,
        ext_size: ::std::os::raw::c_uint,
    ) -> *mut us_timer_t;
}
unsafe extern "C" {
    pub fn us_timer_ext(timer: *mut us_timer_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_timer_close(timer: *mut us_timer_t);
}
unsafe extern "C" {
    pub fn us_timer_set(
        timer: *mut us_timer_t,
        cb: ::std::option::Option<unsafe extern "C" fn(t: *mut us_timer_t)>,
        ms: ::std::os::raw::c_int,
        repeat_ms: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn us_timer_loop(t: *mut us_timer_t) -> *mut us_loop_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_socket_context_options_t {
    pub key_file_name: *const ::std::os::raw::c_char,
    pub cert_file_name: *const ::std::os::raw::c_char,
    pub passphrase: *const ::std::os::raw::c_char,
    pub dh_params_file_name: *const ::std::os::raw::c_char,
    pub ca_file_name: *const ::std::os::raw::c_char,
    pub ssl_ciphers: *const ::std::os::raw::c_char,
    pub ssl_prefer_low_memory_usage: ::std::os::raw::c_int,
}
impl Default for us_socket_context_options_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn us_socket_context_timestamp(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
    ) -> ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn us_socket_context_add_server_name(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        hostname_pattern: *const ::std::os::raw::c_char,
        options: us_socket_context_options_t,
        user: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_remove_server_name(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        hostname_pattern: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_server_name(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut us_socket_context_t,
                hostname: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_server_name_userdata(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_socket_context_find_server_name_userdata(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        hostname_pattern: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_socket_context_get_native_handle(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_create_socket_context(
        ssl: ::std::os::raw::c_int,
        loop_: *mut us_loop_t,
        ext_size: ::std::os::raw::c_int,
        options: us_socket_context_options_t,
    ) -> *mut us_socket_context_t;
}
unsafe extern "C" {
    pub fn us_socket_context_free(ssl: ::std::os::raw::c_int, context: *mut us_socket_context_t);
}
unsafe extern "C" {
    pub fn us_socket_context_on_pre_open(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_pre_open: ::std::option::Option<
            unsafe extern "C" fn(context: *mut us_socket_context_t, fd: SOCKET) -> SOCKET,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_open(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_open: ::std::option::Option<
            unsafe extern "C" fn(
                s: *mut us_socket_t,
                is_client: ::std::os::raw::c_int,
                ip: *mut ::std::os::raw::c_char,
                ip_length: ::std::os::raw::c_int,
            ) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_close(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_close: ::std::option::Option<
            unsafe extern "C" fn(
                s: *mut us_socket_t,
                code: ::std::os::raw::c_int,
                reason: *mut ::std::os::raw::c_void,
            ) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_data(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_data: ::std::option::Option<
            unsafe extern "C" fn(
                s: *mut us_socket_t,
                data: *mut ::std::os::raw::c_char,
                length: ::std::os::raw::c_int,
            ) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_writable(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_writable: ::std::option::Option<
            unsafe extern "C" fn(s: *mut us_socket_t) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_timeout(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_timeout: ::std::option::Option<
            unsafe extern "C" fn(s: *mut us_socket_t) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_long_timeout(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_timeout: ::std::option::Option<
            unsafe extern "C" fn(s: *mut us_socket_t) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_connect_error(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_connect_error: ::std::option::Option<
            unsafe extern "C" fn(
                s: *mut us_socket_t,
                code: ::std::os::raw::c_int,
            ) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_on_end(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        on_end: ::std::option::Option<
            unsafe extern "C" fn(s: *mut us_socket_t) -> *mut us_socket_t,
        >,
    );
}
unsafe extern "C" {
    pub fn us_socket_context_ext(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_socket_context_close(ssl: ::std::os::raw::c_int, context: *mut us_socket_context_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct us_listen_socket_t {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn us_socket_context_listen(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        host: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
        socket_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_listen_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_context_listen_ip4(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        host: u32,
        port: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
        socket_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_listen_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_context_listen_unix(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        path: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
        socket_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_listen_socket_t;
}
unsafe extern "C" {
    pub fn us_listen_socket_close(ssl: ::std::os::raw::c_int, ls: *mut us_listen_socket_t);
}
unsafe extern "C" {
    pub fn us_adopt_accepted_socket(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        client_fd: SOCKET,
        socket_ext_size: ::std::os::raw::c_uint,
        addr_ip: *mut ::std::os::raw::c_char,
        addr_ip_length: ::std::os::raw::c_int,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_context_connect(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        host: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        source_host: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
        socket_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_context_connect_ip4(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        host: u32,
        port: ::std::os::raw::c_int,
        source_host: u32,
        options: ::std::os::raw::c_int,
        socket_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_context_connect_unix(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        server_path: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
        socket_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_is_established(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_close_connecting(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_context_loop(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
    ) -> *mut us_loop_t;
}
unsafe extern "C" {
    pub fn us_socket_context_adopt_socket(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        s: *mut us_socket_t,
        ext_size: ::std::os::raw::c_int,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_create_child_socket_context(
        ssl: ::std::os::raw::c_int,
        context: *mut us_socket_context_t,
        context_ext_size: ::std::os::raw::c_int,
    ) -> *mut us_socket_context_t;
}
unsafe extern "C" {
    pub fn us_create_loop(
        hint: *mut ::std::os::raw::c_void,
        wakeup_cb: ::std::option::Option<unsafe extern "C" fn(loop_: *mut us_loop_t)>,
        pre_cb: ::std::option::Option<unsafe extern "C" fn(loop_: *mut us_loop_t)>,
        post_cb: ::std::option::Option<unsafe extern "C" fn(loop_: *mut us_loop_t)>,
        ext_size: ::std::os::raw::c_uint,
    ) -> *mut us_loop_t;
}
unsafe extern "C" {
    pub fn us_loop_free(loop_: *mut us_loop_t);
}
unsafe extern "C" {
    pub fn us_loop_ext(loop_: *mut us_loop_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_loop_run(loop_: *mut us_loop_t);
}
unsafe extern "C" {
    pub fn us_wakeup_loop(loop_: *mut us_loop_t);
}
unsafe extern "C" {
    pub fn us_loop_integrate(loop_: *mut us_loop_t);
}
unsafe extern "C" {
    pub fn us_loop_iteration_number(loop_: *mut us_loop_t) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn us_create_poll(
        loop_: *mut us_loop_t,
        fallthrough: ::std::os::raw::c_int,
        ext_size: ::std::os::raw::c_uint,
    ) -> *mut us_poll_t;
}
unsafe extern "C" {
    pub fn us_poll_free(p: *mut us_poll_t, loop_: *mut us_loop_t);
}
unsafe extern "C" {
    pub fn us_poll_init(p: *mut us_poll_t, fd: SOCKET, poll_type: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn us_poll_start(p: *mut us_poll_t, loop_: *mut us_loop_t, events: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn us_poll_change(p: *mut us_poll_t, loop_: *mut us_loop_t, events: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn us_poll_stop(p: *mut us_poll_t, loop_: *mut us_loop_t);
}
unsafe extern "C" {
    pub fn us_poll_events(p: *mut us_poll_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_poll_ext(p: *mut us_poll_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_poll_fd(p: *mut us_poll_t) -> SOCKET;
}
unsafe extern "C" {
    pub fn us_poll_resize(
        p: *mut us_poll_t,
        loop_: *mut us_loop_t,
        ext_size: ::std::os::raw::c_uint,
    ) -> *mut us_poll_t;
}
unsafe extern "C" {
    pub fn us_socket_get_native_handle(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_socket_write(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        msg_more: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_write2(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
        header: *const ::std::os::raw::c_char,
        header_length: ::std::os::raw::c_int,
        payload: *const ::std::os::raw::c_char,
        payload_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_timeout(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
        seconds: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn us_socket_long_timeout(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
        minutes: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn us_socket_ext(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn us_socket_context(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> *mut us_socket_context_t;
}
unsafe extern "C" {
    pub fn us_socket_flush(ssl: ::std::os::raw::c_int, s: *mut us_socket_t);
}
unsafe extern "C" {
    pub fn us_socket_shutdown(ssl: ::std::os::raw::c_int, s: *mut us_socket_t);
}
unsafe extern "C" {
    pub fn us_socket_shutdown_read(ssl: ::std::os::raw::c_int, s: *mut us_socket_t);
}
unsafe extern "C" {
    pub fn us_socket_is_shut_down(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_is_closed(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_close(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
        code: ::std::os::raw::c_int,
        reason: *mut ::std::os::raw::c_void,
    ) -> *mut us_socket_t;
}
unsafe extern "C" {
    pub fn us_socket_local_port(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_remote_port(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn us_socket_remote_address(
        ssl: ::std::os::raw::c_int,
        s: *mut us_socket_t,
        buf: *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
    );
}
pub type mdbx_mode_t = ::std::os::raw::c_ushort;
pub type mdbx_filehandle_t = HANDLE;
pub type mdbx_pid_t = DWORD;
pub type mdbx_tid_t = DWORD;
#[doc = " \\brief libmdbx version information, \\see https://semver.org/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_version_info {
    #[doc = "< Major version number"]
    pub major: u16,
    #[doc = "< Minor version number"]
    pub minor: u16,
    #[doc = "< Patch number"]
    pub patch: u16,
    #[doc = "< Tweak number"]
    pub tweak: u16,
    #[doc = "< Semantic Versioning `pre-release`"]
    pub semver_prerelease: *const ::std::os::raw::c_char,
    #[doc = "< source information from git"]
    pub git: MDBX_version_info__bindgen_ty_1,
    #[doc = "< sourcery anchor for pinning"]
    pub sourcery: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_version_info__bindgen_ty_1 {
    #[doc = "< committer date, strict ISO-8601 format"]
    pub datetime: *const ::std::os::raw::c_char,
    #[doc = "< commit hash (hexadecimal digits)"]
    pub tree: *const ::std::os::raw::c_char,
    #[doc = "< tree hash, i.e. digest of the source code"]
    pub commit: *const ::std::os::raw::c_char,
    #[doc = "< git-describe string"]
    pub describe: *const ::std::os::raw::c_char,
}
impl Default for MDBX_version_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for MDBX_version_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief libmdbx version information"]
    pub static mdbx_version: MDBX_version_info;
}
#[doc = " \\brief libmdbx build information\n \\attention Some strings could be NULL in case no corresponding information\n            was provided at build time (i.e. flags)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_build_info {
    #[doc = "< build timestamp (ISO-8601 or __DATE__ __TIME__)"]
    pub datetime: *const ::std::os::raw::c_char,
    #[doc = "< cpu/arch-system-config triplet"]
    pub target: *const ::std::os::raw::c_char,
    #[doc = "< mdbx-related options"]
    pub options: *const ::std::os::raw::c_char,
    #[doc = "< compiler"]
    pub compiler: *const ::std::os::raw::c_char,
    #[doc = "< CFLAGS and CXXFLAGS"]
    pub flags: *const ::std::os::raw::c_char,
    #[doc = "< an extra/custom information provided via\nthe MDBX_BUILD_METADATA definition\nduring library build"]
    pub metadata: *const ::std::os::raw::c_char,
}
impl Default for MDBX_build_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief libmdbx build information"]
    pub static mdbx_build: MDBX_build_info;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_txn {
    _unused: [u8; 0],
}
#[doc = " \\brief A handle for an individual table (key-value spaces) in the\n environment.\n \\ingroup c_dbi\n \\details Zero handle is used internally (hidden Garbage Collection table).\n So, any valid DBI-handle great than 0 and less than or equal\n \\ref MDBX_MAX_DBI.\n \\see mdbx_dbi_open() \\see mdbx_dbi_close()"]
pub type MDBX_dbi = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_cursor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    #[doc = "< pointer to some data"]
    pub iov_base: *mut ::std::os::raw::c_void,
    #[doc = "< the length of data in bytes"]
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type MDBX_val = iovec;
#[doc = " The hard limit for DBI handles."]
pub const MDBX_constants_MDBX_MAX_DBI: MDBX_constants = 32765;
#[doc = " The maximum size of a data item."]
pub const MDBX_constants_MDBX_MAXDATASIZE: MDBX_constants = 2147418112;
#[doc = " The minimal database page size in bytes."]
pub const MDBX_constants_MDBX_MIN_PAGESIZE: MDBX_constants = 256;
#[doc = " The maximal database page size in bytes."]
pub const MDBX_constants_MDBX_MAX_PAGESIZE: MDBX_constants = 65536;
pub type MDBX_constants = ::std::os::raw::c_int;
#[doc = " Critical conditions, i.e. assertion failures.\n \\note libmdbx always produces such messages regardless\n of \\ref MDBX_DEBUG build option."]
pub const MDBX_log_level_MDBX_LOG_FATAL: MDBX_log_level = 0;
#[doc = " Enables logging for error conditions\n and \\ref MDBX_LOG_FATAL.\n \\note libmdbx always produces such messages regardless\n of \\ref MDBX_DEBUG build option."]
pub const MDBX_log_level_MDBX_LOG_ERROR: MDBX_log_level = 1;
#[doc = " Enables logging for warning conditions\n and \\ref MDBX_LOG_ERROR ... \\ref MDBX_LOG_FATAL.\n \\note libmdbx always produces such messages regardless\n of \\ref MDBX_DEBUG build option."]
pub const MDBX_log_level_MDBX_LOG_WARN: MDBX_log_level = 2;
#[doc = " Enables logging for normal but significant condition\n and \\ref MDBX_LOG_WARN ... \\ref MDBX_LOG_FATAL.\n \\note libmdbx always produces such messages regardless\n of \\ref MDBX_DEBUG build option."]
pub const MDBX_log_level_MDBX_LOG_NOTICE: MDBX_log_level = 3;
#[doc = " Enables logging for verbose informational\n and \\ref MDBX_LOG_NOTICE ... \\ref MDBX_LOG_FATAL.\n \\note Requires build libmdbx with \\ref MDBX_DEBUG option."]
pub const MDBX_log_level_MDBX_LOG_VERBOSE: MDBX_log_level = 4;
#[doc = " Enables logging for debug-level messages\n and \\ref MDBX_LOG_VERBOSE ... \\ref MDBX_LOG_FATAL.\n \\note Requires build libmdbx with \\ref MDBX_DEBUG option."]
pub const MDBX_log_level_MDBX_LOG_DEBUG: MDBX_log_level = 5;
#[doc = " Enables logging for trace debug-level messages\n and \\ref MDBX_LOG_DEBUG ... \\ref MDBX_LOG_FATAL.\n \\note Requires build libmdbx with \\ref MDBX_DEBUG option."]
pub const MDBX_log_level_MDBX_LOG_TRACE: MDBX_log_level = 6;
#[doc = " Enables extra debug-level messages (dump pgno lists)\n and all other log-messages.\n \\note Requires build libmdbx with \\ref MDBX_DEBUG option."]
pub const MDBX_log_level_MDBX_LOG_EXTRA: MDBX_log_level = 7;
#[doc = " for \\ref mdbx_setup_debug() only: Don't change current settings"]
pub const MDBX_log_level_MDBX_LOG_DONTCHANGE: MDBX_log_level = -1;
#[doc = " Log level\n \\note Levels detailed than (great than) \\ref MDBX_LOG_NOTICE\n requires build libmdbx with \\ref MDBX_DEBUG option."]
pub type MDBX_log_level = ::std::os::raw::c_int;
#[doc = " Log level\n \\note Levels detailed than (great than) \\ref MDBX_LOG_NOTICE\n requires build libmdbx with \\ref MDBX_DEBUG option."]
pub use self::MDBX_log_level as MDBX_log_level_t;
pub const MDBX_debug_flags_MDBX_DBG_NONE: MDBX_debug_flags = 0;
#[doc = " Enable assertion checks.\n \\note Always enabled for builds with `MDBX_FORCE_ASSERTIONS` option,\n otherwise requires build with \\ref MDBX_DEBUG > 0"]
pub const MDBX_debug_flags_MDBX_DBG_ASSERT: MDBX_debug_flags = 1;
#[doc = " Enable pages usage audit at commit transactions.\n \\note Requires build with \\ref MDBX_DEBUG > 0"]
pub const MDBX_debug_flags_MDBX_DBG_AUDIT: MDBX_debug_flags = 2;
#[doc = " Enable small random delays in critical points.\n \\note Requires build with \\ref MDBX_DEBUG > 0"]
pub const MDBX_debug_flags_MDBX_DBG_JITTER: MDBX_debug_flags = 4;
#[doc = " Include or not meta-pages in coredump files.\n \\note May affect performance in \\ref MDBX_WRITEMAP mode"]
pub const MDBX_debug_flags_MDBX_DBG_DUMP: MDBX_debug_flags = 8;
#[doc = " Allow multi-opening environment(s)"]
pub const MDBX_debug_flags_MDBX_DBG_LEGACY_MULTIOPEN: MDBX_debug_flags = 16;
#[doc = " Allow read and write transactions overlapping for the same thread."]
pub const MDBX_debug_flags_MDBX_DBG_LEGACY_OVERLAP: MDBX_debug_flags = 32;
#[doc = " Don't auto-upgrade format signature.\n \\note However a new write transactions will use and store\n the last signature regardless this flag"]
pub const MDBX_debug_flags_MDBX_DBG_DONT_UPGRADE: MDBX_debug_flags = 64;
#[doc = " for mdbx_setup_debug() only: Don't change current settings"]
pub const MDBX_debug_flags_MDBX_DBG_DONTCHANGE: MDBX_debug_flags = -1;
#[doc = " \\brief Runtime debug flags\n\n \\details `MDBX_DBG_DUMP` and `MDBX_DBG_LEGACY_MULTIOPEN` always have an\n effect, but `MDBX_DBG_ASSERT`, `MDBX_DBG_AUDIT` and `MDBX_DBG_JITTER` only if\n libmdbx built with \\ref MDBX_DEBUG."]
pub type MDBX_debug_flags = ::std::os::raw::c_int;
#[doc = " \\brief Runtime debug flags\n\n \\details `MDBX_DBG_DUMP` and `MDBX_DBG_LEGACY_MULTIOPEN` always have an\n effect, but `MDBX_DBG_ASSERT`, `MDBX_DBG_AUDIT` and `MDBX_DBG_JITTER` only if\n libmdbx built with \\ref MDBX_DEBUG."]
pub use self::MDBX_debug_flags as MDBX_debug_flags_t;
#[doc = " \\brief A debug-logger callback function,\n called before printing the message and aborting.\n \\see mdbx_setup_debug()\n\n \\param [in] loglevel  The severity of message.\n \\param [in] function  The function name which emits message,\n                       may be NULL.\n \\param [in] line      The source code line number which emits message,\n                       may be zero.\n \\param [in] fmt       The printf-like format string with message.\n \\param [in] args      The variable argument list respectively for the\n                       format-message string passed by `fmt` argument.\n                       Maybe NULL or invalid if the format-message string\n                       don't contain `%`-specification of arguments."]
pub type MDBX_debug_func = ::std::option::Option<
    unsafe extern "C" fn(
        loglevel: MDBX_log_level_t,
        function: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Setup global log-level, debug options and debug logger.\n \\returns The previously `debug_flags` in the 0-15 bits\n          and `log_level` in the 16-31 bits."]
    pub fn mdbx_setup_debug(
        log_level: MDBX_log_level_t,
        debug_flags: MDBX_debug_flags_t,
        logger: MDBX_debug_func,
    ) -> ::std::os::raw::c_int;
}
pub type MDBX_debug_func_nofmt = ::std::option::Option<
    unsafe extern "C" fn(
        loglevel: MDBX_log_level_t,
        function: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ),
>;
unsafe extern "C" {
    pub fn mdbx_setup_debug_nofmt(
        log_level: MDBX_log_level_t,
        debug_flags: MDBX_debug_flags_t,
        logger: MDBX_debug_func_nofmt,
        logger_buffer: *mut ::std::os::raw::c_char,
        logger_buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief A callback function for most MDBX assert() failures,\n called before printing the message and aborting.\n \\see mdbx_env_set_assert()\n\n \\param [in] env       An environment handle.\n \\param [in] msg       The assertion message, not including newline.\n \\param [in] function  The function name where the assertion check failed,\n                       may be NULL.\n \\param [in] line      The line number in the source file\n                       where the assertion check failed, may be zero."]
pub type MDBX_assert_func = ::std::option::Option<
    unsafe extern "C" fn(
        env: *const MDBX_env,
        msg: *const ::std::os::raw::c_char,
        function: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Set or reset the assert() callback of the environment.\n\n Does nothing if libmdbx was built with MDBX_DEBUG=0 or with NDEBUG,\n and will return `MDBX_ENOSYS` in such case.\n\n \\param [in] env   An environment handle returned by mdbx_env_create().\n \\param [in] func  An MDBX_assert_func function, or 0.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_assert(env: *mut MDBX_env, func: MDBX_assert_func)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Dump given MDBX_val to the buffer\n\n Dumps it as string if value is printable (all bytes in the range 0x20..0x7E),\n otherwise made hexadecimal dump. Requires at least 4 byte length buffer.\n\n \\returns One of:\n  - NULL if given buffer size less than 4 bytes;\n  - pointer to constant string if given value NULL or empty;\n  - otherwise pointer to given buffer."]
    pub fn mdbx_dump_val(
        key: *const MDBX_val,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief Panics with message and causes abnormal process termination."]
    pub fn mdbx_panic(fmt: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    #[doc = " \\brief Panics with asserton failed message and causes abnormal process\n termination."]
    pub fn mdbx_assert_fail(
        env: *const MDBX_env,
        msg: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
    );
}
pub const MDBX_env_flags_MDBX_ENV_DEFAULTS: MDBX_env_flags = 0;
#[doc = " Extra validation of DB structure and pages content.\n\n The `MDBX_VALIDATION` enabled the simple safe/careful mode for working\n with damaged or untrusted DB. However, a notable performance\n degradation should be expected."]
pub const MDBX_env_flags_MDBX_VALIDATION: MDBX_env_flags = 8192;
#[doc = " No environment directory.\n\n By default, MDBX creates its environment in a directory whose pathname is\n given in path, and creates its data and lock files under that directory.\n With this option, path is used as-is for the database main data file.\n The database lock file is the path with \"-lck\" appended.\n\n - with `MDBX_NOSUBDIR` = in a filesystem we have the pair of MDBX-files\n   which names derived from given pathname by appending predefined suffixes.\n\n - without `MDBX_NOSUBDIR` = in a filesystem we have the MDBX-directory with\n   given pathname, within that a pair of MDBX-files with predefined names.\n\n This flag affects only at new environment creating by \\ref mdbx_env_open(),\n otherwise at opening an existing environment libmdbx will choice this\n automatically."]
pub const MDBX_env_flags_MDBX_NOSUBDIR: MDBX_env_flags = 16384;
#[doc = " Read only mode.\n\n Open the environment in read-only mode. No write operations will be\n allowed. MDBX will still modify the lock file - except on read-only\n filesystems, where MDBX does not use locks.\n\n - with `MDBX_RDONLY` = open environment in read-only mode.\n   MDBX supports pure read-only mode (i.e. without opening LCK-file) only\n   when environment directory and/or both files are not writable (and the\n   LCK-file may be missing). In such case allowing file(s) to be placed\n   on a network read-only share.\n\n - without `MDBX_RDONLY` = open environment in read-write mode.\n\n This flag affects only at environment opening but can't be changed after."]
pub const MDBX_env_flags_MDBX_RDONLY: MDBX_env_flags = 131072;
#[doc = " Open environment in exclusive/monopolistic mode.\n\n `MDBX_EXCLUSIVE` flag can be used as a replacement for `MDB_NOLOCK`,\n which don't supported by MDBX.\n In this way, you can get the minimal overhead, but with the correct\n multi-process and multi-thread locking.\n\n - with `MDBX_EXCLUSIVE` = open environment in exclusive/monopolistic mode\n   or return \\ref MDBX_BUSY if environment already used by other process.\n   The main feature of the exclusive mode is the ability to open the\n   environment placed on a network share.\n\n - without `MDBX_EXCLUSIVE` = open environment in cooperative mode,\n   i.e. for multi-process access/interaction/cooperation.\n   The main requirements of the cooperative mode are:\n\n   1. data files MUST be placed in the LOCAL file system,\n      but NOT on a network share.\n   2. environment MUST be opened only by LOCAL processes,\n      but NOT over a network.\n   3. OS kernel (i.e. file system and memory mapping implementation) and\n      all processes that open the given environment MUST be running\n      in the physically single RAM with cache-coherency. The only\n      exception for cache-consistency requirement is Linux on MIPS\n      architecture, but this case has not been tested for a long time).\n\n This flag affects only at environment opening but can't be changed after."]
pub const MDBX_env_flags_MDBX_EXCLUSIVE: MDBX_env_flags = 4194304;
#[doc = " Using database/environment which already opened by another process(es).\n\n The `MDBX_ACCEDE` flag is useful to avoid \\ref MDBX_INCOMPATIBLE error\n while opening the database/environment which is already used by another\n process(es) with unknown mode/flags. In such cases, if there is a\n difference in the specified flags (\\ref MDBX_NOMETASYNC,\n \\ref MDBX_SAFE_NOSYNC, \\ref MDBX_UTTERLY_NOSYNC, \\ref MDBX_LIFORECLAIM\n and \\ref MDBX_NORDAHEAD), instead of returning an error,\n the database will be opened in a compatibility with the already used mode.\n\n `MDBX_ACCEDE` has no effect if the current process is the only one either\n opening the DB in read-only mode or other process(es) uses the DB in\n read-only mode."]
pub const MDBX_env_flags_MDBX_ACCEDE: MDBX_env_flags = 1073741824;
#[doc = " Map data into memory with write permission.\n\n Use a writeable memory map unless \\ref MDBX_RDONLY is set. This uses fewer\n mallocs and requires much less work for tracking database pages, but\n loses protection from application bugs like wild pointer writes and other\n bad updates into the database. This may be slightly faster for DBs that\n fit entirely in RAM, but is slower for DBs larger than RAM. Also adds the\n possibility for stray application writes thru pointers to silently\n corrupt the database.\n\n - with `MDBX_WRITEMAP` = all data will be mapped into memory in the\n   read-write mode. This offers a significant performance benefit, since the\n   data will be modified directly in mapped memory and then flushed to disk\n   by single system call, without any memory management nor copying.\n\n - without `MDBX_WRITEMAP` = data will be mapped into memory in the\n   read-only mode. This requires stocking all modified database pages in\n   memory and then writing them to disk through file operations.\n\n \\warning On the other hand, `MDBX_WRITEMAP` adds the possibility for stray\n application writes thru pointers to silently corrupt the database.\n\n \\note The `MDBX_WRITEMAP` mode is incompatible with nested transactions,\n since this is unreasonable. I.e. nested transactions requires mallocation\n of database pages and more work for tracking ones, which neuters a\n performance boost caused by the `MDBX_WRITEMAP` mode.\n\n This flag affects only at environment opening but can't be changed after."]
pub const MDBX_env_flags_MDBX_WRITEMAP: MDBX_env_flags = 524288;
#[doc = " Отвязывает транзакции от потоков/threads насколько это возможно.\n\n Опция предназначена для приложений, которые мультиплексируют множество\n пользовательских легковесных потоков выполнения по отдельным потокам\n операционной системы, например как это происходит в средах выполнения\n GoLang и Rust. Таким приложениям также рекомендуется сериализовать\n транзакции записи в одном потоке операционной системы, поскольку блокировка\n записи MDBX использует базовые системные примитивы синхронизации и ничего\n не знает о пользовательских потоках и/или легковесных потоков среды\n выполнения. Как минимум, обязательно требуется обеспечить завершение каждой\n пишущей транзакции строго в том же потоке операционной системы где она была\n запущена.\n\n \\note Начиная с версии v0.13 опция `MDBX_NOSTICKYTHREADS` полностью\n заменяет опцию \\ref MDBX_NOTLS.\n\n При использовании `MDBX_NOSTICKYTHREADS` транзакции становятся не\n ассоциированными с создавшими их потоками выполнения. Поэтому в функциях\n API не выполняется проверка соответствия транзакции и текущего потока\n выполнения. Большинство функций работающих с транзакциями и курсорами\n становится возможным вызывать из любых потоков выполнения. Однако, также\n становится невозможно обнаружить ошибки одновременного использования\n транзакций и/или курсоров в разных потоках.\n\n Использование `MDBX_NOSTICKYTHREADS` также сужает возможности по изменению\n размера БД, так как теряется возможность отслеживать работающие с БД потоки\n выполнения и приостанавливать их на время снятия отображения БД в ОЗУ. В\n частности, по этой причине на Windows уменьшение файла БД не возможно до\n закрытия БД последним работающим с ней процессом или до последующего\n открытия БД в режиме чтения-записи.\n\n \\warning Вне зависимости от \\ref MDBX_NOSTICKYTHREADS и \\ref MDBX_NOTLS не\n допускается одновременно использование объектов API из разных потоков\n выполнения! Обеспечение всех мер для исключения одновременного\n использования объектов API из разных потоков выполнения целиком ложится на\n вас!\n\n \\warning Транзакции записи могут быть завершены только в том же потоке\n выполнения где они были запущены. Это ограничение следует из требований\n большинства операционных систем о том, что захваченный примитив\n синхронизации (мьютекс, семафор, критическая секция) должен освобождаться\n только захватившим его потоком выполнения.\n\n \\warning Создание курсора в контексте транзакции, привязка курсора к\n транзакции, отвязка курсора от транзакции и закрытие привязанного к\n транзакции курсора, являются операциями использующими как сам курсор так и\n соответствующую транзакцию. Аналогично, завершение или прерывание\n транзакции является операцией использующей как саму транзакцию, так и все\n привязанные к ней курсоры. Во избежание повреждения внутренних структур\n данных, непредсказуемого поведения, разрушение БД и потери данных следует\n не допускать возможности одновременного использования каких-либо курсора\n или транзакций из разных потоков выполнения.\n\n Читающие транзакции при использовании `MDBX_NOSTICKYTHREADS` перестают\n использовать TLS (Thread Local Storage), а слоты блокировок MVCC-снимков в\n таблице читателей привязываются только к транзакциям. Завершение каких-либо\n потоков не приводит к снятию блокировок MVCC-снимков до явного завершения\n транзакций, либо до завершения соответствующего процесса в целом.\n\n Для пишущих транзакций не выполняется проверка соответствия текущего потока\n выполнения и потока создавшего транзакцию. Однако, фиксация или прерывание\n пишущих транзакций должны выполняться строго в потоке запустившим\n транзакцию, так как эти операции связаны с захватом и освобождением\n примитивов синхронизации (мьютексов, критических секций), для которых\n большинство операционных систем требует освобождение только потоком\n захватившим ресурс.\n\n Этот флаг вступает в силу при открытии среды и не может быть изменен после."]
pub const MDBX_env_flags_MDBX_NOSTICKYTHREADS: MDBX_env_flags = 2097152;
#[doc = " \\deprecated Please use \\ref MDBX_NOSTICKYTHREADS instead."]
pub const MDBX_env_flags_MDBX_NOTLS: MDBX_env_flags = 2097152;
#[doc = " Don't do readahead.\n\n Turn off readahead. Most operating systems perform readahead on read\n requests by default. This option turns it off if the OS supports it.\n Turning it off may help random read performance when the DB is larger\n than RAM and system RAM is full.\n\n By default libmdbx dynamically enables/disables readahead depending on\n the actual database size and currently available memory. On the other\n hand, such automation has some limitation, i.e. could be performed only\n when DB size changing but can't tracks and reacts changing a free RAM\n availability, since it changes independently and asynchronously.\n\n \\note The mdbx_is_readahead_reasonable() function allows to quickly find\n out whether to use readahead or not based on the size of the data and the\n amount of available memory.\n\n This flag affects only at environment opening and can't be changed after."]
pub const MDBX_env_flags_MDBX_NORDAHEAD: MDBX_env_flags = 8388608;
#[doc = " Don't initialize malloc'ed memory before writing to datafile.\n\n Don't initialize malloc'ed memory before writing to unused spaces in the\n data file. By default, memory for pages written to the data file is\n obtained using malloc. While these pages may be reused in subsequent\n transactions, freshly malloc'ed pages will be initialized to zeroes before\n use. This avoids persisting leftover data from other code (that used the\n heap and subsequently freed the memory) into the data file.\n\n Note that many other system libraries may allocate and free memory from\n the heap for arbitrary uses. E.g., stdio may use the heap for file I/O\n buffers. This initialization step has a modest performance cost so some\n applications may want to disable it using this flag. This option can be a\n problem for applications which handle sensitive data like passwords, and\n it makes memory checkers like Valgrind noisy. This flag is not needed\n with \\ref MDBX_WRITEMAP, which writes directly to the mmap instead of using\n malloc for pages. The initialization is also skipped if \\ref MDBX_RESERVE\n is used; the caller is expected to overwrite all of the memory that was\n reserved in that case.\n\n This flag may be changed at any time using `mdbx_env_set_flags()`."]
pub const MDBX_env_flags_MDBX_NOMEMINIT: MDBX_env_flags = 16777216;
#[doc = " Aims to coalesce a Garbage Collection items.\n \\deprecated Always enabled since v0.12 and deprecated since v0.13.\n\n With `MDBX_COALESCE` flag MDBX will aims to coalesce items while recycling\n a Garbage Collection. Technically, when possible short lists of pages\n will be combined into longer ones, but to fit on one database page. As a\n result, there will be fewer items in Garbage Collection and a page lists\n are longer, which slightly increases the likelihood of returning pages to\n Unallocated space and reducing the database file.\n\n This flag may be changed at any time using mdbx_env_set_flags()."]
pub const MDBX_env_flags_MDBX_COALESCE: MDBX_env_flags = 33554432;
#[doc = " LIFO policy for recycling a Garbage Collection items.\n\n `MDBX_LIFORECLAIM` flag turns on LIFO policy for recycling a Garbage\n Collection items, instead of FIFO by default. On systems with a disk\n write-back cache, this can significantly increase write performance, up\n to several times in a best case scenario.\n\n LIFO recycling policy means that for reuse pages will be taken which became\n unused the lastest (i.e. just now or most recently). Therefore the loop of\n database pages circulation becomes as short as possible. In other words,\n the number of pages, that are overwritten in memory and on disk during a\n series of write transactions, will be as small as possible. Thus creates\n ideal conditions for the efficient operation of the disk write-back cache.\n\n \\ref MDBX_LIFORECLAIM is compatible with all no-sync flags, but gives NO\n noticeable impact in combination with \\ref MDBX_SAFE_NOSYNC or\n \\ref MDBX_UTTERLY_NOSYNC. Because MDBX will reused pages only before the\n last \"steady\" MVCC-snapshot, i.e. the loop length of database pages\n circulation will be mostly defined by frequency of calling\n \\ref mdbx_env_sync() rather than LIFO and FIFO difference.\n\n This flag may be changed at any time using mdbx_env_set_flags()."]
pub const MDBX_env_flags_MDBX_LIFORECLAIM: MDBX_env_flags = 67108864;
#[doc = " Debugging option, fill/perturb released pages."]
pub const MDBX_env_flags_MDBX_PAGEPERTURB: MDBX_env_flags = 134217728;
#[doc = " Default robust and durable sync mode.\n\n Metadata is written and flushed to disk after a data is written and\n flushed, which guarantees the integrity of the database in the event\n of a crash at any time.\n\n \\attention Please do not use other modes until you have studied all the\n details and are sure. Otherwise, you may lose your users' data, as happens\n in [Miranda NG](https://www.miranda-ng.org/) messenger."]
pub const MDBX_env_flags_MDBX_SYNC_DURABLE: MDBX_env_flags = 0;
#[doc = " Don't sync the meta-page after commit.\n\n Flush system buffers to disk only once per transaction commit, omit the\n metadata flush. Defer that until the system flushes files to disk,\n or next non-\\ref MDBX_RDONLY commit or \\ref mdbx_env_sync(). Depending on\n the platform and hardware, with \\ref MDBX_NOMETASYNC you may get a doubling\n of write performance.\n\n This trade-off maintains database integrity, but a system crash may\n undo the last committed transaction. I.e. it preserves the ACI\n (atomicity, consistency, isolation) but not D (durability) database\n property.\n\n `MDBX_NOMETASYNC` flag may be changed at any time using\n \\ref mdbx_env_set_flags() or by passing to \\ref mdbx_txn_begin() for\n particular write transaction. \\see sync_modes"]
pub const MDBX_env_flags_MDBX_NOMETASYNC: MDBX_env_flags = 262144;
#[doc = " Don't sync anything but keep previous steady commits.\n\n Like \\ref MDBX_UTTERLY_NOSYNC the `MDBX_SAFE_NOSYNC` flag disable similarly\n flush system buffers to disk when committing a transaction. But there is a\n huge difference in how are recycled the MVCC snapshots corresponding to\n previous \"steady\" transactions (see below).\n\n With \\ref MDBX_WRITEMAP the `MDBX_SAFE_NOSYNC` instructs MDBX to use\n asynchronous mmap-flushes to disk. Asynchronous mmap-flushes means that\n actually all writes will scheduled and performed by operation system on it\n own manner, i.e. unordered. MDBX itself just notify operating system that\n it would be nice to write data to disk, but no more.\n\n Depending on the platform and hardware, with `MDBX_SAFE_NOSYNC` you may get\n a multiple increase of write performance, even 10 times or more.\n\n In contrast to \\ref MDBX_UTTERLY_NOSYNC mode, with `MDBX_SAFE_NOSYNC` flag\n MDBX will keeps untouched pages within B-tree of the last transaction\n \"steady\" which was synced to disk completely. This has big implications for\n both data durability and (unfortunately) performance:\n  - a system crash can't corrupt the database, but you will lose the last\n    transactions; because MDBX will rollback to last steady commit since it\n    kept explicitly.\n  - the last steady transaction makes an effect similar to \"long-lived\" read\n    transaction (see above in the \\ref restrictions section) since prevents\n    reuse of pages freed by newer write transactions, thus the any data\n    changes will be placed in newly allocated pages.\n  - to avoid rapid database growth, the system will sync data and issue\n    a steady commit-point to resume reuse pages, each time there is\n    insufficient space and before increasing the size of the file on disk.\n\n In other words, with `MDBX_SAFE_NOSYNC` flag MDBX insures you from the\n whole database corruption, at the cost increasing database size and/or\n number of disk IOPs. So, `MDBX_SAFE_NOSYNC` flag could be used with\n \\ref mdbx_env_sync() as alternatively for batch committing or nested\n transaction (in some cases). As well, auto-sync feature exposed by\n \\ref mdbx_env_set_syncbytes() and \\ref mdbx_env_set_syncperiod() functions\n could be very useful with `MDBX_SAFE_NOSYNC` flag.\n\n The number and volume of disk IOPs with MDBX_SAFE_NOSYNC flag will\n exactly the as without any no-sync flags. However, you should expect a\n larger process's [work set](https://bit.ly/2kA2tFX) and significantly worse\n a [locality of reference](https://bit.ly/2mbYq2J), due to the more\n intensive allocation of previously unused pages and increase the size of\n the database.\n\n `MDBX_SAFE_NOSYNC` flag may be changed at any time using\n \\ref mdbx_env_set_flags() or by passing to \\ref mdbx_txn_begin() for\n particular write transaction."]
pub const MDBX_env_flags_MDBX_SAFE_NOSYNC: MDBX_env_flags = 65536;
#[doc = " \\deprecated Please use \\ref MDBX_SAFE_NOSYNC instead of `MDBX_MAPASYNC`.\n\n Since version 0.9.x the `MDBX_MAPASYNC` is deprecated and has the same\n effect as \\ref MDBX_SAFE_NOSYNC with \\ref MDBX_WRITEMAP. This just API\n simplification is for convenience and clarity."]
pub const MDBX_env_flags_MDBX_MAPASYNC: MDBX_env_flags = 65536;
#[doc = " Don't sync anything and wipe previous steady commits.\n\n Don't flush system buffers to disk when committing a transaction. This\n optimization means a system crash can corrupt the database, if buffers are\n not yet flushed to disk. Depending on the platform and hardware, with\n `MDBX_UTTERLY_NOSYNC` you may get a multiple increase of write performance,\n even 100 times or more.\n\n If the filesystem preserves write order (which is rare and never provided\n unless explicitly noted) and the \\ref MDBX_WRITEMAP and \\ref\n MDBX_LIFORECLAIM flags are not used, then a system crash can't corrupt the\n database, but you can lose the last transactions, if at least one buffer is\n not yet flushed to disk. The risk is governed by how often the system\n flushes dirty buffers to disk and how often \\ref mdbx_env_sync() is called.\n So, transactions exhibit ACI (atomicity, consistency, isolation) properties\n and only lose `D` (durability). I.e. database integrity is maintained, but\n a system crash may undo the final transactions.\n\n Otherwise, if the filesystem not preserves write order (which is\n typically) or \\ref MDBX_WRITEMAP or \\ref MDBX_LIFORECLAIM flags are used,\n you should expect the corrupted database after a system crash.\n\n So, most important thing about `MDBX_UTTERLY_NOSYNC`:\n  - a system crash immediately after commit the write transaction\n    high likely lead to database corruption.\n  - successful completion of mdbx_env_sync(force = true) after one or\n    more committed transactions guarantees consistency and durability.\n  - BUT by committing two or more transactions you back database into\n    a weak state, in which a system crash may lead to database corruption!\n    In case single transaction after mdbx_env_sync, you may lose transaction\n    itself, but not a whole database.\n\n Nevertheless, `MDBX_UTTERLY_NOSYNC` provides \"weak\" durability in case\n of an application crash (but no durability on system failure), and\n therefore may be very useful in scenarios where data durability is\n not required over a system failure (e.g for short-lived data), or if you\n can take such risk.\n\n `MDBX_UTTERLY_NOSYNC` flag may be changed at any time using\n \\ref mdbx_env_set_flags(), but don't has effect if passed to\n \\ref mdbx_txn_begin() for particular write transaction. \\see sync_modes"]
pub const MDBX_env_flags_MDBX_UTTERLY_NOSYNC: MDBX_env_flags = 1114112;
#[doc = " \\brief Environment flags\n \\ingroup c_opening\n \\anchor env_flags\n \\see mdbx_env_open() \\see mdbx_env_set_flags()"]
pub type MDBX_env_flags = ::std::os::raw::c_int;
#[doc = " \\brief Environment flags\n \\ingroup c_opening\n \\anchor env_flags\n \\see mdbx_env_open() \\see mdbx_env_set_flags()"]
pub use self::MDBX_env_flags as MDBX_env_flags_t;
#[doc = " Start read-write transaction.\n\n Only one write transaction may be active at a time. Writes are fully\n serialized, which guarantees that writers can never deadlock."]
pub const MDBX_txn_flags_MDBX_TXN_READWRITE: MDBX_txn_flags = 0;
#[doc = " Start read-only transaction.\n\n There can be multiple read-only transactions simultaneously that do not\n block each other and a write transactions."]
pub const MDBX_txn_flags_MDBX_TXN_RDONLY: MDBX_txn_flags = 131072;
pub const MDBX_txn_flags_MDBX_TXN_RDONLY_PREPARE: MDBX_txn_flags = 16908288;
#[doc = " Do not block when starting a write transaction."]
pub const MDBX_txn_flags_MDBX_TXN_TRY: MDBX_txn_flags = 268435456;
#[doc = " Exactly the same as \\ref MDBX_NOMETASYNC,\n but for this transaction only."]
pub const MDBX_txn_flags_MDBX_TXN_NOMETASYNC: MDBX_txn_flags = 262144;
#[doc = " Exactly the same as \\ref MDBX_SAFE_NOSYNC,\n but for this transaction only."]
pub const MDBX_txn_flags_MDBX_TXN_NOSYNC: MDBX_txn_flags = 65536;
#[doc = " Transaction is invalid.\n \\note Transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_INVALID: MDBX_txn_flags = -2147483648;
#[doc = " Transaction is finished or never began.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_FINISHED: MDBX_txn_flags = 1;
#[doc = " Transaction is unusable after an error.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_ERROR: MDBX_txn_flags = 2;
#[doc = " Transaction must write, even if dirty list is empty.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_DIRTY: MDBX_txn_flags = 4;
#[doc = " Transaction or a parent has spilled pages.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_SPILLS: MDBX_txn_flags = 8;
#[doc = " Transaction has a nested child transaction.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_HAS_CHILD: MDBX_txn_flags = 16;
#[doc = " Transaction is parked by \\ref mdbx_txn_park().\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_PARKED: MDBX_txn_flags = 32;
#[doc = " Transaction is parked by \\ref mdbx_txn_park() with `autounpark=true`,\n and therefore it can be used without explicitly calling\n \\ref mdbx_txn_unpark() first.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_AUTOUNPARK: MDBX_txn_flags = 64;
#[doc = " The transaction was blocked using the \\ref mdbx_txn_park() function,\n and then ousted by a write transaction because\n this transaction was interfered with garbage recycling.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_OUSTED: MDBX_txn_flags = 128;
#[doc = " Most operations on the transaction are currently illegal.\n \\note This is a transaction state flag. Returned from \\ref mdbx_txn_flags()\n but can't be used with \\ref mdbx_txn_begin()."]
pub const MDBX_txn_flags_MDBX_TXN_BLOCKED: MDBX_txn_flags = 51;
#[doc = " Transaction flags\n \\ingroup c_transactions\n \\anchor txn_flags\n \\see mdbx_txn_begin() \\see mdbx_txn_flags()"]
pub type MDBX_txn_flags = ::std::os::raw::c_int;
#[doc = " Transaction flags\n \\ingroup c_transactions\n \\anchor txn_flags\n \\see mdbx_txn_begin() \\see mdbx_txn_flags()"]
pub use self::MDBX_txn_flags as MDBX_txn_flags_t;
#[doc = " Variable length unique keys with usual byte-by-byte string comparison."]
pub const MDBX_db_flags_MDBX_DB_DEFAULTS: MDBX_db_flags = 0;
#[doc = " Use reverse string comparison for keys."]
pub const MDBX_db_flags_MDBX_REVERSEKEY: MDBX_db_flags = 2;
#[doc = " Use sorted duplicates, i.e. allow multi-values for a keys."]
pub const MDBX_db_flags_MDBX_DUPSORT: MDBX_db_flags = 4;
#[doc = " Numeric keys in native byte order either uint32_t or uint64_t\n (must be one of uint32_t or uint64_t, other integer types, for example,\n signed integer or uint16_t will not work).\n The keys must all be of the same size and must be aligned while passing as\n arguments."]
pub const MDBX_db_flags_MDBX_INTEGERKEY: MDBX_db_flags = 8;
#[doc = " With \\ref MDBX_DUPSORT; sorted dup items have fixed size. The data values\n must all be of the same size."]
pub const MDBX_db_flags_MDBX_DUPFIXED: MDBX_db_flags = 16;
#[doc = " With \\ref MDBX_DUPSORT and with \\ref MDBX_DUPFIXED; dups are fixed size\n like \\ref MDBX_INTEGERKEY -style integers. The data values must all be of\n the same size and must be aligned while passing as arguments."]
pub const MDBX_db_flags_MDBX_INTEGERDUP: MDBX_db_flags = 32;
#[doc = " With \\ref MDBX_DUPSORT; use reverse string comparison for data values."]
pub const MDBX_db_flags_MDBX_REVERSEDUP: MDBX_db_flags = 64;
#[doc = " Create DB if not already existing."]
pub const MDBX_db_flags_MDBX_CREATE: MDBX_db_flags = 262144;
#[doc = " Opens an existing table created with unknown flags.\n\n The `MDBX_DB_ACCEDE` flag is intend to open a existing table which\n was created with unknown flags (\\ref MDBX_REVERSEKEY, \\ref MDBX_DUPSORT,\n \\ref MDBX_INTEGERKEY, \\ref MDBX_DUPFIXED, \\ref MDBX_INTEGERDUP and\n \\ref MDBX_REVERSEDUP).\n\n In such cases, instead of returning the \\ref MDBX_INCOMPATIBLE error, the\n table will be opened with flags which it was created, and then an\n application could determine the actual flags by \\ref mdbx_dbi_flags()."]
pub const MDBX_db_flags_MDBX_DB_ACCEDE: MDBX_db_flags = 1073741824;
#[doc = " \\brief Table flags\n \\ingroup c_dbi\n \\anchor db_flags\n \\see mdbx_dbi_open()"]
pub type MDBX_db_flags = ::std::os::raw::c_int;
#[doc = " \\brief Table flags\n \\ingroup c_dbi\n \\anchor db_flags\n \\see mdbx_dbi_open()"]
pub use self::MDBX_db_flags as MDBX_db_flags_t;
#[doc = " Upsertion by default (without any other flags)"]
pub const MDBX_put_flags_MDBX_UPSERT: MDBX_put_flags = 0;
#[doc = " For insertion: Don't write if the key already exists."]
pub const MDBX_put_flags_MDBX_NOOVERWRITE: MDBX_put_flags = 16;
#[doc = " Has effect only for \\ref MDBX_DUPSORT tables.\n For upsertion: don't write if the key-value pair already exist."]
pub const MDBX_put_flags_MDBX_NODUPDATA: MDBX_put_flags = 32;
#[doc = " For upsertion: overwrite the current key/data pair.\n MDBX allows this flag for \\ref mdbx_put() for explicit overwrite/update\n without insertion.\n For deletion: remove only single entry at the current cursor position."]
pub const MDBX_put_flags_MDBX_CURRENT: MDBX_put_flags = 64;
#[doc = " Has effect only for \\ref MDBX_DUPSORT tables.\n For deletion: remove all multi-values (aka duplicates) for given key.\n For upsertion: replace all multi-values for given key with a new one."]
pub const MDBX_put_flags_MDBX_ALLDUPS: MDBX_put_flags = 128;
#[doc = " For upsertion: Just reserve space for data, don't copy it.\n Return a pointer to the reserved space."]
pub const MDBX_put_flags_MDBX_RESERVE: MDBX_put_flags = 65536;
#[doc = " Data is being appended.\n Don't split full pages, continue on a new instead."]
pub const MDBX_put_flags_MDBX_APPEND: MDBX_put_flags = 131072;
#[doc = " Has effect only for \\ref MDBX_DUPSORT tables.\n Duplicate data is being appended.\n Don't split full pages, continue on a new instead."]
pub const MDBX_put_flags_MDBX_APPENDDUP: MDBX_put_flags = 262144;
#[doc = " Only for \\ref MDBX_DUPFIXED.\n Store multiple data items in one call."]
pub const MDBX_put_flags_MDBX_MULTIPLE: MDBX_put_flags = 524288;
#[doc = " \\brief Data changing flags\n \\ingroup c_crud\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n \\see mdbx_put() \\see mdbx_cursor_put() \\see mdbx_replace()"]
pub type MDBX_put_flags = ::std::os::raw::c_int;
#[doc = " \\brief Data changing flags\n \\ingroup c_crud\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n \\see mdbx_put() \\see mdbx_cursor_put() \\see mdbx_replace()"]
pub use self::MDBX_put_flags as MDBX_put_flags_t;
pub const MDBX_copy_flags_MDBX_CP_DEFAULTS: MDBX_copy_flags = 0;
#[doc = " Copy with compactification: Omit free space from copy and renumber all\n pages sequentially"]
pub const MDBX_copy_flags_MDBX_CP_COMPACT: MDBX_copy_flags = 1;
#[doc = " Force to make resizable copy, i.e. dynamic size instead of fixed"]
pub const MDBX_copy_flags_MDBX_CP_FORCE_DYNAMIC_SIZE: MDBX_copy_flags = 2;
#[doc = " Don't explicitly flush the written data to an output media"]
pub const MDBX_copy_flags_MDBX_CP_DONT_FLUSH: MDBX_copy_flags = 4;
#[doc = " Use read transaction parking during copying MVCC-snapshot\n \\see mdbx_txn_park()"]
pub const MDBX_copy_flags_MDBX_CP_THROTTLE_MVCC: MDBX_copy_flags = 8;
#[doc = " Abort/dispose passed transaction after copy\n \\see mdbx_txn_copy2fd() \\see mdbx_txn_copy2pathname()"]
pub const MDBX_copy_flags_MDBX_CP_DISPOSE_TXN: MDBX_copy_flags = 16;
#[doc = " Enable renew/restart read transaction in case it use outdated\n MVCC shapshot, otherwise the \\ref MDBX_MVCC_RETARDED will be returned\n \\see mdbx_txn_copy2fd() \\see mdbx_txn_copy2pathname()"]
pub const MDBX_copy_flags_MDBX_CP_RENEW_TXN: MDBX_copy_flags = 32;
#[doc = " \\brief Environment copy flags\n \\ingroup c_extra\n \\see mdbx_env_copy() \\see mdbx_env_copy2fd()"]
pub type MDBX_copy_flags = ::std::os::raw::c_int;
#[doc = " \\brief Environment copy flags\n \\ingroup c_extra\n \\see mdbx_env_copy() \\see mdbx_env_copy2fd()"]
pub use self::MDBX_copy_flags as MDBX_copy_flags_t;
#[doc = " Position at first key/data item"]
pub const MDBX_cursor_op_MDBX_FIRST: MDBX_cursor_op = 0;
#[doc = " \\ref MDBX_DUPSORT -only: Position at first data item of current key."]
pub const MDBX_cursor_op_MDBX_FIRST_DUP: MDBX_cursor_op = 1;
#[doc = " \\ref MDBX_DUPSORT -only: Position at key/data pair."]
pub const MDBX_cursor_op_MDBX_GET_BOTH: MDBX_cursor_op = 2;
#[doc = " \\ref MDBX_DUPSORT -only: Position at given key and at first data greater\n than or equal to specified data."]
pub const MDBX_cursor_op_MDBX_GET_BOTH_RANGE: MDBX_cursor_op = 3;
#[doc = " Return key/data at current cursor position"]
pub const MDBX_cursor_op_MDBX_GET_CURRENT: MDBX_cursor_op = 4;
#[doc = " \\ref MDBX_DUPFIXED -only: Return up to a page of duplicate data items\n from current cursor position. Move cursor to prepare\n for \\ref MDBX_NEXT_MULTIPLE. \\see MDBX_SEEK_AND_GET_MULTIPLE"]
pub const MDBX_cursor_op_MDBX_GET_MULTIPLE: MDBX_cursor_op = 5;
#[doc = " Position at last key/data item"]
pub const MDBX_cursor_op_MDBX_LAST: MDBX_cursor_op = 6;
#[doc = " \\ref MDBX_DUPSORT -only: Position at last data item of current key."]
pub const MDBX_cursor_op_MDBX_LAST_DUP: MDBX_cursor_op = 7;
#[doc = " Position at next data item"]
pub const MDBX_cursor_op_MDBX_NEXT: MDBX_cursor_op = 8;
#[doc = " \\ref MDBX_DUPSORT -only: Position at next data item of current key."]
pub const MDBX_cursor_op_MDBX_NEXT_DUP: MDBX_cursor_op = 9;
#[doc = " \\ref MDBX_DUPFIXED -only: Return up to a page of duplicate data items\n from next cursor position. Move cursor to prepare for `MDBX_NEXT_MULTIPLE`.\n \\see MDBX_SEEK_AND_GET_MULTIPLE \\see MDBX_GET_MULTIPLE"]
pub const MDBX_cursor_op_MDBX_NEXT_MULTIPLE: MDBX_cursor_op = 10;
#[doc = " Position at first data item of next key"]
pub const MDBX_cursor_op_MDBX_NEXT_NODUP: MDBX_cursor_op = 11;
#[doc = " Position at previous data item"]
pub const MDBX_cursor_op_MDBX_PREV: MDBX_cursor_op = 12;
#[doc = " \\ref MDBX_DUPSORT -only: Position at previous data item of current key."]
pub const MDBX_cursor_op_MDBX_PREV_DUP: MDBX_cursor_op = 13;
#[doc = " Position at last data item of previous key"]
pub const MDBX_cursor_op_MDBX_PREV_NODUP: MDBX_cursor_op = 14;
#[doc = " Position at specified key"]
pub const MDBX_cursor_op_MDBX_SET: MDBX_cursor_op = 15;
#[doc = " Position at specified key, return both key and data"]
pub const MDBX_cursor_op_MDBX_SET_KEY: MDBX_cursor_op = 16;
#[doc = " Position at first key greater than or equal to specified key."]
pub const MDBX_cursor_op_MDBX_SET_RANGE: MDBX_cursor_op = 17;
#[doc = " \\ref MDBX_DUPFIXED -only: Position at previous page and return up to\n a page of duplicate data items.\n \\see MDBX_SEEK_AND_GET_MULTIPLE \\see MDBX_GET_MULTIPLE"]
pub const MDBX_cursor_op_MDBX_PREV_MULTIPLE: MDBX_cursor_op = 18;
#[doc = " Positions cursor at first key-value pair greater than or equal to\n specified, return both key and data, and the return code depends on whether\n a exact match.\n\n For non DUPSORT-ed collections this work the same to \\ref MDBX_SET_RANGE,\n but returns \\ref MDBX_SUCCESS if key found exactly or\n \\ref MDBX_RESULT_TRUE if greater key was found.\n\n For DUPSORT-ed a data value is taken into account for duplicates,\n i.e. for a pairs/tuples of a key and an each data value of duplicates.\n Returns \\ref MDBX_SUCCESS if key-value pair found exactly or\n \\ref MDBX_RESULT_TRUE if the next pair was returned."]
pub const MDBX_cursor_op_MDBX_SET_LOWERBOUND: MDBX_cursor_op = 19;
#[doc = " Positions cursor at first key-value pair greater than specified,\n return both key and data, and the return code depends on whether a\n upper-bound was found.\n\n For non DUPSORT-ed collections this work like \\ref MDBX_SET_RANGE,\n but returns \\ref MDBX_SUCCESS if the greater key was found or\n \\ref MDBX_NOTFOUND otherwise.\n\n For DUPSORT-ed a data value is taken into account for duplicates,\n i.e. for a pairs/tuples of a key and an each data value of duplicates.\n Returns \\ref MDBX_SUCCESS if the greater pair was returned or\n \\ref MDBX_NOTFOUND otherwise."]
pub const MDBX_cursor_op_MDBX_SET_UPPERBOUND: MDBX_cursor_op = 20;
#[doc = " Doubtless cursor positioning at a specified key."]
pub const MDBX_cursor_op_MDBX_TO_KEY_LESSER_THAN: MDBX_cursor_op = 21;
#[doc = " Doubtless cursor positioning at a specified key."]
pub const MDBX_cursor_op_MDBX_TO_KEY_LESSER_OR_EQUAL: MDBX_cursor_op = 22;
#[doc = " \\copydoc MDBX_TO_KEY_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_KEY_EQUAL: MDBX_cursor_op = 23;
#[doc = " \\copydoc MDBX_TO_KEY_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_KEY_GREATER_OR_EQUAL: MDBX_cursor_op = 24;
#[doc = " \\copydoc MDBX_TO_KEY_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_KEY_GREATER_THAN: MDBX_cursor_op = 25;
#[doc = " Doubtless cursor positioning at a specified key-value pair\n for dupsort/multi-value hives."]
pub const MDBX_cursor_op_MDBX_TO_EXACT_KEY_VALUE_LESSER_THAN: MDBX_cursor_op = 26;
#[doc = " Doubtless cursor positioning at a specified key-value pair\n for dupsort/multi-value hives."]
pub const MDBX_cursor_op_MDBX_TO_EXACT_KEY_VALUE_LESSER_OR_EQUAL: MDBX_cursor_op = 27;
#[doc = " \\copydoc MDBX_TO_EXACT_KEY_VALUE_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_EXACT_KEY_VALUE_EQUAL: MDBX_cursor_op = 28;
#[doc = " \\copydoc MDBX_TO_EXACT_KEY_VALUE_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_EXACT_KEY_VALUE_GREATER_OR_EQUAL: MDBX_cursor_op = 29;
#[doc = " \\copydoc MDBX_TO_EXACT_KEY_VALUE_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_EXACT_KEY_VALUE_GREATER_THAN: MDBX_cursor_op = 30;
#[doc = " Doubtless cursor positioning at a specified key-value pair\n for dupsort/multi-value hives."]
pub const MDBX_cursor_op_MDBX_TO_PAIR_LESSER_THAN: MDBX_cursor_op = 31;
#[doc = " Doubtless cursor positioning at a specified key-value pair\n for dupsort/multi-value hives."]
pub const MDBX_cursor_op_MDBX_TO_PAIR_LESSER_OR_EQUAL: MDBX_cursor_op = 32;
#[doc = " \\copydoc MDBX_TO_PAIR_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_PAIR_EQUAL: MDBX_cursor_op = 33;
#[doc = " \\copydoc MDBX_TO_PAIR_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_PAIR_GREATER_OR_EQUAL: MDBX_cursor_op = 34;
#[doc = " \\copydoc MDBX_TO_PAIR_LESSER_THAN"]
pub const MDBX_cursor_op_MDBX_TO_PAIR_GREATER_THAN: MDBX_cursor_op = 35;
#[doc = " \\ref MDBX_DUPFIXED -only: Seek to given key and return up to a page of\n duplicate data items from current cursor position. Move cursor to prepare\n for \\ref MDBX_NEXT_MULTIPLE. \\see MDBX_GET_MULTIPLE"]
pub const MDBX_cursor_op_MDBX_SEEK_AND_GET_MULTIPLE: MDBX_cursor_op = 36;
#[doc = " \\brief Cursor operations\n \\ingroup c_cursors\n This is the set of all operations for retrieving data using a cursor.\n \\see mdbx_cursor_get()"]
pub type MDBX_cursor_op = ::std::os::raw::c_int;
#[doc = " Successful result"]
pub const MDBX_error_MDBX_SUCCESS: MDBX_error = 0;
#[doc = " Alias for \\ref MDBX_SUCCESS"]
pub const MDBX_error_MDBX_RESULT_FALSE: MDBX_error = 0;
#[doc = " Successful result with special meaning or a flag"]
pub const MDBX_error_MDBX_RESULT_TRUE: MDBX_error = -1;
#[doc = " key/data pair already exists"]
pub const MDBX_error_MDBX_KEYEXIST: MDBX_error = -30799;
#[doc = " The first LMDB-compatible defined error code"]
pub const MDBX_error_MDBX_FIRST_LMDB_ERRCODE: MDBX_error = -30799;
#[doc = " key/data pair not found (EOF)"]
pub const MDBX_error_MDBX_NOTFOUND: MDBX_error = -30798;
#[doc = " Requested page not found - this usually indicates corruption"]
pub const MDBX_error_MDBX_PAGE_NOTFOUND: MDBX_error = -30797;
#[doc = " Database is corrupted (page was wrong type and so on)"]
pub const MDBX_error_MDBX_CORRUPTED: MDBX_error = -30796;
#[doc = " Environment had fatal error,\n i.e. update of meta page failed and so on."]
pub const MDBX_error_MDBX_PANIC: MDBX_error = -30795;
#[doc = " DB file version mismatch with libmdbx"]
pub const MDBX_error_MDBX_VERSION_MISMATCH: MDBX_error = -30794;
#[doc = " File is not a valid MDBX file"]
pub const MDBX_error_MDBX_INVALID: MDBX_error = -30793;
#[doc = " Environment mapsize reached"]
pub const MDBX_error_MDBX_MAP_FULL: MDBX_error = -30792;
#[doc = " Environment maxdbs reached"]
pub const MDBX_error_MDBX_DBS_FULL: MDBX_error = -30791;
#[doc = " Environment maxreaders reached"]
pub const MDBX_error_MDBX_READERS_FULL: MDBX_error = -30790;
#[doc = " Transaction has too many dirty pages, i.e transaction too big"]
pub const MDBX_error_MDBX_TXN_FULL: MDBX_error = -30788;
#[doc = " Cursor stack too deep - this usually indicates corruption,\n i.e branch-pages loop"]
pub const MDBX_error_MDBX_CURSOR_FULL: MDBX_error = -30787;
#[doc = " Page has not enough space - internal error"]
pub const MDBX_error_MDBX_PAGE_FULL: MDBX_error = -30786;
#[doc = " Database engine was unable to extend mapping, e.g. since address space\n is unavailable or busy. This can mean:\n  - Database size extended by other process beyond to environment mapsize\n    and engine was unable to extend mapping while starting read\n    transaction. Environment should be reopened to continue.\n  - Engine was unable to extend mapping during write transaction\n    or explicit call of \\ref mdbx_env_set_geometry()."]
pub const MDBX_error_MDBX_UNABLE_EXTEND_MAPSIZE: MDBX_error = -30785;
#[doc = " Environment or table is not compatible with the requested operation\n or the specified flags. This can mean:\n  - The operation expects an \\ref MDBX_DUPSORT / \\ref MDBX_DUPFIXED\n    table.\n  - Opening a named DB when the unnamed DB has \\ref MDBX_DUPSORT /\n    \\ref MDBX_INTEGERKEY.\n  - Accessing a data record as a named table, or vice versa.\n  - The table was dropped and recreated with different flags."]
pub const MDBX_error_MDBX_INCOMPATIBLE: MDBX_error = -30784;
#[doc = " Invalid reuse of reader locktable slot,\n e.g. read-transaction already run for current thread"]
pub const MDBX_error_MDBX_BAD_RSLOT: MDBX_error = -30783;
#[doc = " Transaction is not valid for requested operation,\n e.g. had errored and be must aborted, has a child/nested transaction,\n or is invalid"]
pub const MDBX_error_MDBX_BAD_TXN: MDBX_error = -30782;
#[doc = " Invalid size or alignment of key or data for target table,\n either invalid table name"]
pub const MDBX_error_MDBX_BAD_VALSIZE: MDBX_error = -30781;
#[doc = " The specified DBI-handle is invalid\n or changed by another thread/transaction"]
pub const MDBX_error_MDBX_BAD_DBI: MDBX_error = -30780;
#[doc = " Unexpected internal error, transaction should be aborted"]
pub const MDBX_error_MDBX_PROBLEM: MDBX_error = -30779;
#[doc = " The last LMDB-compatible defined error code"]
pub const MDBX_error_MDBX_LAST_LMDB_ERRCODE: MDBX_error = -30779;
#[doc = " Another write transaction is running or environment is already used while\n opening with \\ref MDBX_EXCLUSIVE flag"]
pub const MDBX_error_MDBX_BUSY: MDBX_error = -30778;
#[doc = " The first of MDBX-added error codes"]
pub const MDBX_error_MDBX_FIRST_ADDED_ERRCODE: MDBX_error = -30778;
#[doc = " The specified key has more than one associated value"]
pub const MDBX_error_MDBX_EMULTIVAL: MDBX_error = -30421;
#[doc = " Bad signature of a runtime object(s), this can mean:\n  - memory corruption or double-free;\n  - ABI version mismatch (rare case);"]
pub const MDBX_error_MDBX_EBADSIGN: MDBX_error = -30420;
#[doc = " Database should be recovered, but this could NOT be done for now\n since it opened in read-only mode"]
pub const MDBX_error_MDBX_WANNA_RECOVERY: MDBX_error = -30419;
#[doc = " The given key value is mismatched to the current cursor position"]
pub const MDBX_error_MDBX_EKEYMISMATCH: MDBX_error = -30418;
#[doc = " Database is too large for current system,\n e.g. could NOT be mapped into RAM."]
pub const MDBX_error_MDBX_TOO_LARGE: MDBX_error = -30417;
#[doc = " A thread has attempted to use a not owned object,\n e.g. a transaction that started by another thread"]
pub const MDBX_error_MDBX_THREAD_MISMATCH: MDBX_error = -30416;
#[doc = " Overlapping read and write transactions for the current thread"]
pub const MDBX_error_MDBX_TXN_OVERLAPPING: MDBX_error = -30415;
#[doc = " Внутренняя ошибка возвращаемая в случае нехватки запаса свободных страниц\n при обновлении GC. Используется как вспомогательное средство для отладки.\n \\note С точки зрения пользователя семантически\n       равнозначна \\ref MDBX_PROBLEM."]
pub const MDBX_error_MDBX_BACKLOG_DEPLETED: MDBX_error = -30414;
#[doc = " Alternative/Duplicate LCK-file is exists and should be removed manually"]
pub const MDBX_error_MDBX_DUPLICATED_CLK: MDBX_error = -30413;
#[doc = " Some cursors and/or other resources should be closed before table or\n  corresponding DBI-handle could be (re)used and/or closed."]
pub const MDBX_error_MDBX_DANGLING_DBI: MDBX_error = -30412;
#[doc = " The parked read transaction was outed for the sake of\n recycling old MVCC snapshots."]
pub const MDBX_error_MDBX_OUSTED: MDBX_error = -30411;
#[doc = " MVCC snapshot used by parked transaction was bygone."]
pub const MDBX_error_MDBX_MVCC_RETARDED: MDBX_error = -30410;
#[doc = " MVCC snapshot used by parked transaction was bygone."]
pub const MDBX_error_MDBX_LAST_ADDED_ERRCODE: MDBX_error = -30410;
pub const MDBX_error_MDBX_ENODATA: MDBX_error = 38;
pub const MDBX_error_MDBX_EINVAL: MDBX_error = 87;
pub const MDBX_error_MDBX_EACCESS: MDBX_error = 5;
pub const MDBX_error_MDBX_ENOMEM: MDBX_error = 14;
pub const MDBX_error_MDBX_EROFS: MDBX_error = 6009;
pub const MDBX_error_MDBX_ENOSYS: MDBX_error = 50;
pub const MDBX_error_MDBX_EIO: MDBX_error = 29;
pub const MDBX_error_MDBX_EPERM: MDBX_error = 1;
pub const MDBX_error_MDBX_EINTR: MDBX_error = 1223;
pub const MDBX_error_MDBX_ENOFILE: MDBX_error = 2;
pub const MDBX_error_MDBX_EREMOTE: MDBX_error = 4352;
pub const MDBX_error_MDBX_EDEADLK: MDBX_error = 1131;
#[doc = " \\brief Errors and return codes\n \\ingroup c_err\n\n BerkeleyDB uses -30800 to -30999, we'll go under them\n \\see mdbx_strerror() \\see mdbx_strerror_r() \\see mdbx_liberr2str()"]
pub type MDBX_error = ::std::os::raw::c_int;
#[doc = " \\brief Errors and return codes\n \\ingroup c_err\n\n BerkeleyDB uses -30800 to -30999, we'll go under them\n \\see mdbx_strerror() \\see mdbx_strerror_r() \\see mdbx_liberr2str()"]
pub use self::MDBX_error as MDBX_error_t;
unsafe extern "C" {
    #[doc = " \\brief Return a string describing a given error code.\n \\ingroup c_err\n\n This function is a superset of the ANSI C X3.159-1989 (ANSI C) `strerror()`\n function. If the error code is greater than or equal to 0, then the string\n returned by the system function `strerror()` is returned. If the error code\n is less than 0, an error string corresponding to the MDBX library error is\n returned. See errors for a list of MDBX-specific error codes.\n\n `mdbx_strerror()` is NOT thread-safe because may share common internal buffer\n for system messages. The returned string must NOT be modified by the\n application, but MAY be modified by a subsequent call to\n \\ref mdbx_strerror(), `strerror()` and other related functions.\n \\see mdbx_strerror_r()\n\n \\param [in] errnum  The error code.\n\n \\returns \"error message\" The description of the error."]
    pub fn mdbx_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief Return a string describing a given error code.\n \\ingroup c_err\n\n This function is a superset of the ANSI C X3.159-1989 (ANSI C) `strerror()`\n function. If the error code is greater than or equal to 0, then the string\n returned by the system function `strerror()` is returned. If the error code\n is less than 0, an error string corresponding to the MDBX library error is\n returned. See errors for a list of MDBX-specific error codes.\n\n `mdbx_strerror_r()` is thread-safe since uses user-supplied buffer where\n appropriate. The returned string must NOT be modified by the application,\n since it may be pointer to internal constant string. However, there is no\n restriction if the returned string points to the supplied buffer.\n \\see mdbx_strerror()\n\n mdbx_liberr2str() returns string describing only MDBX error numbers but NULL\n for non-MDBX error codes. This function is thread-safe since return pointer\n to constant non-localized strings.\n\n \\param [in] errnum  The error code.\n \\param [in,out] buf Buffer to store the error message.\n \\param [in] buflen The size of buffer to store the message.\n\n \\returns \"error message\" The description of the error."]
    pub fn mdbx_strerror_r(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mdbx_liberr2str(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Bit of Windows' madness. The similar to \\ref mdbx_strerror() but returns\n Windows error-messages in the OEM-encoding for console utilities.\n \\ingroup c_err\n \\see mdbx_strerror_r_ANSI2OEM()"]
    pub fn mdbx_strerror_ANSI2OEM(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Bit of Windows' madness. The similar to \\ref mdbx_strerror_r() but returns\n Windows error-messages in the OEM-encoding for console utilities.\n \\ingroup c_err\n \\see mdbx_strerror_ANSI2OEM()"]
    pub fn mdbx_strerror_r_ANSI2OEM(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief Create an MDBX environment instance.\n \\ingroup c_opening\n\n This function allocates memory for a \\ref MDBX_env structure. To release\n the allocated memory and discard the handle, call \\ref mdbx_env_close().\n Before the handle may be used, it must be opened using \\ref mdbx_env_open().\n\n Various other options may also need to be set before opening the handle,\n e.g. \\ref mdbx_env_set_geometry(), \\ref mdbx_env_set_maxreaders(),\n \\ref mdbx_env_set_maxdbs(), depending on usage requirements.\n\n \\param [out] penv  The address where the new handle will be stored.\n\n \\returns a non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_create(penv: *mut *mut MDBX_env) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Controls the maximum number of named tables for the environment.\n\n \\details By default only unnamed key-value table could used and\n appropriate value should set by `MDBX_opt_max_db` to using any more named\n table(s). To reduce overhead, use the minimum sufficient value. This option\n may only set after \\ref mdbx_env_create() and before \\ref mdbx_env_open().\n\n \\see mdbx_env_set_maxdbs() \\see mdbx_env_get_maxdbs()"]
pub const MDBX_option_MDBX_opt_max_db: MDBX_option = 0;
#[doc = " \\brief Defines the maximum number of threads/reader slots\n for all processes interacting with the database.\n\n \\details This defines the number of slots in the lock table that is used to\n track readers in the environment. The default is about 100 for 4K\n system page size. Starting a read-only transaction normally ties a lock\n table slot to the current thread until the environment closes or the thread\n exits. If \\ref MDBX_NOSTICKYTHREADS is in use, \\ref mdbx_txn_begin()\n instead ties the slot to the \\ref MDBX_txn object until it or the \\ref\n MDBX_env object is destroyed. This option may only set after \\ref\n mdbx_env_create() and before \\ref mdbx_env_open(), and has an effect only\n when the database is opened by the first process interacts with the\n database.\n\n \\see mdbx_env_set_maxreaders() \\see mdbx_env_get_maxreaders()"]
pub const MDBX_option_MDBX_opt_max_readers: MDBX_option = 1;
#[doc = " \\brief Controls interprocess/shared threshold to force flush the data\n buffers to disk, if \\ref MDBX_SAFE_NOSYNC is used.\n\n \\see mdbx_env_set_syncbytes() \\see mdbx_env_get_syncbytes()"]
pub const MDBX_option_MDBX_opt_sync_bytes: MDBX_option = 2;
#[doc = " \\brief Controls interprocess/shared relative period since the last\n unsteady commit to force flush the data buffers to disk,\n if \\ref MDBX_SAFE_NOSYNC is used.\n \\see mdbx_env_set_syncperiod() \\see mdbx_env_get_syncperiod()"]
pub const MDBX_option_MDBX_opt_sync_period: MDBX_option = 3;
#[doc = " \\brief Controls the in-process limit to grow a list of reclaimed/recycled\n page's numbers for finding a sequence of contiguous pages for large data\n items.\n \\see MDBX_opt_gc_time_limit\n\n \\details A long values requires allocation of contiguous database pages.\n To find such sequences, it may be necessary to accumulate very large lists,\n especially when placing very long values (more than a megabyte) in a large\n databases (several tens of gigabytes), which is much expensive in extreme\n cases. This threshold allows you to avoid such costs by allocating new\n pages at the end of the database (with its possible growth on disk),\n instead of further accumulating/reclaiming Garbage Collection records.\n\n On the other hand, too small threshold will lead to unreasonable database\n growth, or/and to the inability of put long values.\n\n The `MDBX_opt_rp_augment_limit` controls described limit for the current\n process. By default this limit adjusted dynamically to 1/3 of current\n quantity of DB pages, which is usually enough for most cases."]
pub const MDBX_option_MDBX_opt_rp_augment_limit: MDBX_option = 4;
#[doc = " \\brief Controls the in-process limit to grow a cache of dirty\n pages for reuse in the current transaction.\n\n \\details A 'dirty page' refers to a page that has been updated in memory\n only, the changes to a dirty page are not yet stored on disk.\n To reduce overhead, it is reasonable to release not all such pages\n immediately, but to leave some ones in cache for reuse in the current\n transaction.\n\n The `MDBX_opt_loose_limit` allows you to set a limit for such cache inside\n the current process. Should be in the range 0..255, default is 64."]
pub const MDBX_option_MDBX_opt_loose_limit: MDBX_option = 5;
#[doc = " \\brief Controls the in-process limit of a pre-allocated memory items\n for dirty pages.\n\n \\details A 'dirty page' refers to a page that has been updated in memory\n only, the changes to a dirty page are not yet stored on disk.\n Without \\ref MDBX_WRITEMAP dirty pages are allocated from memory and\n released when a transaction is committed. To reduce overhead, it is\n reasonable to release not all ones, but to leave some allocations in\n reserve for reuse in the next transaction(s).\n\n The `MDBX_opt_dp_reserve_limit` allows you to set a limit for such reserve\n inside the current process. Default is 1024."]
pub const MDBX_option_MDBX_opt_dp_reserve_limit: MDBX_option = 6;
#[doc = " \\brief Controls the in-process limit of dirty pages\n for a write transaction.\n\n \\details A 'dirty page' refers to a page that has been updated in memory\n only, the changes to a dirty page are not yet stored on disk.\n Without \\ref MDBX_WRITEMAP dirty pages are allocated from memory and will\n be busy until are written to disk. Therefore for a large transactions is\n reasonable to limit dirty pages collecting above an some threshold but\n spill to disk instead.\n\n The `MDBX_opt_txn_dp_limit` controls described threshold for the current\n process. Default is 1/42 of the sum of whole and currently available RAM\n size, which the same ones are reported by \\ref mdbx_get_sysraminfo()."]
pub const MDBX_option_MDBX_opt_txn_dp_limit: MDBX_option = 7;
#[doc = " \\brief Controls the in-process initial allocation size for dirty pages\n list of a write transaction. Default is 1024."]
pub const MDBX_option_MDBX_opt_txn_dp_initial: MDBX_option = 8;
#[doc = " \\brief Controls the in-process how maximal part of the dirty pages may be\n spilled when necessary.\n\n \\details The `MDBX_opt_spill_max_denominator` defines the denominator for\n limiting from the top for part of the current dirty pages may be spilled\n when the free room for a new dirty pages (i.e. distance to the\n `MDBX_opt_txn_dp_limit` threshold) is not enough to perform requested\n operation.\n Exactly `max_pages_to_spill = dirty_pages - dirty_pages / N`,\n where `N` is the value set by `MDBX_opt_spill_max_denominator`.\n\n Should be in the range 0..255, where zero means no limit, i.e. all dirty\n pages could be spilled. Default is 8, i.e. no more than 7/8 of the current\n dirty pages may be spilled when reached the condition described above."]
pub const MDBX_option_MDBX_opt_spill_max_denominator: MDBX_option = 9;
#[doc = " \\brief Controls the in-process how minimal part of the dirty pages should\n be spilled when necessary.\n\n \\details The `MDBX_opt_spill_min_denominator` defines the denominator for\n limiting from the bottom for part of the current dirty pages should be\n spilled when the free room for a new dirty pages (i.e. distance to the\n `MDBX_opt_txn_dp_limit` threshold) is not enough to perform requested\n operation.\n Exactly `min_pages_to_spill = dirty_pages / N`,\n where `N` is the value set by `MDBX_opt_spill_min_denominator`.\n\n Should be in the range 0..255, where zero means no restriction at the\n bottom. Default is 8, i.e. at least the 1/8 of the current dirty pages\n should be spilled when reached the condition described above."]
pub const MDBX_option_MDBX_opt_spill_min_denominator: MDBX_option = 10;
#[doc = " \\brief Controls the in-process how much of the parent transaction dirty\n pages will be spilled while start each child transaction.\n\n \\details The `MDBX_opt_spill_parent4child_denominator` defines the\n denominator to determine how much of parent transaction dirty pages will be\n spilled explicitly while start each child transaction.\n Exactly `pages_to_spill = dirty_pages / N`,\n where `N` is the value set by `MDBX_opt_spill_parent4child_denominator`.\n\n For a stack of nested transactions each dirty page could be spilled only\n once, and parent's dirty pages couldn't be spilled while child\n transaction(s) are running. Therefore a child transaction could reach\n \\ref MDBX_TXN_FULL when parent(s) transaction has  spilled too less (and\n child reach the limit of dirty pages), either when parent(s) has spilled\n too more (since child can't spill already spilled pages). So there is no\n universal golden ratio.\n\n Should be in the range 0..255, where zero means no explicit spilling will\n be performed during starting nested transactions.\n Default is 0, i.e. by default no spilling performed during starting nested\n transactions, that correspond historically behaviour."]
pub const MDBX_option_MDBX_opt_spill_parent4child_denominator: MDBX_option = 11;
#[doc = " \\brief Controls the in-process threshold of semi-empty pages merge.\n \\details This option controls the in-process threshold of minimum page\n fill, as used space of percentage of a page. Neighbour pages emptier than\n this value are candidates for merging. The threshold value is specified\n in 1/65536 points of a whole page, which is equivalent to the 16-dot-16\n fixed point format.\n The specified value must be in the range from 12.5% (almost empty page)\n to 50% (half empty page) which corresponds to the range from 8192 and\n to 32768 in units respectively.\n \\see MDBX_opt_prefer_waf_insteadof_balance"]
pub const MDBX_option_MDBX_opt_merge_threshold_16dot16_percent: MDBX_option = 12;
#[doc = " \\brief Controls the choosing between use write-through disk writes and\n usual ones with followed flush by the `fdatasync()` syscall.\n \\details Depending on the operating system, storage subsystem\n characteristics and the use case, higher performance can be achieved by\n either using write-through or a serie of usual/lazy writes followed by\n the flush-to-disk.\n\n Basically for N chunks the latency/cost of write-through is:\n  latency = N * (emit + round-trip-to-storage + storage-execution);\n And for serie of lazy writes with flush is:\n  latency = N * (emit + storage-execution) + flush + round-trip-to-storage.\n\n So, for large N and/or noteable round-trip-to-storage the write+flush\n approach is win. But for small N and/or near-zero NVMe-like latency\n the write-through is better.\n\n To solve this issue libmdbx provide `MDBX_opt_writethrough_threshold`:\n  - when N described above less or equal specified threshold,\n    a write-through approach will be used;\n  - otherwise, when N great than specified threshold,\n    a write-and-flush approach will be used.\n\n \\note MDBX_opt_writethrough_threshold affects only \\ref MDBX_SYNC_DURABLE\n mode without \\ref MDBX_WRITEMAP, and not supported on Windows.\n On Windows a write-through is used always but \\ref MDBX_NOMETASYNC could\n be used for switching to write-and-flush."]
pub const MDBX_option_MDBX_opt_writethrough_threshold: MDBX_option = 13;
#[doc = " \\brief Controls prevention of page-faults of reclaimed and allocated pages\n in the \\ref MDBX_WRITEMAP mode by clearing ones through file handle before\n touching."]
pub const MDBX_option_MDBX_opt_prefault_write_enable: MDBX_option = 14;
#[doc = " \\brief Controls the in-process spending time limit of searching\n  consecutive pages inside GC.\n \\see MDBX_opt_rp_augment_limit\n\n \\details Задаёт ограничение времени в 1/65536 долях секунды, которое может\n быть потрачено в ходе пишущей транзакции на поиск последовательностей\n страниц внутри GC/freelist после достижения ограничения задаваемого опцией\n \\ref MDBX_opt_rp_augment_limit. Контроль по времени не выполняется при\n поиске/выделении одиночных страниц и выделении страниц под нужды GC (при\n обновлении GC в ходе фиксации транзакции).\n\n Задаваемый лимит времени исчисляется по \"настенным часам\" и контролируется\n в рамках транзакции, наследуется для вложенных транзакций и с\n аккумулированием в родительской при их фиксации. Контроль по времени\n производится только при достижении ограничения задаваемого опцией \\ref\n MDBX_opt_rp_augment_limit. Это позволяет гибко управлять поведением\n используя обе опции.\n\n По умолчанию ограничение устанавливается в 0, что приводит к\n незамедлительной остановке поиска в GC при достижении \\ref\n MDBX_opt_rp_augment_limit во внутреннем состоянии транзакции и\n соответствует поведению до появления опции `MDBX_opt_gc_time_limit`.\n С другой стороны, при минимальном значении (включая 0)\n `MDBX_opt_rp_augment_limit` переработка GC будет ограничиваться\n преимущественно затраченным временем."]
pub const MDBX_option_MDBX_opt_gc_time_limit: MDBX_option = 15;
#[doc = " \\brief Управляет выбором между стремлением к равномерности наполнения\n страниц, либо уменьшением количества измененных и записанных страниц.\n\n \\details После операций удаления страницы содержащие меньше минимума\n ключей, либо опустошенные до \\ref MDBX_opt_merge_threshold_16dot16_percent\n подлежат слиянию с одной из соседних. Если страницы справа и слева от\n текущей обе «грязные» (были изменены в ходе транзакции и должны быть\n записаны на диск), либо обе «чисты» (не изменялись в текущей транзакции),\n то целью для слияния всегда выбирается менее заполненная страница.\n Когда же только одна из соседствующих является «грязной», а другая\n «чистой», то возможны две тактики выбора цели для слияния:\n\n  - Если `MDBX_opt_prefer_waf_insteadof_balance = True`, то будет выбрана\n    уже измененная страница, что НЕ УВЕЛИЧИТ количество измененных страниц\n    и объем записи на диск при фиксации текущей транзакции, но в среднем\n    будет УВЕЛИЧИВАТЬ неравномерность заполнения страниц.\n\n  - Если `MDBX_opt_prefer_waf_insteadof_balance = False`, то будет выбрана\n    менее заполненная страница, что УВЕЛИЧИТ количество измененных страниц\n    и объем записи на диск при фиксации текущей транзакции, но в среднем\n    будет УМЕНЬШАТЬ неравномерность заполнения страниц.\n\n \\see MDBX_opt_merge_threshold_16dot16_percent"]
pub const MDBX_option_MDBX_opt_prefer_waf_insteadof_balance: MDBX_option = 16;
#[doc = " \\brief Задаёт в % максимальный размер вложенных страниц, используемых для\n размещения небольшого количества мульти-значений связанных с одном ключем.\n\n Использование вложенных страниц, вместо выноса значений на отдельные\n страницы вложенного дерева, позволяет уменьшить объем неиспользуемого места\n и этим увеличить плотность размещения данных.\n\n Но с увеличением размера вложенных страниц требуется больше листовых\n страниц основного дерева, что также увеличивает высоту основного дерева.\n Кроме этого, изменение данных на вложенных страницах требует дополнительных\n копирований, поэтому стоимость может быть больше во многих сценариях.\n\n min 12.5% (8192), max 100% (65535), default = 100%"]
pub const MDBX_option_MDBX_opt_subpage_limit: MDBX_option = 17;
#[doc = " \\brief Задаёт в % минимальный объём свободного места на основной странице,\n при отсутствии которого вложенные страницы выносятся в отдельное дерево.\n\n min 0, max 100% (65535), default = 0"]
pub const MDBX_option_MDBX_opt_subpage_room_threshold: MDBX_option = 18;
#[doc = " \\brief Задаёт в % минимальный объём свободного места на основной странице,\n при наличии которого, производится резервирование места во вложенной.\n\n Если на основной странице свободного места недостаточно, то вложенная\n страница будет минимального размера. В свою очередь, при отсутствии резерва\n во вложенной странице, каждое добавлении в неё элементов будет требовать\n переформирования основной страниц с переносом всех узлов данных.\n\n Поэтому резервирование места, как правило, выгодно в сценариях с\n интенсивным добавлением коротких мульти-значений, например при\n индексировании. Но уменьшает плотность размещения данных, соответственно\n увеличивает объем БД и операций ввода-вывода.\n\n min 0, max 100% (65535), default = 42% (27525)"]
pub const MDBX_option_MDBX_opt_subpage_reserve_prereq: MDBX_option = 19;
#[doc = " \\brief Задаёт в % ограничение резервирования места на вложенных страницах.\n\n min 0, max 100% (65535), default = 4.2% (2753)"]
pub const MDBX_option_MDBX_opt_subpage_reserve_limit: MDBX_option = 20;
#[doc = " \\brief MDBX environment extra runtime options.\n \\ingroup c_settings\n \\see mdbx_env_set_option() \\see mdbx_env_get_option()"]
pub type MDBX_option = ::std::os::raw::c_int;
#[doc = " \\brief MDBX environment extra runtime options.\n \\ingroup c_settings\n \\see mdbx_env_set_option() \\see mdbx_env_get_option()"]
pub use self::MDBX_option as MDBX_option_t;
unsafe extern "C" {
    #[doc = " \\brief Sets the value of a extra runtime options for an environment.\n \\ingroup c_settings\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n \\param [in] option  The option from \\ref MDBX_option_t to set value of it.\n \\param [in] value   The value of option to be set.\n\n \\see MDBX_option_t\n \\see mdbx_env_get_option()\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_option(
        env: *mut MDBX_env,
        option: MDBX_option_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Gets the value of extra runtime options from an environment.\n \\ingroup c_settings\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n \\param [in] option  The option from \\ref MDBX_option_t to get value of it.\n \\param [out] pvalue The address where the option's value will be stored.\n\n \\see MDBX_option_t\n \\see mdbx_env_get_option()\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_get_option(
        env: *const MDBX_env,
        option: MDBX_option_t,
        pvalue: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Open an environment instance.\n \\ingroup c_opening\n\n Indifferently this function will fails or not, the \\ref mdbx_env_close() must\n be called later to discard the \\ref MDBX_env handle and release associated\n resources.\n\n \\note On Windows the \\ref mdbx_env_openW() is recommended to use.\n\n \\param [in] env       An environment handle returned\n                       by \\ref mdbx_env_create()\n\n \\param [in] pathname  The pathname for the database or the directory in which\n                       the database files reside. In the case of directory it\n                       must already exist and be writable.\n\n \\param [in] flags     Specifies options for this environment.\n                       This parameter must be bitwise OR'ing together\n                       any constants described above in the \\ref env_flags\n                       and \\ref sync_modes sections.\n\n Flags set by mdbx_env_set_flags() are also used:\n  - \\ref MDBX_ENV_DEFAULTS, \\ref MDBX_NOSUBDIR, \\ref MDBX_RDONLY,\n    \\ref MDBX_EXCLUSIVE, \\ref MDBX_WRITEMAP, \\ref MDBX_NOSTICKYTHREADS,\n    \\ref MDBX_NORDAHEAD, \\ref MDBX_NOMEMINIT, \\ref MDBX_COALESCE,\n    \\ref MDBX_LIFORECLAIM. See \\ref env_flags section.\n\n  - \\ref MDBX_SYNC_DURABLE, \\ref MDBX_NOMETASYNC, \\ref MDBX_SAFE_NOSYNC,\n    \\ref MDBX_UTTERLY_NOSYNC. See \\ref sync_modes section.\n\n \\note `MDB_NOLOCK` flag don't supported by MDBX,\n       try use \\ref MDBX_EXCLUSIVE as a replacement.\n\n \\note MDBX don't allow to mix processes with different \\ref MDBX_SAFE_NOSYNC\n       flags on the same environment.\n       In such case \\ref MDBX_INCOMPATIBLE will be returned.\n\n If the database is already exist and parameters specified early by\n \\ref mdbx_env_set_geometry() are incompatible (i.e. for instance, different\n page size) then \\ref mdbx_env_open() will return \\ref MDBX_INCOMPATIBLE\n error.\n\n \\param [in] mode   The UNIX permissions to set on created files.\n                    Zero value means to open existing, but do not create.\n\n \\return A non-zero error value on failure and 0 on success,\n         some possible errors are:\n \\retval MDBX_VERSION_MISMATCH The version of the MDBX library doesn't match\n                            the version that created the database environment.\n \\retval MDBX_INVALID       The environment file headers are corrupted.\n \\retval MDBX_ENOENT        The directory specified by the path parameter\n                            doesn't exist.\n \\retval MDBX_EACCES        The user didn't have permission to access\n                            the environment files.\n \\retval MDBX_BUSY          The \\ref MDBX_EXCLUSIVE flag was specified and the\n                            environment is in use by another process,\n                            or the current process tries to open environment\n                            more than once.\n \\retval MDBX_INCOMPATIBLE  Environment is already opened by another process,\n                            but with different set of \\ref MDBX_SAFE_NOSYNC,\n                            \\ref MDBX_UTTERLY_NOSYNC flags.\n                            Or if the database is already exist and parameters\n                            specified early by \\ref mdbx_env_set_geometry()\n                            are incompatible (i.e. different pagesize, etc).\n\n \\retval MDBX_WANNA_RECOVERY The \\ref MDBX_RDONLY flag was specified but\n                             read-write access is required to rollback\n                             inconsistent state after a system crash.\n\n \\retval MDBX_TOO_LARGE      Database is too large for this process,\n                             i.e. 32-bit process tries to open >4Gb database."]
    pub fn mdbx_env_open(
        env: *mut MDBX_env,
        pathname: *const ::std::os::raw::c_char,
        flags: MDBX_env_flags_t,
        mode: mdbx_mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_env_open()\n \\note Available only on Windows.\n \\see mdbx_env_open()"]
    pub fn mdbx_env_openW(
        env: *mut MDBX_env,
        pathname: *const u16,
        flags: MDBX_env_flags_t,
        mode: mdbx_mode_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Just delete the environment's files and directory if any.\n \\note On POSIX systems, processes already working with the database will\n continue to work without interference until it close the environment.\n \\note On Windows, the behavior of `MDBX_ENV_JUST_DELETE` is different\n because the system does not support deleting files that are currently\n memory mapped."]
pub const MDBX_env_delete_mode_MDBX_ENV_JUST_DELETE: MDBX_env_delete_mode = 0;
#[doc = " \\brief Make sure that the environment is not being used by other\n processes, or return an error otherwise."]
pub const MDBX_env_delete_mode_MDBX_ENV_ENSURE_UNUSED: MDBX_env_delete_mode = 1;
#[doc = " \\brief Wait until other processes closes the environment before deletion."]
pub const MDBX_env_delete_mode_MDBX_ENV_WAIT_FOR_UNUSED: MDBX_env_delete_mode = 2;
#[doc = " \\brief Deletion modes for \\ref mdbx_env_delete().\n \\ingroup c_extra\n \\see mdbx_env_delete()"]
pub type MDBX_env_delete_mode = ::std::os::raw::c_int;
#[doc = " \\brief Deletion modes for \\ref mdbx_env_delete().\n \\ingroup c_extra\n \\see mdbx_env_delete()"]
pub use self::MDBX_env_delete_mode as MDBX_env_delete_mode_t;
unsafe extern "C" {
    #[doc = " \\brief Delete the environment's files in a proper and multiprocess-safe way.\n \\ingroup c_extra\n\n \\note On Windows the \\ref mdbx_env_deleteW() is recommended to use.\n\n \\param [in] pathname  The pathname for the database or the directory in which\n                       the database files reside.\n\n \\param [in] mode      Specifies deletion mode for the environment. This\n                       parameter must be set to one of the constants described\n                       above in the \\ref MDBX_env_delete_mode_t section.\n\n \\note The \\ref MDBX_ENV_JUST_DELETE don't supported on Windows since system\n unable to delete a memory-mapped files.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_RESULT_TRUE   No corresponding files or directories were found,\n                            so no deletion was performed."]
    pub fn mdbx_env_delete(
        pathname: *const ::std::os::raw::c_char,
        mode: MDBX_env_delete_mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_env_delete()\n \\ingroup c_extra\n \\note Available only on Windows.\n \\see mdbx_env_delete()"]
    pub fn mdbx_env_deleteW(
        pathname: *const u16,
        mode: MDBX_env_delete_mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Copy an MDBX environment to the specified path, with options.\n \\ingroup c_extra\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n \\note This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under \\ref restrictions section.\n\n \\note On Windows the \\ref mdbx_env_copyW() is recommended to use.\n \\see mdbx_env_copy2fd()\n \\see mdbx_txn_copy2pathname()\n\n \\param [in] env    An environment handle returned by mdbx_env_create().\n                    It must have already been opened successfully.\n \\param [in] dest   The pathname of a file in which the copy will reside.\n                    This file must not be already exist, but parent directory\n                    must be writable.\n \\param [in] flags  Specifies options for this operation. This parameter\n                    must be bitwise OR'ing together any of the constants\n                    described here:\n\n  - \\ref MDBX_CP_DEFAULTS\n      Perform copy as-is without compaction, etc.\n\n  - \\ref MDBX_CP_COMPACT\n      Perform compaction while copying: omit free pages and sequentially\n      renumber all pages in output. This option consumes little bit more\n      CPU for processing, but may running quickly than the default, on\n      account skipping free pages.\n\n  - \\ref MDBX_CP_FORCE_DYNAMIC_SIZE\n      Force to make resizable copy, i.e. dynamic size instead of fixed.\n\n  - \\ref MDBX_CP_DONT_FLUSH\n      Don't explicitly flush the written data to an output media to reduce\n      the time of the operation and the duration of the transaction.\n\n  - \\ref MDBX_CP_THROTTLE_MVCC\n      Use read transaction parking during copying MVCC-snapshot\n      to avoid stopping recycling and overflowing the database.\n      This allows the writing transaction to oust the read\n      transaction used to copy the database if copying takes so long\n      that it will interfere with the recycling old MVCC snapshots\n      and may lead to an overflow of the database.\n      However, if the reading transaction is ousted the copy will\n      be aborted until successful completion. Thus, this option\n      allows copy the database without interfering with write\n      transactions and a threat of database overflow, but at the cost\n      that copying will be aborted to prevent such conditions.\n      \\see mdbx_txn_park()\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_copy(
        env: *mut MDBX_env,
        dest: *const ::std::os::raw::c_char,
        flags: MDBX_copy_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Copy an MDBX environment by given read transaction to the specified\n path, with options.\n \\ingroup c_extra\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n \\note This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under \\ref restrictions section.\n\n \\note On Windows the \\ref mdbx_txn_copy2pathnameW() is recommended to use.\n \\see mdbx_txn_copy2fd()\n \\see mdbx_env_copy()\n\n \\param [in] txn    A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dest   The pathname of a file in which the copy will reside.\n                    This file must not be already exist, but parent directory\n                    must be writable.\n \\param [in] flags  Specifies options for this operation. This parameter\n                    must be bitwise OR'ing together any of the constants\n                    described here:\n\n  - \\ref MDBX_CP_DEFAULTS\n      Perform copy as-is without compaction, etc.\n\n  - \\ref MDBX_CP_COMPACT\n      Perform compaction while copying: omit free pages and sequentially\n      renumber all pages in output. This option consumes little bit more\n      CPU for processing, but may running quickly than the default, on\n      account skipping free pages.\n\n  - \\ref MDBX_CP_FORCE_DYNAMIC_SIZE\n      Force to make resizable copy, i.e. dynamic size instead of fixed.\n\n  - \\ref MDBX_CP_DONT_FLUSH\n      Don't explicitly flush the written data to an output media to reduce\n      the time of the operation and the duration of the transaction.\n\n  - \\ref MDBX_CP_THROTTLE_MVCC\n      Use read transaction parking during copying MVCC-snapshot\n      to avoid stopping recycling and overflowing the database.\n      This allows the writing transaction to oust the read\n      transaction used to copy the database if copying takes so long\n      that it will interfere with the recycling old MVCC snapshots\n      and may lead to an overflow of the database.\n      However, if the reading transaction is ousted the copy will\n      be aborted until successful completion. Thus, this option\n      allows copy the database without interfering with write\n      transactions and a threat of database overflow, but at the cost\n      that copying will be aborted to prevent such conditions.\n      \\see mdbx_txn_park()\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_copy2pathname(
        txn: *mut MDBX_txn,
        dest: *const ::std::os::raw::c_char,
        flags: MDBX_copy_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_env_copy()\n \\ingroup c_extra\n \\note Available only on Windows.\n \\see mdbx_env_copy()"]
    pub fn mdbx_env_copyW(
        env: *mut MDBX_env,
        dest: *const u16,
        flags: MDBX_copy_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_txn_copy2pathname()\n \\ingroup c_extra\n \\note Available only on Windows.\n \\see mdbx_txn_copy2pathname()"]
    pub fn mdbx_txn_copy2pathnameW(
        txn: *mut MDBX_txn,
        dest: *const u16,
        flags: MDBX_copy_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Copy an environment to the specified file descriptor, with\n options.\n \\ingroup c_extra\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n \\see mdbx_env_copy()\n \\see mdbx_txn_copy2fd()\n\n \\note This call can trigger significant file size growth if run in\n       parallel with write transactions, because it employs a read-only\n       transaction. See long-lived transactions under \\ref restrictions\n       section.\n\n \\note Fails if the environment has suffered a page leak and the destination\n       file descriptor is associated with a pipe, socket, or FIFO.\n\n \\param [in] env     An environment handle returned by mdbx_env_create().\n                     It must have already been opened successfully.\n \\param [in] fd      The file descriptor to write the copy to. It must have\n                     already been opened for Write access.\n \\param [in] flags   Special options for this operation. \\see mdbx_env_copy()\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_copy2fd(
        env: *mut MDBX_env,
        fd: mdbx_filehandle_t,
        flags: MDBX_copy_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Copy an environment by given read transaction to the specified file\n descriptor, with options.\n \\ingroup c_extra\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n \\see mdbx_txn_copy2pathname()\n \\see mdbx_env_copy2fd()\n\n \\note This call can trigger significant file size growth if run in\n       parallel with write transactions, because it employs a read-only\n       transaction. See long-lived transactions under \\ref restrictions\n       section.\n\n \\note Fails if the environment has suffered a page leak and the destination\n       file descriptor is associated with a pipe, socket, or FIFO.\n\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] fd      The file descriptor to write the copy to. It must have\n                     already been opened for Write access.\n \\param [in] flags   Special options for this operation. \\see mdbx_env_copy()\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_copy2fd(
        txn: *mut MDBX_txn,
        fd: mdbx_filehandle_t,
        flags: MDBX_copy_flags_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Statistics for a table in the environment\n \\ingroup c_statinfo\n \\see mdbx_env_stat_ex() \\see mdbx_dbi_stat()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_stat {
    #[doc = "< Size of a table page. This is the same for all tables\nin a database."]
    pub ms_psize: u32,
    #[doc = "< Depth (height) of the B-tree"]
    pub ms_depth: u32,
    #[doc = "< Number of internal (non-leaf) pages"]
    pub ms_branch_pages: u64,
    #[doc = "< Number of leaf pages"]
    pub ms_leaf_pages: u64,
    #[doc = "< Number of large/overflow pages"]
    pub ms_overflow_pages: u64,
    #[doc = "< Number of data items"]
    pub ms_entries: u64,
    #[doc = "< Transaction ID of committed last modification"]
    pub ms_mod_txnid: u64,
}
unsafe extern "C" {
    #[doc = " \\brief Return statistics about the MDBX environment.\n \\ingroup c_statinfo\n\n At least one of `env` or `txn` argument must be non-null. If txn is passed\n non-null then stat will be filled accordingly to the given transaction.\n Otherwise, if txn is null, then stat will be populated by a snapshot from\n the last committed write transaction, and at next time, other information\n can be returned.\n\n Legacy mdbx_env_stat() correspond to calling \\ref mdbx_env_stat_ex() with the\n null `txn` argument.\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create()\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()\n \\param [out] stat   The address of an \\ref MDBX_stat structure where\n                     the statistics will be copied\n \\param [in] bytes   The size of \\ref MDBX_stat.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_stat_ex(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        stat: *mut MDBX_stat,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Information about the environment\n \\ingroup c_statinfo\n \\see mdbx_env_info_ex()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_envinfo {
    pub mi_geo: MDBX_envinfo__bindgen_ty_1,
    #[doc = "< Size of the data memory map"]
    pub mi_mapsize: u64,
    #[doc = "< Number of the last used page"]
    pub mi_last_pgno: u64,
    #[doc = "< ID of the last committed transaction"]
    pub mi_recent_txnid: u64,
    #[doc = "< ID of the last reader transaction"]
    pub mi_latter_reader_txnid: u64,
    #[doc = "< ID of the last reader transaction\nof caller process"]
    pub mi_self_latter_reader_txnid: u64,
    pub mi_meta_txnid: [u64; 3usize],
    pub mi_meta_sign: [u64; 3usize],
    #[doc = "< Total reader slots in the environment"]
    pub mi_maxreaders: u32,
    #[doc = "< Max reader slots used in the environment"]
    pub mi_numreaders: u32,
    #[doc = "< Database pagesize"]
    pub mi_dxb_pagesize: u32,
    #[doc = "< System pagesize"]
    pub mi_sys_pagesize: u32,
    pub mi_bootid: MDBX_envinfo__bindgen_ty_2,
    #[doc = " Bytes not explicitly synchronized to disk"]
    pub mi_unsync_volume: u64,
    #[doc = " Current auto-sync threshold, see \\ref mdbx_env_set_syncbytes()."]
    pub mi_autosync_threshold: u64,
    #[doc = " Time since entering to a \"dirty\" out-of-sync state in units of 1/65536 of\n second. In other words, this is the time since the last non-steady commit\n or zero if it was steady."]
    pub mi_since_sync_seconds16dot16: u32,
    #[doc = " Current auto-sync period in 1/65536 of second,\n see \\ref mdbx_env_set_syncperiod()."]
    pub mi_autosync_period_seconds16dot16: u32,
    #[doc = " Time since the last readers check in 1/65536 of second,\n see \\ref mdbx_reader_check()."]
    pub mi_since_reader_check_seconds16dot16: u32,
    #[doc = " Current environment mode.\n The same as \\ref mdbx_env_get_flags() returns."]
    pub mi_mode: u32,
    pub mi_pgop_stat: MDBX_envinfo__bindgen_ty_3,
    pub mi_dxbid: MDBX_envinfo__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_1 {
    #[doc = "< Lower limit for datafile size"]
    pub lower: u64,
    #[doc = "< Upper limit for datafile size"]
    pub upper: u64,
    #[doc = "< Current datafile size"]
    pub current: u64,
    #[doc = "< Shrink threshold for datafile"]
    pub shrink: u64,
    #[doc = "< Growth step for datafile"]
    pub grow: u64,
}
#[doc = " \\brief A mostly unique ID that is regenerated on each boot.\n\nAs such it can be used to identify the local machine's current boot. MDBX\nuses such when open the database to determine whether rollback required to\nthe last steady sync point or not. I.e. if current bootid is differ from the\nvalue within a database then the system was rebooted and all changes since\nlast steady sync must be reverted for data integrity. Zeros mean that no\nrelevant information is available from the system."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_2 {
    pub current: MDBX_envinfo__bindgen_ty_2__bindgen_ty_1,
    pub meta: [MDBX_envinfo__bindgen_ty_2__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_2__bindgen_ty_1 {
    pub x: u64,
    pub y: u64,
}
#[doc = " Statistics of page operations.\n \\details Overall statistics of page operations of all (running, completed\n and aborted) transactions in the current multi-process session (since the\n first process opened the database after everyone had previously closed it)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_3 {
    #[doc = "< Quantity of a new pages added"]
    pub newly: u64,
    #[doc = "< Quantity of pages copied for update"]
    pub cow: u64,
    #[doc = "< Quantity of parent's dirty pages clones\nfor nested transactions"]
    pub clone: u64,
    #[doc = "< Page splits"]
    pub split: u64,
    #[doc = "< Page merges"]
    pub merge: u64,
    #[doc = "< Quantity of spilled dirty pages"]
    pub spill: u64,
    #[doc = "< Quantity of unspilled/reloaded pages"]
    pub unspill: u64,
    #[doc = "< Number of explicit write operations (not a pages)\nto a disk"]
    pub wops: u64,
    #[doc = "< Number of prefault write operations (not a pages)"]
    pub prefault: u64,
    #[doc = "< Number of mincore() calls"]
    pub mincore: u64,
    #[doc = "< Number of explicit msync-to-disk operations (not a pages)"]
    pub msync: u64,
    #[doc = "< Number of explicit fsync-to-disk operations (not a pages)"]
    pub fsync: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_4 {
    pub x: u64,
    pub y: u64,
}
unsafe extern "C" {
    #[doc = " \\brief Return information about the MDBX environment.\n \\ingroup c_statinfo\n\n At least one of `env` or `txn` argument must be non-null. If txn is passed\n non-null then stat will be filled accordingly to the given transaction.\n Otherwise, if txn is null, then stat will be populated by a snapshot from\n the last committed write transaction, and at next time, other information\n can be returned.\n\n Legacy \\ref mdbx_env_info() correspond to calling \\ref mdbx_env_info_ex()\n with the null `txn` argument.\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create()\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()\n \\param [out] info   The address of an \\ref MDBX_envinfo structure\n                     where the information will be copied\n \\param [in] bytes   The actual size of \\ref MDBX_envinfo,\n                     this value is used to provide ABI compatibility.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_info_ex(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        info: *mut MDBX_envinfo,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Flush the environment data buffers to disk.\n \\ingroup c_extra\n\n Unless the environment was opened with no-sync flags (\\ref MDBX_NOMETASYNC,\n \\ref MDBX_SAFE_NOSYNC and \\ref MDBX_UTTERLY_NOSYNC), then\n data is always written an flushed to disk when \\ref mdbx_txn_commit() is\n called. Otherwise \\ref mdbx_env_sync() may be called to manually write and\n flush unsynced data to disk.\n\n Besides, \\ref mdbx_env_sync_ex() with argument `force=false` may be used to\n provide polling mode for lazy/asynchronous sync in conjunction with\n \\ref mdbx_env_set_syncbytes() and/or \\ref mdbx_env_set_syncperiod().\n\n \\note This call is not valid if the environment was opened with MDBX_RDONLY.\n\n \\param [in] env      An environment handle returned by \\ref mdbx_env_create()\n \\param [in] force    If non-zero, force a flush. Otherwise, If force is\n                      zero, then will run in polling mode,\n                      i.e. it will check the thresholds that were\n                      set \\ref mdbx_env_set_syncbytes()\n                      and/or \\ref mdbx_env_set_syncperiod() and perform flush\n                      if at least one of the thresholds is reached.\n\n \\param [in] nonblock Don't wait if write transaction\n                      is running by other thread.\n\n \\returns A non-zero error value on failure and \\ref MDBX_RESULT_TRUE or 0 on\n     success. The \\ref MDBX_RESULT_TRUE means no data pending for flush\n     to disk, and 0 otherwise. Some possible errors are:\n\n \\retval MDBX_EACCES   The environment is read-only.\n \\retval MDBX_BUSY     The environment is used by other thread\n                       and `nonblock=true`.\n \\retval MDBX_EINVAL   An invalid parameter was specified.\n \\retval MDBX_EIO      An error occurred during the flushing/writing data\n                       to a storage medium/disk."]
    pub fn mdbx_env_sync_ex(
        env: *mut MDBX_env,
        force: bool,
        nonblock: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Close the environment and release the memory map.\n \\ingroup c_opening\n\n Only a single thread may call this function. All transactions, tables,\n and cursors must already be closed before calling this function. Attempts\n to use any such handles after calling this function is UB and would cause\n a `SIGSEGV`. The environment handle will be freed and must not be used again\n after this call.\n\n \\param [in] env        An environment handle returned by\n                        \\ref mdbx_env_create().\n\n \\param [in] dont_sync  A dont'sync flag, if non-zero the last checkpoint\n                        will be kept \"as is\" and may be still \"weak\" in the\n                        \\ref MDBX_SAFE_NOSYNC or \\ref MDBX_UTTERLY_NOSYNC\n                        modes. Such \"weak\" checkpoint will be ignored on\n                        opening next time, and transactions since the last\n                        non-weak checkpoint (meta-page update) will rolledback\n                        for consistency guarantee.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_BUSY   The write transaction is running by other thread,\n                     in such case \\ref MDBX_env instance has NOT be destroyed\n                     not released!\n                     \\note If any OTHER error code was returned then\n                     given MDBX_env instance has been destroyed and released.\n\n \\retval MDBX_EBADSIGN  Environment handle already closed or not valid,\n                        i.e. \\ref mdbx_env_close() was already called for the\n                        `env` or was not created by \\ref mdbx_env_create().\n\n \\retval MDBX_PANIC  If \\ref mdbx_env_close_ex() was called in the child\n                     process after `fork()`. In this case \\ref MDBX_PANIC\n                     is expected, i.e. \\ref MDBX_env instance was freed in\n                     proper manner.\n\n \\retval MDBX_EIO    An error occurred during the flushing/writing data\n                     to a storage medium/disk."]
    pub fn mdbx_env_close_ex(env: *mut MDBX_env, dont_sync: bool) -> ::std::os::raw::c_int;
}
#[doc = " By default \\ref mdbx_env_warmup() just ask OS kernel to asynchronously\n prefetch database pages."]
pub const MDBX_warmup_flags_MDBX_warmup_default: MDBX_warmup_flags = 0;
#[doc = " Peeking all pages of allocated portion of the database\n to force ones to be loaded into memory. However, the pages are just peeks\n sequentially, so unused pages that are in GC will be loaded in the same\n way as those that contain payload."]
pub const MDBX_warmup_flags_MDBX_warmup_force: MDBX_warmup_flags = 1;
#[doc = " Using system calls to peeks pages instead of directly accessing ones,\n which at the cost of additional overhead avoids killing the current\n process by OOM-killer in a lack of memory condition.\n \\note Has effect only on POSIX (non-Windows) systems with conjunction\n to \\ref MDBX_warmup_force option."]
pub const MDBX_warmup_flags_MDBX_warmup_oomsafe: MDBX_warmup_flags = 2;
#[doc = " Try to lock database pages in memory by `mlock()` on POSIX-systems\n or `VirtualLock()` on Windows. Please refer to description of these\n functions for reasonability of such locking and the information of\n effects, including the system as a whole.\n\n Such locking in memory requires that the corresponding resource limits\n (e.g. `RLIMIT_RSS`, `RLIMIT_MEMLOCK` or process working set size)\n and the availability of system RAM are sufficiently high.\n\n On successful, all currently allocated pages, both unused in GC and\n containing payload, will be locked in memory until the environment closes,\n or explicitly unblocked by using \\ref MDBX_warmup_release, or the\n database geometry will changed, including its auto-shrinking."]
pub const MDBX_warmup_flags_MDBX_warmup_lock: MDBX_warmup_flags = 4;
#[doc = " Alters corresponding current resource limits to be enough for lock pages\n by \\ref MDBX_warmup_lock. However, this option should be used in simpler\n applications since takes into account only current size of this environment\n disregarding all other factors. For real-world database application you\n will need full-fledged management of resources and their limits with\n respective engineering."]
pub const MDBX_warmup_flags_MDBX_warmup_touchlimit: MDBX_warmup_flags = 8;
#[doc = " Release the lock that was performed before by \\ref MDBX_warmup_lock."]
pub const MDBX_warmup_flags_MDBX_warmup_release: MDBX_warmup_flags = 16;
#[doc = " \\brief Warming up options\n \\ingroup c_settings\n \\anchor warmup_flags\n \\see mdbx_env_warmup()"]
pub type MDBX_warmup_flags = ::std::os::raw::c_int;
#[doc = " \\brief Warming up options\n \\ingroup c_settings\n \\anchor warmup_flags\n \\see mdbx_env_warmup()"]
pub use self::MDBX_warmup_flags as MDBX_warmup_flags_t;
unsafe extern "C" {
    #[doc = " \\brief Warms up the database by loading pages into memory,\n optionally lock ones.\n \\ingroup c_settings\n\n Depending on the specified flags, notifies OS kernel about following access,\n force loads the database pages, including locks ones in memory or releases\n such a lock. However, the function does not analyze the b-tree nor the GC.\n Therefore an unused pages that are in GC handled (i.e. will be loaded) in\n the same way as those that contain payload.\n\n At least one of `env` or `txn` argument must be non-null.\n\n \\param [in] env              An environment handle returned\n                              by \\ref mdbx_env_create().\n \\param [in] txn              A transaction handle returned\n                              by \\ref mdbx_txn_begin().\n \\param [in] flags            The \\ref warmup_flags, bitwise OR'ed together.\n\n \\param [in] timeout_seconds_16dot16  Optional timeout which checking only\n                              during explicitly peeking database pages\n                              for loading ones if the \\ref MDBX_warmup_force\n                              option was specified.\n\n \\returns A non-zero error value on failure and 0 on success.\n Some possible errors are:\n\n \\retval MDBX_ENOSYS        The system does not support requested\n operation(s).\n\n \\retval MDBX_RESULT_TRUE   The specified timeout is reached during load\n                            data into memory."]
    pub fn mdbx_env_warmup(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        flags: MDBX_warmup_flags_t,
        timeout_seconds_16dot16: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Set environment flags.\n \\ingroup c_settings\n\n This may be used to set some flags in addition to those from\n mdbx_env_open(), or to unset these flags.\n \\see mdbx_env_get_flags()\n\n \\note In contrast to LMDB, the MDBX serialize threads via mutex while\n changing the flags. Therefore this function will be blocked while a write\n transaction running by other thread, or \\ref MDBX_BUSY will be returned if\n function called within a write transaction.\n\n \\param [in] env      An environment handle returned\n                      by \\ref mdbx_env_create().\n \\param [in] flags    The \\ref env_flags to change, bitwise OR'ed together.\n \\param [in] onoff    A non-zero value sets the flags, zero clears them.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_env_set_flags(
        env: *mut MDBX_env,
        flags: MDBX_env_flags_t,
        onoff: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Get environment flags.\n \\ingroup c_statinfo\n \\see mdbx_env_set_flags()\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n \\param [out] flags  The address of an integer to store the flags.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_EINVAL An invalid parameter was specified."]
    pub fn mdbx_env_get_flags(
        env: *const MDBX_env,
        flags: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Return the path that was used in mdbx_env_open().\n \\ingroup c_statinfo\n\n \\note On Windows the \\ref mdbx_env_get_pathW() is recommended to use.\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create()\n \\param [out] dest   Address of a string pointer to contain the path.\n                     This is the actual string in the environment, not a\n                     copy. It should not be altered in any way.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_env_get_path(
        env: *const MDBX_env,
        dest: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_env_get_path()\n \\ingroup c_statinfo\n \\note Available only on Windows.\n \\see mdbx_env_get_path()"]
    pub fn mdbx_env_get_pathW(env: *const MDBX_env, dest: *mut *const u16)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Return the file descriptor for the given environment.\n \\ingroup c_statinfo\n\n \\note All MDBX file descriptors have `FD_CLOEXEC` and\n       couldn't be used after exec() and or `fork()`.\n\n \\param [in] env   An environment handle returned by \\ref mdbx_env_create().\n \\param [out] fd   Address of a int to contain the descriptor.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_env_get_fd(
        env: *const MDBX_env,
        fd: *mut mdbx_filehandle_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Set all size-related parameters of environment, including page size\n and the min/max size of the memory map.\n \\ingroup c_settings\n\n In contrast to LMDB, the MDBX provide automatic size management of an\n database according the given parameters, including shrinking and resizing\n on the fly. From user point of view all of these just working. Nevertheless,\n it is reasonable to know some details in order to make optimal decisions\n when choosing parameters.\n\n \\see mdbx_env_info_ex()\n\n Both \\ref mdbx_env_set_geometry() and legacy \\ref mdbx_env_set_mapsize() are\n inapplicable to read-only opened environment.\n\n Both \\ref mdbx_env_set_geometry() and legacy \\ref mdbx_env_set_mapsize()\n could be called either before or after \\ref mdbx_env_open(), either within\n the write transaction running by current thread or not:\n\n  - In case \\ref mdbx_env_set_geometry() or legacy \\ref mdbx_env_set_mapsize()\n    was called BEFORE \\ref mdbx_env_open(), i.e. for closed environment, then\n    the specified parameters will be used for new database creation,\n    or will be applied during opening if database exists and no other process\n    using it.\n\n    If the database is already exist, opened with \\ref MDBX_EXCLUSIVE or not\n    used by any other process, and parameters specified by\n    \\ref mdbx_env_set_geometry() are incompatible (i.e. for instance,\n    different page size) then \\ref mdbx_env_open() will return\n    \\ref MDBX_INCOMPATIBLE error.\n\n    In another way, if database will opened read-only or will used by other\n    process during calling \\ref mdbx_env_open() that specified parameters will\n    silently discarded (open the database with \\ref MDBX_EXCLUSIVE flag\n    to avoid this).\n\n  - In case \\ref mdbx_env_set_geometry() or legacy \\ref mdbx_env_set_mapsize()\n    was called after \\ref mdbx_env_open() WITHIN the write transaction running\n    by current thread, then specified parameters will be applied as a part of\n    write transaction, i.e. will not be completely visible to any others\n    processes until the current write transaction has been committed by the\n    current process. However, if transaction will be aborted, then the\n    database file will be reverted to the previous size not immediately, but\n    when a next transaction will be committed or when the database will be\n    opened next time.\n\n  - In case \\ref mdbx_env_set_geometry() or legacy \\ref mdbx_env_set_mapsize()\n    was called after \\ref mdbx_env_open() but OUTSIDE a write transaction,\n    then MDBX will execute internal pseudo-transaction to apply new parameters\n    (but only if anything has been changed), and changes be visible to any\n    others processes immediately after successful completion of function.\n\n Essentially a concept of \"automatic size management\" is simple and useful:\n  - There are the lower and upper bounds of the database file size;\n  - There is the growth step by which the database file will be increased,\n    in case of lack of space;\n  - There is the threshold for unused space, beyond which the database file\n    will be shrunk;\n  - The size of the memory map is also the maximum size of the database;\n  - MDBX will automatically manage both the size of the database and the size\n    of memory map, according to the given parameters.\n\n So, there some considerations about choosing these parameters:\n  - The lower bound allows you to prevent database shrinking below certain\n    reasonable size to avoid unnecessary resizing costs.\n  - The upper bound allows you to prevent database growth above certain\n    reasonable size. Besides, the upper bound defines the linear address space\n    reservation in each process that opens the database. Therefore changing\n    the upper bound is costly and may be required reopening environment in\n    case of \\ref MDBX_UNABLE_EXTEND_MAPSIZE errors, and so on. Therefore, this\n    value should be chosen reasonable large, to accommodate future growth of\n    the database.\n  - The growth step must be greater than zero to allow the database to grow,\n    but also reasonable not too small, since increasing the size by little\n    steps will result a large overhead.\n  - The shrink threshold must be greater than zero to allow the database\n    to shrink but also reasonable not too small (to avoid extra overhead) and\n    not less than growth step to avoid up-and-down flouncing.\n  - The current size (i.e. `size_now` argument) is an auxiliary parameter for\n    simulation legacy \\ref mdbx_env_set_mapsize() and as workaround Windows\n    issues (see below).\n\n Unfortunately, Windows has is a several issue\n with resizing of memory-mapped file:\n  - Windows unable shrinking a memory-mapped file (i.e memory-mapped section)\n    in any way except unmapping file entirely and then map again. Moreover,\n    it is impossible in any way when a memory-mapped file is used more than\n    one process.\n  - Windows does not provide the usual API to augment a memory-mapped file\n    (i.e. a memory-mapped partition), but only by using \"Native API\"\n    in an undocumented way.\n\n MDBX bypasses all Windows issues, but at a cost:\n  - Ability to resize database on the fly requires an additional lock\n    and release `SlimReadWriteLock` during each read-only transaction.\n  - During resize all in-process threads should be paused and then resumed.\n  - Shrinking of database file is performed only when it used by single\n    process, i.e. when a database closes by the last process or opened\n    by the first.\n  = Therefore, the size_now argument may be useful to set database size\n    by the first process which open a database, and thus avoid expensive\n    remapping further.\n\n For create a new database with particular parameters, including the page\n size, \\ref mdbx_env_set_geometry() should be called after\n \\ref mdbx_env_create() and before \\ref mdbx_env_open(). Once the database is\n created, the page size cannot be changed. If you do not specify all or some\n of the parameters, the corresponding default values will be used. For\n instance, the default for database size is 10485760 bytes.\n\n If the mapsize is increased by another process, MDBX silently and\n transparently adopt these changes at next transaction start. However,\n \\ref mdbx_txn_begin() will return \\ref MDBX_UNABLE_EXTEND_MAPSIZE if new\n mapping size could not be applied for current process (for instance if\n address space is busy).  Therefore, in the case of\n \\ref MDBX_UNABLE_EXTEND_MAPSIZE error you need close and reopen the\n environment to resolve error.\n\n \\note Actual values may be different than your have specified because of\n rounding to specified database page size, the system page size and/or the\n size of the system virtual memory management unit. You can get actual values\n by \\ref mdbx_env_info_ex() or see by using the tool `mdbx_chk` with the `-v`\n option.\n\n Legacy \\ref mdbx_env_set_mapsize() correspond to calling\n \\ref mdbx_env_set_geometry() with the arguments `size_lower`, `size_now`,\n `size_upper` equal to the `size` and `-1` (i.e. default) for all other\n parameters.\n\n \\param [in] env         An environment handle returned\n                         by \\ref mdbx_env_create()\n\n \\param [in] size_lower  The lower bound of database size in bytes.\n                         Zero value means \"minimal acceptable\",\n                         and negative means \"keep current or use default\".\n\n \\param [in] size_now    The size in bytes to setup the database size for\n                         now. Zero value means \"minimal acceptable\", and\n                         negative means \"keep current or use default\". So,\n                         it is recommended always pass -1 in this argument\n                         except some special cases.\n\n \\param [in] size_upper The upper bound of database size in bytes.\n                        Zero value means \"minimal acceptable\",\n                        and negative means \"keep current or use default\".\n                        It is recommended to avoid change upper bound while\n                        database is used by other processes or threaded\n                        (i.e. just pass -1 in this argument except absolutely\n                        necessary). Otherwise you must be ready for\n                        \\ref MDBX_UNABLE_EXTEND_MAPSIZE error(s), unexpected\n                        pauses during remapping and/or system errors like\n                        \"address busy\", and so on. In other words, there\n                        is no way to handle a growth of the upper bound\n                        robustly because there may be a lack of appropriate\n                        system resources (which are extremely volatile in\n                        a multi-process multi-threaded environment).\n\n \\param [in] growth_step  The growth step in bytes, must be greater than\n                          zero to allow the database to grow. Negative value\n                          means \"keep current or use default\".\n\n \\param [in] shrink_threshold  The shrink threshold in bytes, must be greater\n                               than zero to allow the database to shrink and\n                               greater than growth_step to avoid shrinking\n                               right after grow.\n                               Negative value means \"keep current\n                               or use default\". Default is 2*growth_step.\n\n \\param [in] pagesize          The database page size for new database\n                               creation or -1 otherwise. Once the database\n                               is created, the page size cannot be changed.\n                               Must be power of 2 in the range between\n                               \\ref MDBX_MIN_PAGESIZE and\n                               \\ref MDBX_MAX_PAGESIZE. Zero value means\n                               \"minimal acceptable\", and negative means\n                               \"keep current or use default\".\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_EINVAL    An invalid parameter was specified,\n                        or the environment has an active write transaction.\n \\retval MDBX_EPERM     Two specific cases for Windows:\n                        1) Shrinking was disabled before via geometry settings\n                        and now it enabled, but there are reading threads that\n                        don't use the additional `SRWL` (which is required to\n                        avoid Windows issues).\n                        2) Temporary close memory mapped is required to change\n                        geometry, but there read transaction(s) is running\n                        and no corresponding thread(s) could be suspended\n                        since the \\ref MDBX_NOSTICKYTHREADS mode is used.\n \\retval MDBX_EACCESS   The environment opened in read-only.\n \\retval MDBX_MAP_FULL  Specified size smaller than the space already\n                        consumed by the environment.\n \\retval MDBX_TOO_LARGE Specified size is too large, i.e. too many pages for\n                        given size, or a 32-bit process requests too much\n                        bytes for the 32-bit address space."]
    pub fn mdbx_env_set_geometry(
        env: *mut MDBX_env,
        size_lower: isize,
        size_now: isize,
        size_upper: isize,
        growth_step: isize,
        shrink_threshold: isize,
        pagesize: isize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Find out whether to use readahead or not, based on the given database\n size and the amount of available memory.\n \\ingroup c_extra\n\n \\param [in] volume      The expected database size in bytes.\n \\param [in] redundancy  Additional reserve or overload in case of negative\n                         value.\n\n \\returns A \\ref MDBX_RESULT_TRUE or \\ref MDBX_RESULT_FALSE value,\n          otherwise the error code.\n \\retval MDBX_RESULT_TRUE   Readahead is reasonable.\n \\retval MDBX_RESULT_FALSE  Readahead is NOT reasonable,\n                            i.e. \\ref MDBX_NORDAHEAD is useful to\n                            open environment by \\ref mdbx_env_open().\n \\retval Otherwise the error code."]
    pub fn mdbx_is_readahead_reasonable(volume: usize, redundancy: isize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns minimal database size in bytes for given page size,\n or -1 if pagesize is invalid.\n \\ingroup c_statinfo"]
    pub fn mdbx_limits_dbsize_min(pagesize: isize) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal database size in bytes for given page size,\n or -1 if pagesize is invalid.\n \\ingroup c_statinfo"]
    pub fn mdbx_limits_dbsize_max(pagesize: isize) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal key size in bytes for given page size\n and table flags, or -1 if pagesize is invalid.\n \\ingroup c_statinfo\n \\see db_flags"]
    pub fn mdbx_limits_keysize_max(pagesize: isize, flags: MDBX_db_flags_t) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns minimal key size in bytes for given table flags.\n \\ingroup c_statinfo\n \\see db_flags"]
    pub fn mdbx_limits_keysize_min(flags: MDBX_db_flags_t) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal data size in bytes for given page size\n and table flags, or -1 if pagesize is invalid.\n \\ingroup c_statinfo\n \\see db_flags"]
    pub fn mdbx_limits_valsize_max(pagesize: isize, flags: MDBX_db_flags_t) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns minimal data size in bytes for given table flags.\n \\ingroup c_statinfo\n \\see db_flags"]
    pub fn mdbx_limits_valsize_min(flags: MDBX_db_flags_t) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal size of key-value pair to fit in a single page with\n the given size and table flags, or -1 if pagesize is invalid.\n \\ingroup c_statinfo\n \\see db_flags"]
    pub fn mdbx_limits_pairsize4page_max(pagesize: isize, flags: MDBX_db_flags_t) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal data size in bytes to fit in a leaf-page or\n single large/overflow-page with the given page size and table flags,\n or -1 if pagesize is invalid.\n \\ingroup c_statinfo\n \\see db_flags"]
    pub fn mdbx_limits_valsize4page_max(pagesize: isize, flags: MDBX_db_flags_t) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal write transaction size (i.e. limit for summary volume\n of dirty pages) in bytes for given page size, or -1 if pagesize is invalid.\n \\ingroup c_statinfo"]
    pub fn mdbx_limits_txnsize_max(pagesize: isize) -> isize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the default size of database page for the current system.\n \\ingroup c_statinfo\n \\details Default size of database page depends on the size of the system\n page and usually exactly match it."]
    pub fn mdbx_default_pagesize() -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief Returns basic information about system RAM.\n This function provides a portable way to get information about available RAM\n and can be useful in that it returns the same information that libmdbx uses\n internally to adjust various options and control readahead.\n \\ingroup c_statinfo\n\n \\param [out] page_size     Optional address where the system page size\n                            will be stored.\n \\param [out] total_pages   Optional address where the number of total RAM\n                            pages will be stored.\n \\param [out] avail_pages   Optional address where the number of\n                            available/free RAM pages will be stored.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_get_sysraminfo(
        page_size: *mut isize,
        total_pages: *mut isize,
        avail_pages: *mut isize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the maximum size of keys can put.\n \\ingroup c_statinfo\n\n \\param [in] env    An environment handle returned by \\ref mdbx_env_create().\n \\param [in] flags  Table options (\\ref MDBX_DUPSORT, \\ref MDBX_INTEGERKEY\n                    and so on). \\see db_flags\n\n \\returns The maximum size of a key can write,\n          or -1 if something is wrong."]
    pub fn mdbx_env_get_maxkeysize_ex(
        env: *const MDBX_env,
        flags: MDBX_db_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the maximum size of data we can put.\n \\ingroup c_statinfo\n\n \\param [in] env    An environment handle returned by \\ref mdbx_env_create().\n \\param [in] flags  Table options (\\ref MDBX_DUPSORT, \\ref MDBX_INTEGERKEY\n                    and so on). \\see db_flags\n\n \\returns The maximum size of a data can write,\n          or -1 if something is wrong."]
    pub fn mdbx_env_get_maxvalsize_ex(
        env: *const MDBX_env,
        flags: MDBX_db_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\deprecated Please use \\ref mdbx_env_get_maxkeysize_ex()\n              and/or \\ref mdbx_env_get_maxvalsize_ex()\n \\ingroup c_statinfo"]
    pub fn mdbx_env_get_maxkeysize(env: *const MDBX_env) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal size of key-value pair to fit in a single page\n for specified table flags.\n \\ingroup c_statinfo\n\n \\param [in] env    An environment handle returned by \\ref mdbx_env_create().\n \\param [in] flags  Table options (\\ref MDBX_DUPSORT, \\ref MDBX_INTEGERKEY\n                    and so on). \\see db_flags\n\n \\returns The maximum size of a data can write,\n          or -1 if something is wrong."]
    pub fn mdbx_env_get_pairsize4page_max(
        env: *const MDBX_env,
        flags: MDBX_db_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns maximal data size in bytes to fit in a leaf-page or\n single large/overflow-page for specified table flags.\n \\ingroup c_statinfo\n\n \\param [in] env    An environment handle returned by \\ref mdbx_env_create().\n \\param [in] flags  Table options (\\ref MDBX_DUPSORT, \\ref MDBX_INTEGERKEY\n                    and so on). \\see db_flags\n\n \\returns The maximum size of a data can write,\n          or -1 if something is wrong."]
    pub fn mdbx_env_get_valsize4page_max(
        env: *const MDBX_env,
        flags: MDBX_db_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Sets application information (a context pointer) associated with\n the environment.\n \\see mdbx_env_get_userctx()\n \\ingroup c_settings\n\n \\param [in] env  An environment handle returned by \\ref mdbx_env_create().\n \\param [in] ctx  An arbitrary pointer for whatever the application needs.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_userctx(
        env: *mut MDBX_env,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns an application information (a context pointer) associated\n with the environment.\n \\see mdbx_env_set_userctx()\n \\ingroup c_statinfo\n\n \\param [in] env An environment handle returned by \\ref mdbx_env_create()\n \\returns The pointer set by \\ref mdbx_env_set_userctx()\n          or `NULL` if something wrong."]
    pub fn mdbx_env_get_userctx(env: *const MDBX_env) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " \\brief Create a transaction with a user provided context pointer\n for use with the environment.\n \\ingroup c_transactions\n\n The transaction handle may be discarded using \\ref mdbx_txn_abort()\n or \\ref mdbx_txn_commit().\n \\see mdbx_txn_begin()\n\n \\note A transaction and its cursors must only be used by a single thread,\n and a thread may only have a single transaction at a time unless\n the \\ref MDBX_NOSTICKYTHREADS is used.\n\n \\note Cursors may not span transactions.\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n\n \\param [in] parent  If this parameter is non-NULL, the new transaction will\n                     be a nested transaction, with the transaction indicated\n                     by parent as its parent. Transactions may be nested\n                     to any level. A parent transaction and its cursors may\n                     not issue any other operations than mdbx_txn_commit and\n                     \\ref mdbx_txn_abort() while it has active child\n                     transactions.\n\n \\param [in] flags   Special options for this transaction. This parameter\n                     must be set to 0 or by bitwise OR'ing together one\n                     or more of the values described here:\n                      - \\ref MDBX_RDONLY   This transaction will not perform\n                                           any write operations.\n\n                      - \\ref MDBX_TXN_TRY  Do not block when starting\n                                           a write transaction.\n\n                      - \\ref MDBX_SAFE_NOSYNC, \\ref MDBX_NOMETASYNC.\n                        Do not sync data to disk corresponding\n                        to \\ref MDBX_NOMETASYNC or \\ref MDBX_SAFE_NOSYNC\n                        description. \\see sync_modes\n\n \\param [out] txn    Address where the new \\ref MDBX_txn handle\n                     will be stored.\n\n \\param [in] context A pointer to application context to be associated with\n                     created transaction and could be retrieved by\n                     \\ref mdbx_txn_get_userctx() until transaction finished.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_PANIC         A fatal error occurred earlier and the\n                            environment must be shut down.\n \\retval MDBX_UNABLE_EXTEND_MAPSIZE  Another process wrote data beyond\n                                     this MDBX_env's mapsize and this\n                                     environment map must be resized as well.\n                                     See \\ref mdbx_env_set_mapsize().\n \\retval MDBX_READERS_FULL  A read-only transaction was requested and\n                            the reader lock table is full.\n                            See \\ref mdbx_env_set_maxreaders().\n \\retval MDBX_ENOMEM        Out of memory.\n \\retval MDBX_BUSY          The write transaction is already started by the\n                            current thread."]
    pub fn mdbx_txn_begin_ex(
        env: *mut MDBX_env,
        parent: *mut MDBX_txn,
        flags: MDBX_txn_flags_t,
        txn: *mut *mut MDBX_txn,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Sets application information associated (a context pointer) with the\n transaction.\n \\ingroup c_transactions\n \\see mdbx_txn_get_userctx()\n\n \\param [in] txn  An transaction handle returned by \\ref mdbx_txn_begin_ex()\n                  or \\ref mdbx_txn_begin().\n \\param [in] ctx  An arbitrary pointer for whatever the application needs.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_set_userctx(
        txn: *mut MDBX_txn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns an application information (a context pointer) associated\n with the transaction.\n \\ingroup c_transactions\n \\see mdbx_txn_set_userctx()\n\n \\param [in] txn  An transaction handle returned by \\ref mdbx_txn_begin_ex()\n                  or \\ref mdbx_txn_begin().\n \\returns The pointer which was passed via the `context` parameter\n          of `mdbx_txn_begin_ex()` or set by \\ref mdbx_txn_set_userctx(),\n          or `NULL` if something wrong."]
    pub fn mdbx_txn_get_userctx(txn: *const MDBX_txn) -> *mut ::std::os::raw::c_void;
}
#[doc = " \\brief Information about the transaction\n \\ingroup c_statinfo\n \\see mdbx_txn_info"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_txn_info {
    #[doc = " The ID of the transaction. For a READ-ONLY transaction, this corresponds\nto the snapshot being read."]
    pub txn_id: u64,
    #[doc = " For READ-ONLY transaction: the lag from a recent MVCC-snapshot, i.e. the\nnumber of committed transaction since read transaction started.\nFor WRITE transaction (provided if `scan_rlt=true`): the lag of the oldest\nreader from current transaction (i.e. at least 1 if any reader running)."]
    pub txn_reader_lag: u64,
    #[doc = " Used space by this transaction, i.e. corresponding to the last used\n database page."]
    pub txn_space_used: u64,
    #[doc = " Current size of database file."]
    pub txn_space_limit_soft: u64,
    #[doc = " Upper bound for size the database file, i.e. the value `size_upper`\nargument of the appropriate call of \\ref mdbx_env_set_geometry()."]
    pub txn_space_limit_hard: u64,
    #[doc = " For READ-ONLY transaction: The total size of the database pages that were\nretired by committed write transactions after the reader's MVCC-snapshot,\ni.e. the space which would be freed after the Reader releases the\nMVCC-snapshot for reuse by completion read transaction.\nFor WRITE transaction: The summarized size of the database pages that were\nretired for now due Copy-On-Write during this transaction."]
    pub txn_space_retired: u64,
    #[doc = " For READ-ONLY transaction: the space available for writer(s) and that\nmust be exhausted for reason to call the Handle-Slow-Readers callback for\nthis read transaction.\nFor WRITE transaction: the space inside transaction\nthat left to `MDBX_TXN_FULL` error."]
    pub txn_space_leftover: u64,
    #[doc = " For READ-ONLY transaction (provided if `scan_rlt=true`): The space that\nactually become available for reuse when only this transaction will be\nfinished.\nFor WRITE transaction: The summarized size of the dirty database\npages that generated during this transaction."]
    pub txn_space_dirty: u64,
}
unsafe extern "C" {
    #[doc = " \\brief Return information about the MDBX transaction.\n \\ingroup c_statinfo\n\n \\param [in] txn        A transaction handle returned by \\ref mdbx_txn_begin()\n \\param [out] info      The address of an \\ref MDBX_txn_info structure\n                        where the information will be copied.\n \\param [in] scan_rlt   The boolean flag controls the scan of the read lock\n                        table to provide complete information. Such scan\n                        is relatively expensive and you can avoid it\n                        if corresponding fields are not needed.\n                        See description of \\ref MDBX_txn_info.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_info(
        txn: *const MDBX_txn,
        info: *mut MDBX_txn_info,
        scan_rlt: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the transaction's MDBX_env.\n \\ingroup c_transactions\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()"]
    pub fn mdbx_txn_env(txn: *const MDBX_txn) -> *mut MDBX_env;
}
unsafe extern "C" {
    #[doc = " \\brief Return the transaction's flags.\n \\ingroup c_transactions\n\n This returns the flags, including internal, associated with this transaction.\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n\n \\returns A transaction flags, valid if input is an valid transaction,\n          otherwise \\ref MDBX_TXN_INVALID."]
    pub fn mdbx_txn_flags(txn: *const MDBX_txn) -> MDBX_txn_flags_t;
}
unsafe extern "C" {
    #[doc = " \\brief Return the transaction's ID.\n \\ingroup c_statinfo\n\n This returns the identifier associated with this transaction. For a\n read-only transaction, this corresponds to the snapshot being read;\n concurrent readers will frequently have the same transaction ID.\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n\n \\returns A transaction ID, valid if input is an active transaction,\n          otherwise 0."]
    pub fn mdbx_txn_id(txn: *const MDBX_txn) -> u64;
}
#[doc = " \\brief Latency of commit stages in 1/65536 of seconds units.\n \\warning This structure may be changed in future releases.\n \\ingroup c_statinfo\n \\see mdbx_txn_commit_ex()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_commit_latency {
    #[doc = " \\brief Duration of preparation (commit child transactions, update\n table's records and cursors destroying)."]
    pub preparation: u32,
    #[doc = " \\brief Duration of GC update by wall clock."]
    pub gc_wallclock: u32,
    #[doc = " \\brief Duration of internal audit if enabled."]
    pub audit: u32,
    #[doc = " \\brief Duration of writing dirty/modified data pages to a filesystem,\n i.e. the summary duration of a `write()` syscalls during commit."]
    pub write: u32,
    #[doc = " \\brief Duration of syncing written data to the disk/storage, i.e.\n the duration of a `fdatasync()` or a `msync()` syscall during commit."]
    pub sync: u32,
    #[doc = " \\brief Duration of transaction ending (releasing resources)."]
    pub ending: u32,
    #[doc = " \\brief The total duration of a commit."]
    pub whole: u32,
    #[doc = " \\brief User-mode CPU time spent on GC update."]
    pub gc_cputime: u32,
    pub gc_prof: MDBX_commit_latency__bindgen_ty_1,
}
#[doc = " \\brief Информация для профилирования работы GC.\n \\note Статистика является общей для всех процессов работающих с одним\n файлом БД и хранится в LCK-файле. Данные аккумулируются при фиксации всех\n транзакций, но только в сборках libmdbx c установленной опцией\n \\ref MDBX_ENABLE_PROFGC. Собранная статистика возвращаются любому процессу\n при использовании \\ref mdbx_txn_commit_ex() и одновременно обнуляется\n при завершении транзакций верхнего уровня (не вложенных)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_commit_latency__bindgen_ty_1 {
    #[doc = " \\brief Количество итераций обновления GC,\n  больше 1 если были повторы/перезапуски."]
    pub wloops: u32,
    #[doc = " \\brief Количество итераций слияния записей GC."]
    pub coalescences: u32,
    #[doc = " \\brief Количество уничтожений предыдущих надежных/устойчивых\n  точек фиксации при работе в режиме \\ref MDBX_UTTERLY_NOSYNC."]
    pub wipes: u32,
    #[doc = " \\brief Количество принудительных фиксаций на диск\n  во избежания приращения БД при работе вне режима\n  \\ref MDBX_UTTERLY_NOSYNC."]
    pub flushes: u32,
    #[doc = " \\brief Количество обращений к механизму Handle-Slow-Readers\n  во избежания приращения БД.\n  \\see MDBX_hsr_func"]
    pub kicks: u32,
    #[doc = " \\brief Счетчик выполнения по медленному пути (slow path execution count)\n  GC ради данных пользователя."]
    pub work_counter: u32,
    #[doc = " \\brief Время \"по настенным часам\" затраченное на чтение и поиск внутри\n  GC ради данных пользователя."]
    pub work_rtime_monotonic: u32,
    #[doc = " \\brief Время ЦПУ в режиме пользователе затраченное\n   на подготовку страниц извлекаемых из GC для данных пользователя,\n   включая подкачку с диска."]
    pub work_xtime_cpu: u32,
    #[doc = " \\brief Количество итераций поиска внутри GC при выделении страниц\n  ради данных пользователя."]
    pub work_rsteps: u32,
    #[doc = " \\brief Количество запросов на выделение последовательностей страниц\n  ради данных пользователя."]
    pub work_xpages: u32,
    #[doc = " \\brief Количество страничных промахов (page faults) внутри GC\n  при выделении и подготовки страниц для данных пользователя."]
    pub work_majflt: u32,
    #[doc = " \\brief Счетчик выполнения по медленному пути (slow path execution count)\n  GC для целей поддержки и обновления самой GC."]
    pub self_counter: u32,
    #[doc = " \\brief Время \"по настенным часам\" затраченное на чтение и поиск внутри\n  GC для целей поддержки и обновления самой GC."]
    pub self_rtime_monotonic: u32,
    #[doc = " \\brief Время ЦПУ в режиме пользователе затраченное на подготовку\n  страниц извлекаемых из GC для целей поддержки и обновления самой GC,\n  включая подкачку с диска."]
    pub self_xtime_cpu: u32,
    #[doc = " \\brief Количество итераций поиска внутри GC при выделении страниц\n  для целей поддержки и обновления самой GC."]
    pub self_rsteps: u32,
    #[doc = " \\brief Количество запросов на выделение последовательностей страниц\n  для самой GC."]
    pub self_xpages: u32,
    #[doc = " \\brief Количество страничных промахов (page faults) внутри GC\n  при выделении и подготовки страниц для самой GC."]
    pub self_majflt: u32,
    pub pnl_merge_work: MDBX_commit_latency__bindgen_ty_1__bindgen_ty_1,
    pub pnl_merge_self: MDBX_commit_latency__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_commit_latency__bindgen_ty_1__bindgen_ty_1 {
    pub time: u32,
    pub volume: u64,
    pub calls: u32,
}
unsafe extern "C" {
    #[doc = " \\brief Commit all the operations of a transaction into the database and\n collect latency information.\n \\see mdbx_txn_commit()\n \\ingroup c_transactions\n \\warning This function may be changed in future releases."]
    pub fn mdbx_txn_commit_ex(
        txn: *mut MDBX_txn,
        latency: *mut MDBX_commit_latency,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Abandon all the operations of the transaction instead of saving them.\n \\ingroup c_transactions\n\n The transaction handle is freed. It and its cursors must not be used again\n after this call, except with \\ref mdbx_cursor_renew() and\n \\ref mdbx_cursor_close().\n\n If the current thread is not eligible to manage the transaction then\n the \\ref MDBX_THREAD_MISMATCH error will returned. Otherwise the transaction\n will be aborted and its handle is freed. Thus, a result other than\n \\ref MDBX_THREAD_MISMATCH means that the transaction is terminated:\n  - Resources are released;\n  - Transaction handle is invalid;\n  - Cursor(s) associated with transaction must not be used, except with\n    \\ref mdbx_cursor_renew() and \\ref mdbx_cursor_close().\n    Such cursor(s) must be closed explicitly by \\ref mdbx_cursor_close()\n    before or after transaction abort, either can be reused with\n    \\ref mdbx_cursor_renew() until it will be explicitly closed by\n    \\ref mdbx_cursor_close().\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_PANIC            A fatal error occurred earlier and\n                               the environment must be shut down.\n \\retval MDBX_BAD_TXN          Transaction is already finished or never began.\n \\retval MDBX_EBADSIGN         Transaction object has invalid signature,\n                               e.g. transaction was already terminated\n                               or memory was corrupted.\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL           Transaction handle is NULL."]
    pub fn mdbx_txn_abort(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Marks transaction as broken to prevent further operations.\n \\ingroup c_transactions\n\n Function keeps the transaction handle and corresponding locks, but makes\n impossible to perform any operations within a broken transaction.\n Broken transaction must then be aborted explicitly later.\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n\n \\see mdbx_txn_abort() \\see mdbx_txn_reset() \\see mdbx_txn_commit()\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_break(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Reset a read-only transaction.\n \\ingroup c_transactions\n\n Abort the read-only transaction like \\ref mdbx_txn_abort(), but keep the\n transaction handle. Therefore \\ref mdbx_txn_renew() may reuse the handle.\n This saves allocation overhead if the process will start a new read-only\n transaction soon, and also locking overhead if \\ref MDBX_NOSTICKYTHREADS is\n in use. The reader table lock is released, but the table slot stays tied to\n its thread or \\ref MDBX_txn. Use \\ref mdbx_txn_abort() to discard a reset\n handle, and to free its lock table slot if \\ref MDBX_NOSTICKYTHREADS\n is in use.\n\n Cursors opened within the transaction must not be used again after this\n call, except with \\ref mdbx_cursor_renew() and \\ref mdbx_cursor_close().\n\n Reader locks generally don't interfere with writers, but they keep old\n versions of database pages allocated. Thus they prevent the old pages from\n being reused when writers commit new data, and so under heavy load the\n database size may grow much more rapidly than otherwise.\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_PANIC            A fatal error occurred earlier and\n                               the environment must be shut down.\n \\retval MDBX_BAD_TXN          Transaction is already finished or never began.\n \\retval MDBX_EBADSIGN         Transaction object has invalid signature,\n                               e.g. transaction was already terminated\n                               or memory was corrupted.\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL           Transaction handle is NULL."]
    pub fn mdbx_txn_reset(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Переводит читающую транзакцию в \"припаркованное\" состояние.\n \\ingroup c_transactions\n\n Выполняющиеся читающие транзакции не позволяют перерабатывать старые\n MVCC-снимки данных, начиная с самой старой используемой/читаемой версии и все\n последующие. Припаркованная же транзакция может быть вытеснена транзакцией\n записи, если будет мешать переработке мусора (старых MVCC-снимков данных).\n А если вытеснения не произойдет, то восстановление (перевод в рабочее\n состояние и продолжение выполнение) читающей транзакции будет существенно\n дешевле. Таким образом, парковка транзакций позволяет предотвратить\n негативные последствия связанные с остановкой переработки мусора,\n одновременно сохранив накладные расходы на минимальном уровне.\n\n Для продолжения выполнения (чтения и/или использования данных) припаркованная\n транзакция должна быть восстановлена посредством \\ref mdbx_txn_unpark().\n Для удобства использования и предотвращения лишних вызовов API, посредством\n параметра `autounpark`, предусмотрена возможность автоматической\n «распарковки» при использовании припаркованной транзакции в функциях API\n предполагающих чтение данных.\n\n \\warning До восстановления/распарковки транзакции, вне зависимости от\n аргумента `autounpark`, нельзя допускать разыменования указателей полученных\n ранее при чтении данных в рамках припаркованной транзакции, так как\n MVCC-снимок в котором размещены эти данные не удерживается и может\n переработан в любой момент.\n\n Припаркованная транзакция без \"распарковки\" может быть прервана, сброшена\n или перезапущена в любой момент посредством \\ref mdbx_txn_abort(),\n \\ref mdbx_txn_reset() и \\ref mdbx_txn_renew(), соответственно.\n\n \\see mdbx_txn_unpark()\n \\see mdbx_txn_flags()\n \\see mdbx_env_set_hsr()\n \\see <a href=\"intro.html#long-lived-read\">Long-lived read transactions</a>\n\n \\param [in] txn          Транзакция чтения запущенная посредством\n                          \\ref mdbx_txn_begin().\n\n \\param [in] autounpark   Позволяет включить автоматическую\n                          распарковку/восстановление транзакции при вызове\n                          функций API предполагающих чтение данных.\n\n \\returns Ненулевое значение кода ошибки, либо 0 при успешном выполнении."]
    pub fn mdbx_txn_park(txn: *mut MDBX_txn, autounpark: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Распарковывает ранее припаркованную читающую транзакцию.\n \\ingroup c_transactions\n\n Функция пытается восстановить ранее припаркованную транзакцию. Если\n припаркованная транзакция была вытеснена ради переработки старых\n MVCC-снимков, то в зависимости от аргумента `restart_if_ousted` выполняется\n её перезапуск аналогично \\ref mdbx_txn_renew(), либо транзакция сбрасывается\n и возвращается код ошибки \\ref MDBX_OUSTED.\n\n \\see mdbx_txn_park()\n \\see mdbx_txn_flags()\n \\see <a href=\"intro.html#long-lived-read\">Long-lived read transactions</a>\n\n \\param [in] txn     Транзакция чтения запущенная посредством\n                     \\ref mdbx_txn_begin() и затем припаркованная\n                     посредством \\ref mdbx_txn_park.\n\n \\param [in] restart_if_ousted   Позволяет сразу выполнить перезапуск\n                                 транзакции, если она была вынестена.\n\n \\returns Ненулевое значение кода ошибки, либо 0 при успешном выполнении.\n Некоторые специфичекие коды результата:\n\n \\retval MDBX_SUCCESS      Припаркованная транзакция успешно восстановлена,\n                           либо она не была припаркована.\n\n \\retval MDBX_OUSTED       Читающая транзакция была вытеснена пишущей\n                           транзакцией ради переработки старых MVCC-снимков,\n                           а аргумент `restart_if_ousted` был задан `false`.\n                           Транзакция сбрасывается в состояние аналогичное\n                           после вызова \\ref mdbx_txn_reset(), но экземпляр\n                           (хендл) не освобождается и может быть использован\n                           повторно посредством \\ref mdbx_txn_renew(), либо\n                           освобожден посредством \\ref mdbx_txn_abort().\n\n \\retval MDBX_RESULT_TRUE  Читающая транзакция была вынеснена, но теперь\n                           перезапущена для чтения другого (последнего)\n                           MVCC-снимка, так как restart_if_ousted` был задан\n                           `true`.\n\n \\retval MDBX_BAD_TXN      Транзакция уже завершена, либо не была запущена."]
    pub fn mdbx_txn_unpark(txn: *mut MDBX_txn, restart_if_ousted: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Renew a read-only transaction.\n \\ingroup c_transactions\n\n This acquires a new reader lock for a transaction handle that had been\n released by \\ref mdbx_txn_reset(). It must be called before a reset\n transaction may be used again.\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_PANIC            A fatal error occurred earlier and\n                               the environment must be shut down.\n \\retval MDBX_BAD_TXN          Transaction is already finished or never began.\n \\retval MDBX_EBADSIGN         Transaction object has invalid signature,\n                               e.g. transaction was already terminated\n                               or memory was corrupted.\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL           Transaction handle is NULL."]
    pub fn mdbx_txn_renew(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
#[doc = " \\brief The fours integers markers (aka \"canary\") associated with the\n environment.\n \\ingroup c_crud\n \\see mdbx_canary_put()\n \\see mdbx_canary_get()\n\n The `x`, `y` and `z` values could be set by \\ref mdbx_canary_put(), while the\n 'v' will be always set to the transaction number. Updated values becomes\n visible outside the current transaction only after it was committed. Current\n values could be retrieved by \\ref mdbx_canary_get()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_canary {
    pub x: u64,
    pub y: u64,
    pub z: u64,
    pub v: u64,
}
unsafe extern "C" {
    #[doc = " \\brief Set integers markers (aka \"canary\") associated with the environment.\n \\ingroup c_crud\n \\see mdbx_canary_get()\n\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()\n \\param [in] canary  A optional pointer to \\ref MDBX_canary structure for `x`,\n              `y` and `z` values from.\n            - If canary is NOT NULL then the `x`, `y` and `z` values will be\n              updated from given canary argument, but the 'v' be always set\n              to the current transaction number if at least one `x`, `y` or\n              `z` values have changed (i.e. if `x`, `y` and `z` have the same\n              values as currently present then nothing will be changes or\n              updated).\n            - if canary is NULL then the `v` value will be explicitly update\n              to the current transaction number without changes `x`, `y` nor\n              `z`.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_canary_put(txn: *mut MDBX_txn, canary: *const MDBX_canary)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns fours integers markers (aka \"canary\") associated with the\n environment.\n \\ingroup c_crud\n \\see mdbx_canary_put()\n\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] canary  The address of an \\ref MDBX_canary structure where the\n                     information will be copied.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_canary_get(txn: *const MDBX_txn, canary: *mut MDBX_canary)
    -> ::std::os::raw::c_int;
}
#[doc = " \\brief A callback function used to compare two keys in a table\n \\ingroup c_crud\n \\see mdbx_cmp() \\see mdbx_get_keycmp()\n \\see mdbx_get_datacmp \\see mdbx_dcmp()\n\n \\anchor avoid_custom_comparators\n \\deprecated It is recommend not using custom comparison functions, but\n instead converting the keys to one of the forms that are suitable for\n built-in comparators (for instance take look to the \\ref value2key).\n The reasons to not using custom comparators are:\n   - The order of records could not be validated without your code.\n     So `mdbx_chk` utility will reports \"wrong order\" errors\n     and the `-i` option is required to suppress ones.\n   - A records could not be ordered or sorted without your code.\n     So `mdbx_load` utility should be used with `-a` option to preserve\n     input data order.\n   - However, the custom comparators feature will never be removed.\n     You have been warned but still can use custom comparators knowing\n     about the issues noted above. In this case you should ignore `deprecated`\n     warnings or define `MDBX_DEPRECATED` macro to empty to avoid ones."]
pub type MDBX_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(a: *const MDBX_val, b: *const MDBX_val) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " \\brief Open or Create a named table in the environment.\n \\ingroup c_dbi\n\n A table handle denotes the name and parameters of a table,\n independently of whether such a table exists. The table handle may be\n discarded by calling \\ref mdbx_dbi_close(). The old table handle is\n returned if the table was already open. The handle may only be closed\n once.\n\n \\note A notable difference between MDBX and LMDB is that MDBX make handles\n opened for existing tables immediately available for other transactions,\n regardless this transaction will be aborted or reset. The REASON for this is\n to avoiding the requirement for multiple opening a same handles in\n concurrent read transactions, and tracking of such open but hidden handles\n until the completion of read transactions which opened them.\n\n Nevertheless, the handle for the NEWLY CREATED table will be invisible\n for other transactions until the this write transaction is successfully\n committed. If the write transaction is aborted the handle will be closed\n automatically. After a successful commit the such handle will reside in the\n shared environment, and may be used by other transactions.\n\n In contrast to LMDB, the MDBX allow this function to be called from multiple\n concurrent transactions or threads in the same process.\n\n To use named table (with name != NULL), \\ref mdbx_env_set_maxdbs()\n must be called before opening the environment. Table names are\n keys in the internal unnamed table, and may be read but not written.\n\n \\param [in] txn    transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] name   The name of the table to open. If only a single\n                    table is needed in the environment,\n                    this value may be NULL.\n \\param [in] flags  Special options for this table. This parameter must\n                    be bitwise OR'ing together any of the constants\n                    described here:\n\n  - \\ref MDBX_DB_DEFAULTS\n      Keys are arbitrary byte strings and compared from beginning to end.\n  - \\ref MDBX_REVERSEKEY\n      Keys are arbitrary byte strings to be compared in reverse order,\n      from the end of the strings to the beginning.\n  - \\ref MDBX_INTEGERKEY\n      Keys are binary integers in native byte order, either uint32_t or\n      uint64_t, and will be sorted as such. The keys must all be of the\n      same size and must be aligned while passing as arguments.\n  - \\ref MDBX_DUPSORT\n      Duplicate keys may be used in the table. Or, from another point of\n      view, keys may have multiple data items, stored in sorted order. By\n      default keys must be unique and may have only a single data item.\n  - \\ref MDBX_DUPFIXED\n      This flag may only be used in combination with \\ref MDBX_DUPSORT. This\n      option tells the library that the data items for this table are\n      all the same size, which allows further optimizations in storage and\n      retrieval. When all data items are the same size, the\n      \\ref MDBX_GET_MULTIPLE, \\ref MDBX_NEXT_MULTIPLE and\n      \\ref MDBX_PREV_MULTIPLE cursor operations may be used to retrieve\n      multiple items at once.\n  - \\ref MDBX_INTEGERDUP\n      This option specifies that duplicate data items are binary integers,\n      similar to \\ref MDBX_INTEGERKEY keys. The data values must all be of the\n      same size and must be aligned while passing as arguments.\n  - \\ref MDBX_REVERSEDUP\n      This option specifies that duplicate data items should be compared as\n      strings in reverse order (the comparison is performed in the direction\n      from the last byte to the first).\n  - \\ref MDBX_CREATE\n      Create the named table if it doesn't exist. This option is not\n      allowed in a read-only transaction or a read-only environment.\n\n \\param [out] dbi     Address where the new \\ref MDBX_dbi handle\n                      will be stored.\n\n For \\ref mdbx_dbi_open_ex() additional arguments allow you to set custom\n comparison functions for keys and values (for multimaps).\n \\see avoid_custom_comparators\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_NOTFOUND   The specified table doesn't exist in the\n                         environment and \\ref MDBX_CREATE was not specified.\n \\retval MDBX_DBS_FULL   Too many tables have been opened.\n                         \\see mdbx_env_set_maxdbs()\n \\retval MDBX_INCOMPATIBLE  Table is incompatible with given flags,\n                         i.e. the passed flags is different with which the\n                         table was created, or the table was already\n                         opened with a different comparison function(s).\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread."]
    pub fn mdbx_dbi_open(
        txn: *mut MDBX_txn,
        name: *const ::std::os::raw::c_char,
        flags: MDBX_db_flags_t,
        dbi: *mut MDBX_dbi,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_dbi_open()\n \\ingroup c_dbi"]
    pub fn mdbx_dbi_open2(
        txn: *mut MDBX_txn,
        name: *const MDBX_val,
        flags: MDBX_db_flags_t,
        dbi: *mut MDBX_dbi,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Open or Create a named table in the environment\n with using custom comparison functions.\n \\ingroup c_dbi\n\n \\deprecated Please \\ref avoid_custom_comparators\n \"avoid using custom comparators\" and use \\ref mdbx_dbi_open() instead.\n\n \\param [in] txn    transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] name   The name of the table to open. If only a single\n                    table is needed in the environment,\n                    this value may be NULL.\n \\param [in] flags  Special options for this table.\n \\param [in] keycmp  Optional custom key comparison function for a table.\n \\param [in] datacmp Optional custom data comparison function for a table.\n \\param [out] dbi    Address where the new MDBX_dbi handle will be stored.\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_dbi_open_ex(
        txn: *mut MDBX_txn,
        name: *const ::std::os::raw::c_char,
        flags: MDBX_db_flags_t,
        dbi: *mut MDBX_dbi,
        keycmp: MDBX_cmp_func,
        datacmp: MDBX_cmp_func,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_dbi_open_ex()\n \\ingroup c_dbi"]
    pub fn mdbx_dbi_open_ex2(
        txn: *mut MDBX_txn,
        name: *const MDBX_val,
        flags: MDBX_db_flags_t,
        dbi: *mut MDBX_dbi,
        keycmp: MDBX_cmp_func,
        datacmp: MDBX_cmp_func,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Переименовает таблицу по DBI-дескриптору\n\n \\ingroup c_dbi\n\n Переименовывает пользовательскую именованную таблицу связанную с передаваемым\n DBI-дескриптором.\n\n \\param [in,out] txn   Пишущая транзакция запущенная посредством\n                       \\ref mdbx_txn_begin().\n \\param [in]     dbi   Дескриптор таблицы\n                       открытый посредством \\ref mdbx_dbi_open().\n\n \\param [in]     name  Новое имя для переименования.\n\n \\returns Ненулевое значение кода ошибки, либо 0 при успешном выполнении."]
    pub fn mdbx_dbi_rename(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_dbi_rename()\n \\ingroup c_dbi"]
    pub fn mdbx_dbi_rename2(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        name: *const MDBX_val,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Функция обратного вызова для перечисления\n  пользовательских именованных таблиц.\n\n \\ingroup c_statinfo\n \\see mdbx_enumerate_tables()\n\n \\param [in] ctx       Указатель на контекст переданный аналогичным\n                       параметром в \\ref mdbx_enumerate_tables().\n \\param [in] txn       Транзазакция.\n \\param [in] name      Имя таблицы.\n \\param [in] flags     Флаги \\ref MDBX_db_flags_t.\n \\param [in] stat      Базовая информация \\ref MDBX_stat о таблице.\n \\param [in] dbi       Отличное от 0 значение DBI-дескриптора,\n                       если таковой был открыт для этой таблицы.\n                       Либо 0 если такого открытого дескриптора нет.\n\n \\returns Ноль при успехе и продолжении перечисления, при возвращении другого\n          значения оно будет немедленно возвращено вызывающему\n          без продолжения перечисления."]
pub type MDBX_table_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        txn: *const MDBX_txn,
        name: *const MDBX_val,
        flags: MDBX_db_flags_t,
        stat: *const MDBX_stat,
        dbi: MDBX_dbi,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " \\brief Перечисляет пользовательские именнованные таблицы.\n\n Производит перечисление пользовательских именнованных таблиц, вызывая\n специфицируемую пользователем функцию-визитер для каждой именованной таблицы.\n Перечисление продолжается до исчерпания именованных таблиц, либо до возврата\n отличного от нуля результата из заданной пользователем функции, которое будет\n сразу возвращено в качестве результата.\n\n \\ingroup c_statinfo\n \\see MDBX_table_enum_func\n\n \\param [in] txn     Транзакция запущенная посредством\n                     \\ref mdbx_txn_begin().\n \\param [in] func    Указатель на пользовательскую функцию\n                     с сигнатурой \\ref MDBX_table_enum_func,\n                     которая будет вызвана для каждой таблицы.\n \\param [in] ctx     Указатель на некоторый контект, который будет передан\n                     в функцию `func()` как есть.\n\n \\returns Ненулевое значение кода ошибки, либо 0 при успешном выполнении."]
    pub fn mdbx_enumerate_tables(
        txn: *const MDBX_txn,
        func: MDBX_table_enum_func,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\defgroup value2key Value-to-Key functions\n \\brief Value-to-Key functions to\n \\ref avoid_custom_comparators \"avoid using custom comparators\"\n \\see key2value\n @{\n\n The \\ref mdbx_key_from_jsonInteger() build a keys which are comparable with\n keys created by \\ref mdbx_key_from_double(). So this allows mixing `int64_t`\n and IEEE754 double values in one index for JSON-numbers with restriction for\n integer numbers range corresponding to RFC-7159, i.e. \\f$[-2^{53}+1,\n 2^{53}-1]\\f$. See bottom of page 6 at https://tools.ietf.org/html/rfc7159"]
    pub fn mdbx_key_from_jsonInteger(json_integer: i64) -> u64;
}
unsafe extern "C" {
    pub fn mdbx_key_from_double(ieee754_64bit: f64) -> u64;
}
unsafe extern "C" {
    pub fn mdbx_key_from_ptrdouble(ieee754_64bit: *const f64) -> u64;
}
unsafe extern "C" {
    pub fn mdbx_key_from_float(ieee754_32bit: f32) -> u32;
}
unsafe extern "C" {
    pub fn mdbx_key_from_ptrfloat(ieee754_32bit: *const f32) -> u32;
}
unsafe extern "C" {
    #[doc = " \\defgroup key2value Key-to-Value functions\n \\brief Key-to-Value functions to\n \\ref avoid_custom_comparators \"avoid using custom comparators\"\n \\see value2key\n @{"]
    pub fn mdbx_jsonInteger_from_key(arg1: MDBX_val) -> i64;
}
unsafe extern "C" {
    pub fn mdbx_double_from_key(arg1: MDBX_val) -> f64;
}
unsafe extern "C" {
    pub fn mdbx_float_from_key(arg1: MDBX_val) -> f32;
}
unsafe extern "C" {
    pub fn mdbx_int32_from_key(arg1: MDBX_val) -> i32;
}
unsafe extern "C" {
    pub fn mdbx_int64_from_key(arg1: MDBX_val) -> i64;
}
unsafe extern "C" {
    #[doc = " \\brief Retrieve statistics for a table.\n \\ingroup c_statinfo\n\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi     A table handle returned by \\ref mdbx_dbi_open().\n \\param [out] stat   The address of an \\ref MDBX_stat structure where\n                     the statistics will be copied.\n \\param [in] bytes   The size of \\ref MDBX_stat.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL   An invalid parameter was specified."]
    pub fn mdbx_dbi_stat(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        stat: *mut MDBX_stat,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Retrieve depth (bitmask) information of nested dupsort (multi-value)\n B+trees for given table.\n \\ingroup c_statinfo\n\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi     A table handle returned by \\ref mdbx_dbi_open().\n \\param [out] mask   The address of an uint32_t value where the bitmask\n                     will be stored.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL       An invalid parameter was specified.\n \\retval MDBX_RESULT_TRUE  The dbi isn't a dupsort (multi-value) table."]
    pub fn mdbx_dbi_dupsort_depthmask(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        mask: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " DB was written in this txn"]
pub const MDBX_dbi_state_MDBX_DBI_DIRTY: MDBX_dbi_state = 1;
#[doc = " Cached Named-DB record is older than txnID"]
pub const MDBX_dbi_state_MDBX_DBI_STALE: MDBX_dbi_state = 2;
#[doc = " Named-DB handle opened in this txn"]
pub const MDBX_dbi_state_MDBX_DBI_FRESH: MDBX_dbi_state = 4;
#[doc = " Named-DB handle created in this txn"]
pub const MDBX_dbi_state_MDBX_DBI_CREAT: MDBX_dbi_state = 8;
#[doc = " \\brief DBI state bits returted by \\ref mdbx_dbi_flags_ex()\n \\ingroup c_statinfo\n \\see mdbx_dbi_flags_ex()"]
pub type MDBX_dbi_state = ::std::os::raw::c_int;
#[doc = " \\brief DBI state bits returted by \\ref mdbx_dbi_flags_ex()\n \\ingroup c_statinfo\n \\see mdbx_dbi_flags_ex()"]
pub use self::MDBX_dbi_state as MDBX_dbi_state_t;
unsafe extern "C" {
    #[doc = " \\brief Retrieve the DB flags and status for a table handle.\n \\ingroup c_statinfo\n \\see MDBX_db_flags_t\n \\see MDBX_dbi_state_t\n\n \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi     A table handle returned by \\ref mdbx_dbi_open().\n \\param [out] flags  Address where the flags will be returned.\n \\param [out] state  Address where the state will be returned.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_dbi_flags_ex(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        flags: *mut ::std::os::raw::c_uint,
        state: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Close a table handle. Normally unnecessary.\n \\ingroup c_dbi\n\n Closing a table handle is not necessary, but lets \\ref mdbx_dbi_open()\n reuse the handle value. Usually it's better to set a bigger\n \\ref mdbx_env_set_maxdbs(), unless that value would be large.\n\n \\note Use with care.\n This call is synchronized via mutex with \\ref mdbx_dbi_open(), but NOT with\n any transaction(s) running by other thread(s).\n So the `mdbx_dbi_close()` MUST NOT be called in-parallel/concurrently\n with any transactions using the closing dbi-handle, nor during other thread\n commit/abort a write transacton(s). The \"next\" version of libmdbx (\\ref\n MithrilDB) will solve this issue.\n\n Handles should only be closed if no other threads are going to reference\n the table handle or one of its cursors any further. Do not close a handle\n if an existing transaction has modified its table. Doing so can cause\n misbehavior from table corruption to errors like \\ref MDBX_BAD_DBI\n (since the DB name is gone).\n\n \\param [in] env  An environment handle returned by \\ref mdbx_env_create().\n \\param [in] dbi  A table handle returned by \\ref mdbx_dbi_open().\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_dbi_close(env: *mut MDBX_env, dbi: MDBX_dbi) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Empty or delete and close a table.\n \\ingroup c_crud\n\n \\see mdbx_dbi_close() \\see mdbx_dbi_open()\n\n \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi  A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] del  `false` to empty the DB, `true` to delete it\n                  from the environment and close the DB handle.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_drop(txn: *mut MDBX_txn, dbi: MDBX_dbi, del: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Get items from a table.\n \\ingroup c_crud\n\n This function retrieves key/data pairs from the table. The address\n and length of the data associated with the specified key are returned\n in the structure to which data refers.\n If the table supports duplicate keys (\\ref MDBX_DUPSORT) then the\n first data item for the key will be returned. Retrieval of other\n items requires the use of \\ref mdbx_cursor_get().\n\n \\note The memory pointed to by the returned values is owned by the\n table. The caller MUST not dispose of the memory, and MUST not modify it\n in any way regardless in a read-only nor read-write transactions!\n For case a table opened without the \\ref MDBX_WRITEMAP modification\n attempts likely will cause a `SIGSEGV`. However, when a table opened with\n the \\ref MDBX_WRITEMAP or in case values returned inside read-write\n transaction are located on a \"dirty\" (modified and pending to commit) pages,\n such modification will silently accepted and likely will lead to DB and/or\n data corruption.\n\n \\note Values returned from the table are valid only until a\n subsequent update operation, or the end of the transaction.\n\n \\param [in] txn       A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi       A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] key       The key to search for in the table.\n \\param [in,out] data  The data corresponding to the key.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_NOTFOUND  The key was not in the table.\n \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_get(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        data: *mut MDBX_val,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Get items from a table\n and optionally number of data items for a given key.\n\n \\ingroup c_crud\n\n Briefly this function does the same as \\ref mdbx_get() with a few\n differences:\n  1. If values_count is NOT NULL, then returns the count\n     of multi-values/duplicates for a given key.\n  2. Updates BOTH the key and the data for pointing to the actual key-value\n     pair inside the table.\n\n \\param [in] txn           A transaction handle returned\n                           by \\ref mdbx_txn_begin().\n \\param [in] dbi           A table handle returned by \\ref mdbx_dbi_open().\n \\param [in,out] key       The key to search for in the table.\n \\param [in,out] data      The data corresponding to the key.\n \\param [out] values_count The optional address to return number of values\n                           associated with given key:\n                            = 0 - in case \\ref MDBX_NOTFOUND error;\n                            = 1 - exactly for tables\n                                  WITHOUT \\ref MDBX_DUPSORT;\n                            >= 1 for tables WITH \\ref MDBX_DUPSORT.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_NOTFOUND  The key was not in the table.\n \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_get_ex(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
        values_count: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Get equal or great item from a table.\n \\ingroup c_crud\n\n Briefly this function does the same as \\ref mdbx_get() with a few\n differences:\n 1. Return equal or great (due comparison function) key-value\n    pair, but not only exactly matching with the key.\n 2. On success return \\ref MDBX_SUCCESS if key found exactly,\n    and \\ref MDBX_RESULT_TRUE otherwise. Moreover, for tables with\n    \\ref MDBX_DUPSORT flag the data argument also will be used to match over\n    multi-value/duplicates, and \\ref MDBX_SUCCESS will be returned only when\n    BOTH the key and the data match exactly.\n 3. Updates BOTH the key and the data for pointing to the actual key-value\n    pair inside the table.\n\n \\param [in] txn           A transaction handle returned\n                           by \\ref mdbx_txn_begin().\n \\param [in] dbi           A table handle returned by \\ref mdbx_dbi_open().\n \\param [in,out] key       The key to search for in the table.\n \\param [in,out] data      The data corresponding to the key.\n\n \\returns A non-zero error value on failure and \\ref MDBX_RESULT_FALSE\n          or \\ref MDBX_RESULT_TRUE on success (as described above).\n          Some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_NOTFOUND      The key was not in the table.\n \\retval MDBX_EINVAL        An invalid parameter was specified."]
    pub fn mdbx_get_equal_or_great(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Store items into a table.\n \\ingroup c_crud\n\n This function stores key/data pairs in the table. The default behavior\n is to enter the new key/data pair, replacing any previously existing key\n if duplicates are disallowed, or adding a duplicate data item if\n duplicates are allowed (see \\ref MDBX_DUPSORT).\n\n \\param [in] txn        A transaction handle returned\n                        by \\ref mdbx_txn_begin().\n \\param [in] dbi        A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] key        The key to store in the table.\n \\param [in,out] data   The data to store.\n \\param [in] flags      Special options for this operation.\n                        This parameter must be set to 0 or by bitwise OR'ing\n                        together one or more of the values described here:\n   - \\ref MDBX_NODUPDATA\n      Enter the new key-value pair only if it does not already appear\n      in the table. This flag may only be specified if the table\n      was opened with \\ref MDBX_DUPSORT. The function will return\n      \\ref MDBX_KEYEXIST if the key/data pair already appears in the table.\n\n  - \\ref MDBX_NOOVERWRITE\n      Enter the new key/data pair only if the key does not already appear\n      in the table. The function will return \\ref MDBX_KEYEXIST if the key\n      already appears in the table, even if the table supports\n      duplicates (see \\ref  MDBX_DUPSORT). The data parameter will be set\n      to point to the existing item.\n\n  - \\ref MDBX_CURRENT\n      Update an single existing entry, but not add new ones. The function will\n      return \\ref MDBX_NOTFOUND if the given key not exist in the table.\n      In case multi-values for the given key, with combination of\n      the \\ref MDBX_ALLDUPS will replace all multi-values,\n      otherwise return the \\ref MDBX_EMULTIVAL.\n\n  - \\ref MDBX_RESERVE\n      Reserve space for data of the given size, but don't copy the given\n      data. Instead, return a pointer to the reserved space, which the\n      caller can fill in later - before the next update operation or the\n      transaction ends. This saves an extra memcpy if the data is being\n      generated later. MDBX does nothing else with this memory, the caller\n      is expected to modify all of the space requested. This flag must not\n      be specified if the table was opened with \\ref MDBX_DUPSORT.\n\n  - \\ref MDBX_APPEND\n      Append the given key/data pair to the end of the table. This option\n      allows fast bulk loading when keys are already known to be in the\n      correct order. Loading unsorted keys with this flag will cause\n      a \\ref MDBX_EKEYMISMATCH error.\n\n  - \\ref MDBX_APPENDDUP\n      As above, but for sorted dup data.\n\n  - \\ref MDBX_MULTIPLE\n      Store multiple contiguous data elements in a single request. This flag\n      may only be specified if the table was opened with\n      \\ref MDBX_DUPFIXED. With combination the \\ref MDBX_ALLDUPS\n      will replace all multi-values.\n      The data argument must be an array of two \\ref MDBX_val. The `iov_len`\n      of the first \\ref MDBX_val must be the size of a single data element.\n      The `iov_base` of the first \\ref MDBX_val must point to the beginning\n      of the array of contiguous data elements which must be properly aligned\n      in case of table with \\ref MDBX_INTEGERDUP flag.\n      The `iov_len` of the second \\ref MDBX_val must be the count of the\n      number of data elements to store. On return this field will be set to\n      the count of the number of elements actually written. The `iov_base` of\n      the second \\ref MDBX_val is unused.\n\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_KEYEXIST  The key/value pair already exists in the table.\n \\retval MDBX_MAP_FULL  The database is full, see \\ref mdbx_env_set_mapsize().\n \\retval MDBX_TXN_FULL  The transaction has too many dirty pages.\n \\retval MDBX_EACCES    An attempt was made to write\n                        in a read-only transaction.\n \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_put(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Replace items in a table.\n \\ingroup c_crud\n\n This function allows to update or delete an existing value at the same time\n as the previous value is retrieved. If the argument new_data equal is NULL\n zero, the removal is performed, otherwise the update/insert.\n\n The current value may be in an already changed (aka dirty) page. In this\n case, the page will be overwritten during the update, and the old value will\n be lost. Therefore, an additional buffer must be passed via old_data\n argument initially to copy the old value. If the buffer passed in is too\n small, the function will return \\ref MDBX_RESULT_TRUE by setting iov_len\n field pointed by old_data argument to the appropriate value, without\n performing any changes.\n\n For tables with non-unique keys (i.e. with \\ref MDBX_DUPSORT flag),\n another use case is also possible, when by old_data argument selects a\n specific item from multi-value/duplicates with the same key for deletion or\n update. To select this scenario in flags should simultaneously specify\n \\ref MDBX_CURRENT and \\ref MDBX_NOOVERWRITE. This combination is chosen\n because it makes no sense, and thus allows you to identify the request of\n such a scenario.\n\n \\param [in] txn           A transaction handle returned\n                           by \\ref mdbx_txn_begin().\n \\param [in] dbi           A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] key           The key to store in the table.\n \\param [in] new_data      The data to store, if NULL then deletion will\n                           be performed.\n \\param [in,out] old_data  The buffer for retrieve previous value as describe\n                           above.\n \\param [in] flags         Special options for this operation.\n                           This parameter must be set to 0 or by bitwise\n                           OR'ing together one or more of the values\n                           described in \\ref mdbx_put() description above,\n                           and additionally\n                           (\\ref MDBX_CURRENT | \\ref MDBX_NOOVERWRITE)\n                           combination for selection particular item from\n                           multi-value/duplicates.\n\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_replace(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        new_data: *mut MDBX_val,
        old_data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
    ) -> ::std::os::raw::c_int;
}
pub type MDBX_preserve_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        target: *mut MDBX_val,
        src: *const ::std::os::raw::c_void,
        bytes: usize,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn mdbx_replace_ex(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        new_data: *mut MDBX_val,
        old_data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
        preserver: MDBX_preserve_func,
        preserver_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Delete items from a table.\n \\ingroup c_crud\n\n This function removes key/data pairs from the table.\n\n \\note The data parameter is NOT ignored regardless the table does\n support sorted duplicate data items or not. If the data parameter\n is non-NULL only the matching data item will be deleted. Otherwise, if data\n parameter is NULL, any/all value(s) for specified key will be deleted.\n\n This function will return \\ref MDBX_NOTFOUND if the specified key/data\n pair is not in the table.\n\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n\n \\param [in] txn   A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi   A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] key   The key to delete from the table.\n \\param [in] data  The data to delete.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_EACCES   An attempt was made to write\n                       in a read-only transaction.\n \\retval MDBX_EINVAL   An invalid parameter was specified."]
    pub fn mdbx_del(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        data: *const MDBX_val,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Create a cursor handle but not bind it to transaction nor DBI-handle.\n \\ingroup c_cursors\n\n A cursor cannot be used when its table handle is closed. Nor when its\n transaction has ended, except with \\ref mdbx_cursor_bind() and \\ref\n mdbx_cursor_renew(). Also it can be discarded with \\ref mdbx_cursor_close().\n\n A cursor must be closed explicitly always, before or after its transaction\n ends. It can be reused with \\ref mdbx_cursor_bind()\n or \\ref mdbx_cursor_renew() before finally closing it.\n\n \\note In contrast to LMDB, the MDBX required that any opened cursors can be\n reused and must be freed explicitly, regardless ones was opened in a\n read-only or write transaction. The REASON for this is eliminates ambiguity\n which helps to avoid errors such as: use-after-free, double-free, i.e.\n memory corruption and segfaults.\n\n \\param [in] context A pointer to application context to be associated with\n                     created cursor and could be retrieved by\n                     \\ref mdbx_cursor_get_userctx() until cursor closed.\n\n \\returns Created cursor handle or NULL in case out of memory."]
    pub fn mdbx_cursor_create(context: *mut ::std::os::raw::c_void) -> *mut MDBX_cursor;
}
unsafe extern "C" {
    #[doc = " \\brief Set application information associated with the cursor.\n \\ingroup c_cursors\n \\see mdbx_cursor_get_userctx()\n\n \\param [in] cursor  An cursor handle returned by \\ref mdbx_cursor_create()\n                     or \\ref mdbx_cursor_open().\n \\param [in] ctx     An arbitrary pointer for whatever the application needs.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_cursor_set_userctx(
        cursor: *mut MDBX_cursor,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Get the application information associated with the MDBX_cursor.\n \\ingroup c_cursors\n \\see mdbx_cursor_set_userctx()\n\n \\param [in] cursor  An cursor handle returned by \\ref mdbx_cursor_create()\n                     or \\ref mdbx_cursor_open().\n \\returns The pointer which was passed via the `context` parameter\n          of `mdbx_cursor_create()` or set by \\ref mdbx_cursor_set_userctx(),\n          or `NULL` if something wrong."]
    pub fn mdbx_cursor_get_userctx(cursor: *const MDBX_cursor) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " \\brief Bind cursor to specified transaction and DBI-handle.\n \\ingroup c_cursors\n\n Using of the `mdbx_cursor_bind()` is equivalent to calling\n \\ref mdbx_cursor_renew() but with specifying an arbitrary DBI-handle.\n\n A cursor may be associated with a new transaction, and referencing a new or\n the same table handle as it was created with. This may be done whether the\n previous transaction is live or dead.\n\n If the transaction is nested, then the cursor should not be used in its parent transaction.\n Otherwise it is no way to restore state if this nested transaction will be aborted,\n nor impossible to define the expected behavior.\n\n \\note In contrast to LMDB, the MDBX required that any opened cursors can be\n reused and must be freed explicitly, regardless ones was opened in a\n read-only or write transaction. The REASON for this is eliminates ambiguity\n which helps to avoid errors such as: use-after-free, double-free, i.e.\n memory corruption and segfaults.\n\n \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi      A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] cursor   A cursor handle returned by \\ref mdbx_cursor_create().\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_cursor_bind(
        txn: *mut MDBX_txn,
        cursor: *mut MDBX_cursor,
        dbi: MDBX_dbi,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Unbind cursor from a transaction.\n \\ingroup c_cursors\n\n Unbinded cursor is disassociated with any transactions but still holds\n the original DBI-handle internally. Thus it could be renewed with any running\n transaction or closed.\n\n If the transaction is nested, then the cursor should not be used in its parent transaction.\n Otherwise it is no way to restore state if this nested transaction will be aborted,\n nor impossible to define the expected behavior.\n\n \\see mdbx_cursor_renew()\n \\see mdbx_cursor_bind()\n \\see mdbx_cursor_close()\n \\see mdbx_cursor_reset()\n\n \\note In contrast to LMDB, the MDBX required that any opened cursors can be\n reused and must be freed explicitly, regardless ones was opened in a\n read-only or write transaction. The REASON for this is eliminates ambiguity\n which helps to avoid errors such as: use-after-free, double-free, i.e.\n memory corruption and segfaults.\n\n \\param [in] cursor   A cursor handle returned by \\ref mdbx_cursor_open().\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_cursor_unbind(cursor: *mut MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Сбрасывает состояние курсора.\n \\ingroup c_cursors\n\n В результате сброса курсор становится неустановленным и не позволяет\n выполнять операции относительного позиционирования, получения или изменения\n данных, до установки на позицию не зависящую от текущей. Что позволяет\n приложению пресекать дальнейшие операции без предварительного\n позиционирования курсора.\n\n \\param [in] cursor   Указатель на курсор.\n\n \\returns Результат операции сканирования, либо код ошибки."]
    pub fn mdbx_cursor_reset(cursor: *mut MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Create a cursor handle for the specified transaction and DBI handle.\n \\ingroup c_cursors\n\n Using of the `mdbx_cursor_open()` is equivalent to calling\n \\ref mdbx_cursor_create() and then \\ref mdbx_cursor_bind() functions.\n\n A cursor cannot be used when its table handle is closed. Nor when its\n transaction has ended, except with \\ref mdbx_cursor_bind() and \\ref\n mdbx_cursor_renew(). Also it can be discarded with \\ref mdbx_cursor_close().\n\n A cursor must be closed explicitly always, before or after its transaction\n ends. It can be reused with \\ref mdbx_cursor_bind()\n or \\ref mdbx_cursor_renew() before finally closing it.\n\n \\note In contrast to LMDB, the MDBX required that any opened cursors can be\n reused and must be freed explicitly, regardless ones was opened in a\n read-only or write transaction. The REASON for this is eliminates ambiguity\n which helps to avoid errors such as: use-after-free, double-free, i.e.\n memory corruption and segfaults.\n\n \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi      A table handle returned by \\ref mdbx_dbi_open().\n \\param [out] cursor  Address where the new \\ref MDBX_cursor handle will be\n                      stored.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_cursor_open(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        cursor: *mut *mut MDBX_cursor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Closes a cursor handle without returning error code.\n \\ingroup c_cursors\n\n The cursor handle will be freed and must not be used again after this call,\n but its transaction may still be live.\n\n This function returns `void` but panic in case of error. Use \\ref mdbx_cursor_close2()\n if you need to receive an error code instead of an app crash.\n\n \\see mdbx_cursor_close2\n\n \\note In contrast to LMDB, the MDBX required that any opened cursors can be\n reused and must be freed explicitly, regardless ones was opened in a\n read-only or write transaction. The REASON for this is eliminates ambiguity\n which helps to avoid errors such as: use-after-free, double-free, i.e.\n memory corruption and segfaults.\n\n \\param [in] cursor  A cursor handle returned by \\ref mdbx_cursor_open()\n                     or \\ref mdbx_cursor_create()."]
    pub fn mdbx_cursor_close(cursor: *mut MDBX_cursor);
}
unsafe extern "C" {
    #[doc = " \\brief Closes a cursor handle with returning error code.\n \\ingroup c_cursors\n\n The cursor handle will be freed and must not be used again after this call,\n but its transaction may still be live.\n\n \\see mdbx_cursor_close\n\n \\note In contrast to LMDB, the MDBX required that any opened cursors can be\n reused and must be freed explicitly, regardless ones was opened in a\n read-only or write transaction. The REASON for this is eliminates ambiguity\n which helps to avoid errors such as: use-after-free, double-free, i.e.\n memory corruption and segfaults.\n\n \\param [in] cursor  A cursor handle returned by \\ref mdbx_cursor_open()\n                     or \\ref mdbx_cursor_create().\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_cursor_close2(cursor: *mut MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Unbind or closes all cursors of a given transaction and of all\n its parent transactions if ones are.\n \\ingroup c_cursors\n\n Unbinds either closes all cursors associated (opened, renewed or binded) with\n the given transaction in a bulk with minimal overhead.\n\n \\see mdbx_cursor_unbind()\n \\see mdbx_cursor_close()\n\n \\param [in] txn        A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] unbind     If non-zero, unbinds cursors and leaves ones reusable.\n                        Otherwise close and dispose cursors.\n \\param [in,out] count  An optional pointer to return the number of cursors\n                        processed by the requested operation.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_BAD_TXN          Given transaction is invalid or has\n                               a child/nested transaction transaction."]
    pub fn mdbx_txn_release_all_cursors_ex(
        txn: *const MDBX_txn,
        unbind: bool,
        count: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Renew a cursor handle for use within the given transaction.\n \\ingroup c_cursors\n\n A cursor may be associated with a new transaction whether the previous\n transaction is running or finished.\n\n Using of the `mdbx_cursor_renew()` is equivalent to calling\n \\ref mdbx_cursor_bind() with the DBI-handle that previously\n the cursor was used with.\n\n \\note In contrast to LMDB, the MDBX allow any cursor to be re-used by using\n \\ref mdbx_cursor_renew(), to avoid unnecessary malloc/free overhead until it\n freed by \\ref mdbx_cursor_close().\n\n \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] cursor   A cursor handle returned by \\ref mdbx_cursor_open().\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL  An invalid parameter was specified.\n \\retval MDBX_BAD_DBI The cursor was not bound to a DBI-handle\n                      or such a handle became invalid."]
    pub fn mdbx_cursor_renew(txn: *mut MDBX_txn, cursor: *mut MDBX_cursor)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Return the cursor's transaction handle.\n \\ingroup c_cursors\n\n \\param [in] cursor A cursor handle returned by \\ref mdbx_cursor_open()."]
    pub fn mdbx_cursor_txn(cursor: *const MDBX_cursor) -> *mut MDBX_txn;
}
unsafe extern "C" {
    #[doc = " \\brief Return the cursor's table handle.\n \\ingroup c_cursors\n\n \\param [in] cursor  A cursor handle returned by \\ref mdbx_cursor_open()."]
    pub fn mdbx_cursor_dbi(cursor: *const MDBX_cursor) -> MDBX_dbi;
}
unsafe extern "C" {
    #[doc = " \\brief Copy cursor position and state.\n \\ingroup c_cursors\n\n \\param [in] src       A source cursor handle returned\n by \\ref mdbx_cursor_create() or \\ref mdbx_cursor_open().\n\n \\param [in,out] dest  A destination cursor handle returned\n by \\ref mdbx_cursor_create() or \\ref mdbx_cursor_open().\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_cursor_copy(
        src: *const MDBX_cursor,
        dest: *mut MDBX_cursor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Сравнивает позицию курсоров.\n \\ingroup c_cursors\n\n Функция предназначена для сравнения позиций двух\n инициализированных/установленных курсоров, связанных с одной транзакцией и\n одной таблицей (DBI-дескриптором).\n Если же курсоры связаны с разными транзакциями, либо с разными таблицами,\n либо один из них не инициализирован, то результат сравнения не определен\n (поведением может быть изменено в последующих версиях).\n\n \\param [in] left             Левый курсор для сравнения позиций.\n \\param [in] right            Правый курсор для сравнения позиций.\n \\param [in] ignore_multival  Булевой флаг, влияющий на результат только при\n        сравнении курсоров для таблиц с мульти-значениями, т.е. с флагом\n        \\ref MDBX_DUPSORT. В случае `true`, позиции курсоров сравниваются\n        только по ключам, без учета позиционирования среди мульти-значений.\n        Иначе, в случае `false`, при совпадении позиций по ключам,\n        сравниваются также позиции по мульти-значениям.\n\n \\retval Значение со знаком в семантике оператора `<=>` (меньше нуля, ноль,\n либо больше нуля) как результат сравнения позиций курсоров."]
    pub fn mdbx_cursor_compare(
        left: *const MDBX_cursor,
        right: *const MDBX_cursor,
        ignore_multival: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Retrieve by cursor.\n \\ingroup c_crud\n\n This function retrieves key/data pairs from the table. The address and\n length of the key are returned in the object to which key refers (except\n for the case of the \\ref MDBX_SET option, in which the key object is\n unchanged), and the address and length of the data are returned in the object\n to which data refers.\n \\see mdbx_get()\n\n \\note The memory pointed to by the returned values is owned by the\n database. The caller MUST not dispose of the memory, and MUST not modify it\n in any way regardless in a read-only nor read-write transactions!\n For case a database opened without the \\ref MDBX_WRITEMAP modification\n attempts likely will cause a `SIGSEGV`. However, when a database opened with\n the \\ref MDBX_WRITEMAP or in case values returned inside read-write\n transaction are located on a \"dirty\" (modified and pending to commit) pages,\n such modification will silently accepted and likely will lead to DB and/or\n data corruption.\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n \\param [in,out] key   The key for a retrieved item.\n \\param [in,out] data  The data of a retrieved item.\n \\param [in] op        A cursor operation \\ref MDBX_cursor_op.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_NOTFOUND  No matching key found.\n \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_cursor_get(
        cursor: *mut MDBX_cursor,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
        op: MDBX_cursor_op,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Служебная функция для использования в утилитах.\n \\ingroup c_extra\n\n При использовании определяемых пользователем функций сравнения (aka custom\n comparison functions) проверка порядка ключей может приводить к неверным\n результатам и возврате ошибки \\ref MDBX_CORRUPTED.\n\n Эта функция отключает контроль порядка следования ключей на страницах при\n чтении страниц БД для этого курсора, и таким образом, позволяет прочитать\n данные при отсутствии/недоступности использованных функций сравнения.\n \\see avoid_custom_comparators\n\n \\returns Результат операции сканирования, либо код ошибки."]
    pub fn mdbx_cursor_ignord(cursor: *mut MDBX_cursor) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Тип предикативных функций обратного вызова используемых\n \\ref mdbx_cursor_scan() и \\ref mdbx_cursor_scan_from() для пробирования\n пар ключ-значения.\n \\ingroup c_crud\n\n \\param [in,out] context  Указатель на контекст с необходимой для оценки\n                          информацией, который полностью подготавливается\n                          и контролируется вами.\n \\param [in] key          Ключ для оценки пользовательской функцией.\n \\param [in] value        Значение для оценки пользовательской функцией.\n \\param [in,out] arg      Дополнительный аргумент предикативной функции,\n                          который полностью подготавливается\n                          и контролируется вами.\n\n \\returns Результат проверки соответствия переданной пары ключ-значения\n искомой цели. Иначе код ошибки, который прерывает сканирование и возвращается\n без изменения в качестве результата из функций \\ref mdbx_cursor_scan()\n или \\ref mdbx_cursor_scan_from().\n\n \\retval MDBX_RESULT_TRUE если переданная пара ключ-значение соответствует\n         искомой и следует завершить сканирование.\n \\retval MDBX_RESULT_FALSE если переданная пара ключ-значение НЕ соответствует\n         искомой и следует продолжать сканирование.\n \\retval ИНАЧЕ любое другое значение, отличное от \\ref MDBX_RESULT_TRUE\n         и \\ref MDBX_RESULT_FALSE, считается индикатором ошибки\n         и возвращается без изменений в качестве результата сканирования.\n\n \\see mdbx_cursor_scan()\n \\see mdbx_cursor_scan_from()"]
pub type MDBX_predicate_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        key: *mut MDBX_val,
        value: *mut MDBX_val,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " \\brief Сканирует таблицу с использованием передаваемого предиката,\n с уменьшением сопутствующих накладных расходов.\n \\ingroup c_crud\n\n Реализует функционал сходный с шаблоном `std::find_if<>()` с использованием\n курсора и пользовательской предикативной функции, экономя при этом\n на сопутствующих накладных расходах, в том числе, не выполняя часть проверок\n внутри цикла итерации записей и потенциально уменьшая количество\n DSO-трансграничных вызовов.\n\n Функция принимает курсор, который должен быть привязан к некоторой транзакции\n и DBI-дескриптору таблицы, выполняет первоначальное позиционирование курсора\n определяемое аргументом `start_op`. Далее, производится оценка каждой пары\n ключ-значения посредством предоставляемой вами предикативной функции\n `predicate` и затем, при необходимости, переход к следующему элементу\n посредством операции `turn_op`, до наступления одного из четырех событий:\n  - достигается конец данных;\n  - возникнет ошибка при позиционировании курсора;\n  - оценочная функция вернет \\ref MDBX_RESULT_TRUE, сигнализируя\n    о необходимости остановить дальнейшее сканирование;\n  - оценочная функция возвратит значение отличное от \\ref MDBX_RESULT_FALSE\n    и \\ref MDBX_RESULT_TRUE сигнализируя об ошибке.\n\n \\param [in,out] cursor   Курсор для выполнения операции сканирования,\n                          связанный с активной транзакцией и DBI-дескриптором\n                          таблицы. Например, курсор созданный\n                          посредством \\ref mdbx_cursor_open().\n \\param [in] predicate    Предикативная функция для оценки итерируемых\n                          пар ключ-значения,\n                          более подробно смотрите \\ref MDBX_predicate_func.\n \\param [in,out] context  Указатель на контекст с необходимой для оценки\n                          информацией, который полностью подготавливается\n                          и контролируется вами.\n \\param [in] start_op     Стартовая операция позиционирования курсора,\n                          более подробно смотрите \\ref MDBX_cursor_op.\n                          Для сканирования без изменения исходной позиции\n                          курсора используйте \\ref MDBX_GET_CURRENT.\n                          Допустимые значения \\ref MDBX_FIRST,\n                          \\ref MDBX_FIRST_DUP, \\ref MDBX_LAST,\n                          \\ref MDBX_LAST_DUP, \\ref MDBX_GET_CURRENT,\n                          а также \\ref MDBX_GET_MULTIPLE.\n \\param [in] turn_op      Операция позиционирования курсора для перехода\n                          к следующему элементу. Допустимые значения\n                          \\ref MDBX_NEXT, \\ref MDBX_NEXT_DUP,\n                          \\ref MDBX_NEXT_NODUP, \\ref MDBX_PREV,\n                          \\ref MDBX_PREV_DUP, \\ref MDBX_PREV_NODUP, а также\n                          \\ref MDBX_NEXT_MULTIPLE и \\ref MDBX_PREV_MULTIPLE.\n \\param [in,out] arg      Дополнительный аргумент предикативной функции,\n                          который полностью подготавливается\n                          и контролируется вами.\n\n \\note При использовании \\ref MDBX_GET_MULTIPLE, \\ref MDBX_NEXT_MULTIPLE\n или \\ref MDBX_PREV_MULTIPLE внимательно учитывайте пакетную специфику\n передачи значений через параметры предикативной функции.\n\n \\see MDBX_predicate_func\n \\see mdbx_cursor_scan_from\n\n \\returns Результат операции сканирования, либо код ошибки.\n\n \\retval MDBX_RESULT_TRUE если найдена пара ключ-значение, для которой\n         предикативная функция вернула \\ref MDBX_RESULT_TRUE.\n \\retval MDBX_RESULT_FALSE если если подходящая пара ключ-значения НЕ найдена,\n         в процессе поиска достигнут конец данных, либо нет данных для поиска.\n \\retval ИНАЧЕ любое другое значение, отличное от \\ref MDBX_RESULT_TRUE\n         и \\ref MDBX_RESULT_FALSE, является кодом ошибки при позиционировании\n         курса, либо определяемым пользователем кодом остановки поиска\n         или ошибочной ситуации."]
    pub fn mdbx_cursor_scan(
        cursor: *mut MDBX_cursor,
        predicate: MDBX_predicate_func,
        context: *mut ::std::os::raw::c_void,
        start_op: MDBX_cursor_op,
        turn_op: MDBX_cursor_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Сканирует таблицу с использованием передаваемого предиката,\n  начиная с передаваемой пары ключ-значение,\n  с уменьшением сопутствующих накладных расходов.\n \\ingroup c_crud\n\n Функция принимает курсор, который должен быть привязан к некоторой транзакции\n и DBI-дескриптору таблицы, выполняет первоначальное позиционирование курсора\n определяемое аргументом `from_op`. а также аргументами `from_key` и\n `from_value`. Далее, производится оценка каждой пары ключ-значения\n посредством предоставляемой вами предикативной функции `predicate` и затем,\n при необходимости, переход к следующему элементу посредством операции\n `turn_op`, до наступления одного из четырех событий:\n  - достигается конец данных;\n  - возникнет ошибка при позиционировании курсора;\n  - оценочная функция вернет \\ref MDBX_RESULT_TRUE, сигнализируя\n    о необходимости остановить дальнейшее сканирование;\n  - оценочная функция возвратит значение отличное от \\ref MDBX_RESULT_FALSE\n    и \\ref MDBX_RESULT_TRUE сигнализируя об ошибке.\n\n \\param [in,out] cursor    Курсор для выполнения операции сканирования,\n                           связанный с активной транзакцией и DBI-дескриптором\n                           таблицы. Например, курсор созданный\n                           посредством \\ref mdbx_cursor_open().\n \\param [in] predicate     Предикативная функция для оценки итерируемых\n                           пар ключ-значения,\n                           более подробно смотрите \\ref MDBX_predicate_func.\n \\param [in,out] context   Указатель на контекст с необходимой для оценки\n                           информацией, который полностью подготавливается\n                           и контролируется вами.\n \\param [in] from_op       Операция позиционирования курсора к исходной\n                           позиции, более подробно смотрите\n                           \\ref MDBX_cursor_op.\n                           Допустимые значения \\ref MDBX_GET_BOTH,\n                           \\ref MDBX_GET_BOTH_RANGE, \\ref MDBX_SET_KEY,\n                           \\ref MDBX_SET_LOWERBOUND, \\ref MDBX_SET_UPPERBOUND,\n                           \\ref MDBX_TO_KEY_LESSER_THAN,\n                           \\ref MDBX_TO_KEY_LESSER_OR_EQUAL,\n                           \\ref MDBX_TO_KEY_EQUAL,\n                           \\ref MDBX_TO_KEY_GREATER_OR_EQUAL,\n                           \\ref MDBX_TO_KEY_GREATER_THAN,\n                           \\ref MDBX_TO_EXACT_KEY_VALUE_LESSER_THAN,\n                           \\ref MDBX_TO_EXACT_KEY_VALUE_LESSER_OR_EQUAL,\n                           \\ref MDBX_TO_EXACT_KEY_VALUE_EQUAL,\n                           \\ref MDBX_TO_EXACT_KEY_VALUE_GREATER_OR_EQUAL,\n                           \\ref MDBX_TO_EXACT_KEY_VALUE_GREATER_THAN,\n                           \\ref MDBX_TO_PAIR_LESSER_THAN,\n                           \\ref MDBX_TO_PAIR_LESSER_OR_EQUAL,\n                           \\ref MDBX_TO_PAIR_EQUAL,\n                           \\ref MDBX_TO_PAIR_GREATER_OR_EQUAL,\n                           \\ref MDBX_TO_PAIR_GREATER_THAN,\n                           а также \\ref MDBX_GET_MULTIPLE.\n \\param [in,out] from_key  Указатель на ключ используемый как для исходного\n                           позиционирования, так и для последующих итераций\n                           перехода.\n \\param [in,out] from_value Указатель на значние используемое как для\n                            исходного позиционирования, так и для последующих\n                            итераций перехода.\n \\param [in] turn_op       Операция позиционирования курсора для перехода\n                           к следующему элементу. Допустимые значения\n                           \\ref MDBX_NEXT, \\ref MDBX_NEXT_DUP,\n                           \\ref MDBX_NEXT_NODUP, \\ref MDBX_PREV,\n                           \\ref MDBX_PREV_DUP, \\ref MDBX_PREV_NODUP, а также\n                           \\ref MDBX_NEXT_MULTIPLE и \\ref MDBX_PREV_MULTIPLE.\n \\param [in,out] arg       Дополнительный аргумент предикативной функции,\n                           который полностью подготавливается\n                           и контролируется вами.\n\n \\note При использовании \\ref MDBX_GET_MULTIPLE, \\ref MDBX_NEXT_MULTIPLE\n или \\ref MDBX_PREV_MULTIPLE внимательно учитывайте пакетную специфику\n передачи значений через параметры предикативной функции.\n\n \\see MDBX_predicate_func\n \\see mdbx_cursor_scan\n\n \\returns Результат операции сканирования, либо код ошибки.\n\n \\retval MDBX_RESULT_TRUE если найдена пара ключ-значение, для которой\n         предикативная функция вернула \\ref MDBX_RESULT_TRUE.\n \\retval MDBX_RESULT_FALSE если если подходящая пара ключ-значения НЕ найдена,\n         в процессе поиска достигнут конец данных, либо нет данных для поиска.\n \\retval ИНАЧЕ любое другое значение, отличное от \\ref MDBX_RESULT_TRUE\n         и \\ref MDBX_RESULT_FALSE, является кодом ошибки при позиционировании\n         курса, либо определяемым пользователем кодом остановки поиска\n         или ошибочной ситуации."]
    pub fn mdbx_cursor_scan_from(
        cursor: *mut MDBX_cursor,
        predicate: MDBX_predicate_func,
        context: *mut ::std::os::raw::c_void,
        from_op: MDBX_cursor_op,
        from_key: *mut MDBX_val,
        from_value: *mut MDBX_val,
        turn_op: MDBX_cursor_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Retrieve multiple non-dupsort key/value pairs by cursor.\n \\ingroup c_crud\n\n This function retrieves multiple key/data pairs from the table without\n \\ref MDBX_DUPSORT option. For `MDBX_DUPSORT` tables please\n use \\ref MDBX_GET_MULTIPLE and \\ref MDBX_NEXT_MULTIPLE.\n\n The number of key and value items is returned in the `size_t count`\n refers. The addresses and lengths of the keys and values are returned in the\n array to which `pairs` refers.\n \\see mdbx_cursor_get()\n\n \\note The memory pointed to by the returned values is owned by the\n database. The caller MUST not dispose of the memory, and MUST not modify it\n in any way regardless in a read-only nor read-write transactions!\n For case a database opened without the \\ref MDBX_WRITEMAP modification\n attempts likely will cause a `SIGSEGV`. However, when a database opened with\n the \\ref MDBX_WRITEMAP or in case values returned inside read-write\n transaction are located on a \"dirty\" (modified and pending to commit) pages,\n such modification will silently accepted and likely will lead to DB and/or\n data corruption.\n\n \\param [in] cursor     A cursor handle returned by \\ref mdbx_cursor_open().\n \\param [out] count     The number of key and value item returned, on success\n                        it always be the even because the key-value\n                        pairs are returned.\n \\param [in,out] pairs  A pointer to the array of key value pairs.\n \\param [in] limit      The size of pairs buffer as the number of items,\n                        but not a pairs.\n \\param [in] op         A cursor operation \\ref MDBX_cursor_op (only\n                        \\ref MDBX_FIRST and \\ref MDBX_NEXT are supported).\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_NOTFOUND         No any key-value pairs are available.\n \\retval MDBX_ENODATA          The cursor is already at the end of data.\n \\retval MDBX_RESULT_TRUE      The returned chunk is the last one,\n                               and there are no pairs left.\n \\retval MDBX_EINVAL           An invalid parameter was specified."]
    pub fn mdbx_cursor_get_batch(
        cursor: *mut MDBX_cursor,
        count: *mut usize,
        pairs: *mut MDBX_val,
        limit: usize,
        op: MDBX_cursor_op,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Store by cursor.\n \\ingroup c_crud\n\n This function stores key/data pairs into the table. The cursor is\n positioned at the new item, or on failure usually near it.\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n \\param [in] key       The key operated on.\n \\param [in,out] data  The data operated on.\n \\param [in] flags     Options for this operation. This parameter\n                       must be set to 0 or by bitwise OR'ing together\n                       one or more of the values described here:\n  - \\ref MDBX_CURRENT\n      Replace the item at the current cursor position. The key parameter\n      must still be provided, and must match it, otherwise the function\n      return \\ref MDBX_EKEYMISMATCH. With combination the\n      \\ref MDBX_ALLDUPS will replace all multi-values.\n\n      \\note MDBX allows (unlike LMDB) you to change the size of the data and\n      automatically handles reordering for sorted duplicates\n      (see \\ref MDBX_DUPSORT).\n\n  - \\ref MDBX_NODUPDATA\n      Enter the new key-value pair only if it does not already appear in the\n      table. This flag may only be specified if the table was opened\n      with \\ref MDBX_DUPSORT. The function will return \\ref MDBX_KEYEXIST\n      if the key/data pair already appears in the table.\n\n  - \\ref MDBX_NOOVERWRITE\n      Enter the new key/data pair only if the key does not already appear\n      in the table. The function will return \\ref MDBX_KEYEXIST if the key\n      already appears in the table, even if the table supports\n      duplicates (\\ref MDBX_DUPSORT).\n\n  - \\ref MDBX_RESERVE\n      Reserve space for data of the given size, but don't copy the given\n      data. Instead, return a pointer to the reserved space, which the\n      caller can fill in later - before the next update operation or the\n      transaction ends. This saves an extra memcpy if the data is being\n      generated later. This flag must not be specified if the table\n      was opened with \\ref MDBX_DUPSORT.\n\n  - \\ref MDBX_APPEND\n      Append the given key/data pair to the end of the table. No key\n      comparisons are performed. This option allows fast bulk loading when\n      keys are already known to be in the correct order. Loading unsorted\n      keys with this flag will cause a \\ref MDBX_KEYEXIST error.\n\n  - \\ref MDBX_APPENDDUP\n      As above, but for sorted dup data.\n\n  - \\ref MDBX_MULTIPLE\n      Store multiple contiguous data elements in a single request. This flag\n      may only be specified if the table was opened with\n      \\ref MDBX_DUPFIXED. With combination the \\ref MDBX_ALLDUPS\n      will replace all multi-values.\n      The data argument must be an array of two \\ref MDBX_val. The `iov_len`\n      of the first \\ref MDBX_val must be the size of a single data element.\n      The `iov_base` of the first \\ref MDBX_val must point to the beginning\n      of the array of contiguous data elements which must be properly aligned\n      in case of table with \\ref MDBX_INTEGERDUP flag.\n      The `iov_len` of the second \\ref MDBX_val must be the count of the\n      number of data elements to store. On return this field will be set to\n      the count of the number of elements actually written. The `iov_base` of\n      the second \\ref MDBX_val is unused.\n\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EKEYMISMATCH  The given key value is mismatched to the current\n                            cursor position\n \\retval MDBX_MAP_FULL      The database is full,\n                             see \\ref mdbx_env_set_mapsize().\n \\retval MDBX_TXN_FULL      The transaction has too many dirty pages.\n \\retval MDBX_EACCES        An attempt was made to write in a read-only\n                            transaction.\n \\retval MDBX_EINVAL        An invalid parameter was specified."]
    pub fn mdbx_cursor_put(
        cursor: *mut MDBX_cursor,
        key: *const MDBX_val,
        data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Delete current key/data pair.\n \\ingroup c_crud\n\n This function deletes the key/data pair to which the cursor refers. This\n does not invalidate the cursor, so operations such as \\ref MDBX_NEXT can\n still be used on it. Both \\ref MDBX_NEXT and \\ref MDBX_GET_CURRENT will\n return the same record after this operation.\n\n \\param [in] cursor  A cursor handle returned by mdbx_cursor_open().\n \\param [in] flags   Options for this operation. This parameter must be set\n to one of the values described here.\n\n  - \\ref MDBX_CURRENT Delete only single entry at current cursor position.\n  - \\ref MDBX_ALLDUPS\n    or \\ref MDBX_NODUPDATA (supported for compatibility)\n      Delete all of the data items for the current key. This flag has effect\n      only for table(s) was created with \\ref MDBX_DUPSORT.\n\n \\see \\ref c_crud_hints \"Quick reference for Insert/Update/Delete operations\"\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_MAP_FULL      The database is full,\n                            see \\ref mdbx_env_set_mapsize().\n \\retval MDBX_TXN_FULL      The transaction has too many dirty pages.\n \\retval MDBX_EACCES        An attempt was made to write in a read-only\n                            transaction.\n \\retval MDBX_EINVAL        An invalid parameter was specified."]
    pub fn mdbx_cursor_del(
        cursor: *mut MDBX_cursor,
        flags: MDBX_put_flags_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Return count values (aka duplicates) for current key.\n \\ingroup c_crud\n\n \\see mdbx_cursor_count_ex\n\n This call is valid for all tables, but reasonable only for that support\n sorted duplicate data items \\ref MDBX_DUPSORT.\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n \\param [out] count    Address where the count will be stored.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL   Cursor is not initialized, or an invalid parameter\n                       was specified."]
    pub fn mdbx_cursor_count(
        cursor: *const MDBX_cursor,
        count: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Return count values (aka duplicates) and nested b-tree statistics for current key.\n \\ingroup c_crud\n\n \\see mdbx_dbi_stat\n \\see mdbx_dbi_dupsort_depthmask\n \\see mdbx_cursor_count\n\n This call is valid for all tables, but reasonable only for that support\n sorted duplicate data items \\ref MDBX_DUPSORT.\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n \\param [out] count    Address where the count will be stored.\n \\param [out] stat     The address of an \\ref MDBX_stat structure where\n                       the statistics of a nested b-tree will be copied.\n \\param [in] bytes     The size of \\ref MDBX_stat.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned\n                               by current thread.\n \\retval MDBX_EINVAL   Cursor is not initialized, or an invalid parameter\n                       was specified."]
    pub fn mdbx_cursor_count_ex(
        cursor: *const MDBX_cursor,
        count: *mut usize,
        stat: *mut MDBX_stat,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Determines whether the cursor is pointed to a key-value pair or not,\n i.e. was not positioned or points to the end of data.\n \\ingroup c_cursors\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n\n \\returns A \\ref MDBX_RESULT_TRUE or \\ref MDBX_RESULT_FALSE value,\n          otherwise the error code.\n \\retval MDBX_RESULT_TRUE    No more data available or cursor not\n                             positioned\n \\retval MDBX_RESULT_FALSE   A data is available\n \\retval Otherwise the error code"]
    pub fn mdbx_cursor_eof(cursor: *const MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Determines whether the cursor is pointed to the first key-value pair\n or not.\n \\ingroup c_cursors\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n\n \\returns A MDBX_RESULT_TRUE or MDBX_RESULT_FALSE value,\n          otherwise the error code.\n \\retval MDBX_RESULT_TRUE   Cursor positioned to the first key-value pair\n \\retval MDBX_RESULT_FALSE  Cursor NOT positioned to the first key-value\n pair \\retval Otherwise the error code"]
    pub fn mdbx_cursor_on_first(cursor: *const MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Определяет стоит ли курсор на первом или единственном\n мульти-значении соответствующем ключу.\n \\ingroup c_cursors\n \\param [in] cursor    Курсор созданный посредством \\ref mdbx_cursor_open().\n \\returns Значание \\ref MDBX_RESULT_TRUE, либо \\ref MDBX_RESULT_FALSE,\n          иначе код ошибки.\n \\retval MDBX_RESULT_TRUE   курсор установлен на первом или единственном\n                            мульти-значении соответствующем ключу.\n \\retval MDBX_RESULT_FALSE  курсор НЕ установлен на первом или единственном\n                            мульти-значении соответствующем ключу.\n \\retval ИНАЧЕ код ошибки."]
    pub fn mdbx_cursor_on_first_dup(cursor: *const MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Determines whether the cursor is pointed to the last key-value pair\n or not.\n \\ingroup c_cursors\n\n \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open().\n\n \\returns A \\ref MDBX_RESULT_TRUE or \\ref MDBX_RESULT_FALSE value,\n          otherwise the error code.\n \\retval MDBX_RESULT_TRUE   Cursor positioned to the last key-value pair\n \\retval MDBX_RESULT_FALSE  Cursor NOT positioned to the last key-value pair\n \\retval Otherwise the error code"]
    pub fn mdbx_cursor_on_last(cursor: *const MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Определяет стоит ли курсор на последнем или единственном\n мульти-значении соответствующем ключу.\n \\ingroup c_cursors\n \\param [in] cursor    Курсор созданный посредством \\ref mdbx_cursor_open().\n \\returns Значание \\ref MDBX_RESULT_TRUE, либо \\ref MDBX_RESULT_FALSE,\n          иначе код ошибки.\n \\retval MDBX_RESULT_TRUE   курсор установлен на последнем или единственном\n                            мульти-значении соответствующем ключу.\n \\retval MDBX_RESULT_FALSE  курсор НЕ установлен на последнем или единственном\n                            мульти-значении соответствующем ключу.\n \\retval ИНАЧЕ код ошибки."]
    pub fn mdbx_cursor_on_last_dup(cursor: *const MDBX_cursor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Estimates the distance between cursors as a number of elements.\n \\ingroup c_rqest\n\n This function performs a rough estimate based only on b-tree pages that are\n common for the both cursor's stacks. The results of such estimation can be\n used to build and/or optimize query execution plans.\n\n Please see notes on accuracy of the result in the details\n of \\ref c_rqest section.\n\n Both cursors must be initialized for the same table and the same\n transaction.\n\n \\param [in] first            The first cursor for estimation.\n \\param [in] last             The second cursor for estimation.\n \\param [out] distance_items  The pointer to store estimated distance value,\n                              i.e. `*distance_items = distance(first, last)`.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_estimate_distance(
        first: *const MDBX_cursor,
        last: *const MDBX_cursor,
        distance_items: *mut isize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Estimates the move distance.\n \\ingroup c_rqest\n\n This function performs a rough estimate distance between the current\n cursor position and next position after the specified move-operation with\n given key and data. The results of such estimation can be used to build\n and/or optimize query execution plans. Current cursor position and state are\n preserved.\n\n Please see notes on accuracy of the result in the details\n of \\ref c_rqest section.\n\n \\param [in] cursor            Cursor for estimation.\n \\param [in,out] key           The key for a retrieved item.\n \\param [in,out] data          The data of a retrieved item.\n \\param [in] move_op           A cursor operation \\ref MDBX_cursor_op.\n \\param [out] distance_items   A pointer to store estimated move distance\n                               as the number of elements.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_estimate_move(
        cursor: *const MDBX_cursor,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
        move_op: MDBX_cursor_op,
        distance_items: *mut isize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Estimates the size of a range as a number of elements.\n \\ingroup c_rqest\n\n The results of such estimation can be used to build and/or optimize query\n execution plans.\n\n Please see notes on accuracy of the result in the details\n of \\ref c_rqest section.\n\n\n \\param [in] txn        A transaction handle returned\n                        by \\ref mdbx_txn_begin().\n \\param [in] dbi        A table handle returned by  \\ref mdbx_dbi_open().\n \\param [in] begin_key  The key of range beginning or NULL for explicit FIRST.\n \\param [in] begin_data Optional additional data to seeking among sorted\n                        duplicates.\n                        Only for \\ref MDBX_DUPSORT, NULL otherwise.\n \\param [in] end_key    The key of range ending or NULL for explicit LAST.\n \\param [in] end_data   Optional additional data to seeking among sorted\n                        duplicates.\n                        Only for \\ref MDBX_DUPSORT, NULL otherwise.\n \\param [out] distance_items  A pointer to store range estimation result.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_estimate_range(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        begin_key: *const MDBX_val,
        begin_data: *const MDBX_val,
        end_key: *const MDBX_val,
        end_data: *const MDBX_val,
        distance_items: *mut isize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Determines whether the given address is on a dirty database page of\n the transaction or not.\n \\ingroup c_statinfo\n\n Ultimately, this allows to avoid copy data from non-dirty pages.\n\n \"Dirty\" pages are those that have already been changed during a write\n transaction. Accordingly, any further changes may result in such pages being\n overwritten. Therefore, all functions libmdbx performing changes inside the\n database as arguments should NOT get pointers to data in those pages. In\n turn, \"not dirty\" pages before modification will be copied.\n\n In other words, data from dirty pages must either be copied before being\n passed as arguments for further processing or rejected at the argument\n validation stage. Thus, `mdbx_is_dirty()` allows you to get rid of\n unnecessary copying, and perform a more complete check of the arguments.\n\n \\note The address passed must point to the beginning of the data. This is\n the only way to ensure that the actual page header is physically located in\n the same memory page, including for multi-pages with long data.\n\n \\note In rare cases the function may return a false positive answer\n (\\ref MDBX_RESULT_TRUE when data is NOT on a dirty page), but never a false\n negative if the arguments are correct.\n\n \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] ptr      The address of data to check.\n\n \\returns A MDBX_RESULT_TRUE or MDBX_RESULT_FALSE value,\n          otherwise the error code.\n \\retval MDBX_RESULT_TRUE    Given address is on the dirty page.\n \\retval MDBX_RESULT_FALSE   Given address is NOT on the dirty page.\n \\retval Otherwise the error code."]
    pub fn mdbx_is_dirty(
        txn: *const MDBX_txn,
        ptr: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Sequence generation for a table.\n \\ingroup c_crud\n\n The function allows to create a linear sequence of unique positive integers\n for each table. The function can be called for a read transaction to\n retrieve the current sequence value, and the increment must be zero.\n Sequence changes become visible outside the current write transaction after\n it is committed, and discarded on abort.\n\n \\param [in] txn        A transaction handle returned\n                        by \\ref mdbx_txn_begin().\n \\param [in] dbi        A table handle returned by \\ref mdbx_dbi_open().\n \\param [out] result    The optional address where the value of sequence\n                        before the change will be stored.\n \\param [in] increment  Value to increase the sequence,\n                        must be 0 for read-only transactions.\n\n \\returns A non-zero error value on failure and 0 on success,\n          some possible errors are:\n \\retval MDBX_RESULT_TRUE   Increasing the sequence has resulted in an\n                            overflow and therefore cannot be executed."]
    pub fn mdbx_dbi_sequence(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        result: *mut u64,
        increment: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Compare two keys according to a particular table.\n \\ingroup c_crud\n \\see MDBX_cmp_func\n\n This returns a comparison as if the two data items were keys in the\n specified table.\n\n \\warning There is a Undefined behavior if one of arguments is invalid.\n\n \\param [in] txn   A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi   A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] a     The first item to compare.\n \\param [in] b     The second item to compare.\n\n \\returns < 0 if a < b, 0 if a == b, > 0 if a > b"]
    pub fn mdbx_cmp(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        a: *const MDBX_val,
        b: *const MDBX_val,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns default internal key's comparator for given table flags.\n \\ingroup c_extra"]
    pub fn mdbx_get_keycmp(flags: MDBX_db_flags_t) -> MDBX_cmp_func;
}
unsafe extern "C" {
    #[doc = " \\brief Compare two data items according to a particular table.\n \\ingroup c_crud\n \\see MDBX_cmp_func\n\n This returns a comparison as if the two items were data items of the\n specified table.\n\n \\warning There is a Undefined behavior if one of arguments is invalid.\n\n \\param [in] txn   A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [in] dbi   A table handle returned by \\ref mdbx_dbi_open().\n \\param [in] a     The first item to compare.\n \\param [in] b     The second item to compare.\n\n \\returns < 0 if a < b, 0 if a == b, > 0 if a > b"]
    pub fn mdbx_dcmp(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        a: *const MDBX_val,
        b: *const MDBX_val,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns default internal data's comparator for given table flags\n \\ingroup c_extra"]
    pub fn mdbx_get_datacmp(flags: MDBX_db_flags_t) -> MDBX_cmp_func;
}
#[doc = " \\brief A callback function used to enumerate the reader lock table.\n \\ingroup c_statinfo\n\n \\param [in] ctx            An arbitrary context pointer for the callback.\n \\param [in] num            The serial number during enumeration,\n                            starting from 1.\n \\param [in] slot           The reader lock table slot number.\n \\param [in] txnid          The ID of the transaction being read,\n                            i.e. the MVCC-snapshot number.\n \\param [in] lag            The lag from a recent MVCC-snapshot,\n                            i.e. the number of committed write transactions\n                            since the current read transaction started.\n \\param [in] pid            The reader process ID.\n \\param [in] thread         The reader thread ID.\n \\param [in] bytes_used     The number of last used page\n                            in the MVCC-snapshot which being read,\n                            i.e. database file can't be shrunk beyond this.\n \\param [in] bytes_retained The total size of the database pages that were\n                            retired by committed write transactions after\n                            the reader's MVCC-snapshot,\n                            i.e. the space which would be freed after\n                            the Reader releases the MVCC-snapshot\n                            for reuse by completion read transaction.\n\n \\returns < 0 on failure, >= 0 on success. \\see mdbx_reader_list()"]
pub type MDBX_reader_list_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        slot: ::std::os::raw::c_int,
        pid: mdbx_pid_t,
        thread: mdbx_tid_t,
        txnid: u64,
        lag: u64,
        bytes_used: usize,
        bytes_retained: usize,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " \\brief Enumerate the entries in the reader lock table.\n\n \\ingroup c_statinfo\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n \\param [in] func    A \\ref MDBX_reader_list_func function.\n \\param [in] ctx     An arbitrary context pointer for the enumeration\n                     function.\n\n \\returns A non-zero error value on failure and 0 on success,\n or \\ref MDBX_RESULT_TRUE if the reader lock table is empty."]
    pub fn mdbx_reader_list(
        env: *const MDBX_env,
        func: MDBX_reader_list_func,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Check for stale entries in the reader lock table.\n \\ingroup c_extra\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n \\param [out] dead   Number of stale slots that were cleared.\n\n \\returns A non-zero error value on failure and 0 on success,\n or \\ref MDBX_RESULT_TRUE if a dead reader(s) found or mutex was recovered."]
    pub fn mdbx_reader_check(
        env: *mut MDBX_env,
        dead: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Returns a lag of the reading for the given transaction.\n \\ingroup c_statinfo\n\n Returns an information for estimate how much given read-only\n transaction is lagging relative the to actual head.\n \\deprecated Please use \\ref mdbx_txn_info() instead.\n\n \\param [in] txn       A transaction handle returned by \\ref mdbx_txn_begin().\n \\param [out] percent  Percentage of page allocation in the database.\n\n \\returns Number of transactions committed after the given was started for\n          read, or negative value on failure."]
    pub fn mdbx_txn_straggler(
        txn: *const MDBX_txn,
        percent: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Registers the current thread as a reader for the environment.\n \\ingroup c_extra\n\n To perform read operations without blocking, a reader slot must be assigned\n for each thread. However, this assignment requires a short-term lock\n acquisition which is performed automatically. This function allows you to\n assign the reader slot in advance and thus avoid capturing the blocker when\n the read transaction starts firstly from current thread.\n \\see mdbx_thread_unregister()\n\n \\note Threads are registered automatically the first time a read transaction\n       starts. Therefore, there is no need to use this function, except in\n       special cases.\n\n \\param [in] env   An environment handle returned by \\ref mdbx_env_create().\n\n \\returns A non-zero error value on failure and 0 on success,\n or \\ref MDBX_RESULT_TRUE if thread is already registered."]
    pub fn mdbx_thread_register(env: *const MDBX_env) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Unregisters the current thread as a reader for the environment.\n \\ingroup c_extra\n\n To perform read operations without blocking, a reader slot must be assigned\n for each thread. However, the assigned reader slot will remain occupied until\n the thread ends or the environment closes. This function allows you to\n explicitly release the assigned reader slot.\n \\see mdbx_thread_register()\n\n \\param [in] env   An environment handle returned by \\ref mdbx_env_create().\n\n \\returns A non-zero error value on failure and 0 on success, or\n \\ref MDBX_RESULT_TRUE if thread is not registered or already unregistered."]
    pub fn mdbx_thread_unregister(env: *const MDBX_env) -> ::std::os::raw::c_int;
}
#[doc = " \\brief A Handle-Slow-Readers callback function to resolve database\n full/overflow issue due to a reader(s) which prevents the old data from being\n recycled.\n \\ingroup c_err\n\n Read transactions prevent reuse of pages freed by newer write transactions,\n thus the database can grow quickly. This callback will be called when there\n is not enough space in the database (i.e. before increasing the database size\n or before \\ref MDBX_MAP_FULL error) and thus can be used to resolve issues\n with a \"long-lived\" read transactions.\n \\see mdbx_env_set_hsr()\n \\see mdbx_env_get_hsr()\n \\see mdbx_txn_park()\n \\see <a href=\"intro.html#long-lived-read\">Long-lived read transactions</a>\n\n Using this callback you can choose how to resolve the situation:\n   - abort the write transaction with an error;\n   - wait for the read transaction(s) to complete;\n   - notify a thread performing a long-lived read transaction\n     and wait for an effect;\n   - kill the thread or whole process that performs the long-lived read\n     transaction;\n\n Depending on the arguments and needs, your implementation may wait,\n terminate a process or thread that is performing a long read, or perform\n some other action. In doing so it is important that the returned code always\n corresponds to the performed action.\n\n \\param [in] env     An environment handle returned by \\ref mdbx_env_create().\n \\param [in] txn     The current write transaction which internally at\n                     the \\ref MDBX_MAP_FULL condition.\n \\param [in] pid     A pid of the reader process.\n \\param [in] tid     A thread_id of the reader thread.\n \\param [in] laggard An oldest read transaction number on which stalled.\n \\param [in] gap     A lag from the last committed txn.\n \\param [in] space   A space that actually become available for reuse after\n                     this reader finished. The callback function can take\n                     this value into account to evaluate the impact that\n                     a long-running transaction has.\n \\param [in] retry   A retry number starting from 0.\n                     If callback has returned 0 at least once, then at end of\n                     current handling loop the callback function will be\n                     called additionally with negative `retry` value to notify\n                     about the end of loop. The callback function can use this\n                     fact to implement timeout reset logic while waiting for\n                     a readers.\n\n \\returns The RETURN CODE determines the further actions libmdbx and must\n          match the action which was executed by the callback:\n\n \\retval -2 or less  An error condition and the reader was not killed.\n\n \\retval -1          The callback was unable to solve the problem and\n                     agreed on \\ref MDBX_MAP_FULL error;\n                     libmdbx should increase the database size or\n                     return \\ref MDBX_MAP_FULL error.\n\n \\retval 0 (zero)    The callback solved the problem or just waited for\n                     a while, libmdbx should rescan the reader lock table and\n                     retry. This also includes a situation when corresponding\n                     transaction terminated in normal way by\n                     \\ref mdbx_txn_abort() or \\ref mdbx_txn_reset(),\n                     and my be restarted. I.e. reader slot don't needed\n                     to be cleaned from transaction.\n\n \\retval 1           Transaction aborted asynchronous and reader slot\n                     should be cleared immediately, i.e. read transaction\n                     will not continue but \\ref mdbx_txn_abort()\n                     nor \\ref mdbx_txn_reset() will be called later.\n\n \\retval 2 or great  The reader process was terminated or killed,\n                     and libmdbx should entirely reset reader registration."]
pub type MDBX_hsr_func = ::std::option::Option<
    unsafe extern "C" fn(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        pid: mdbx_pid_t,
        tid: mdbx_tid_t,
        laggard: u64,
        gap: ::std::os::raw::c_uint,
        space: usize,
        retry: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " \\brief Sets a Handle-Slow-Readers callback to resolve database full/overflow\n issue due to a reader(s) which prevents the old data from being recycled.\n \\ingroup c_err\n\n The callback will only be triggered when the database is full due to a\n reader(s) prevents the old data from being recycled.\n\n \\see MDBX_hsr_func\n \\see mdbx_env_get_hsr()\n \\see mdbx_txn_park()\n \\see <a href=\"intro.html#long-lived-read\">Long-lived read transactions</a>\n\n \\param [in] env             An environment handle returned\n                             by \\ref mdbx_env_create().\n \\param [in] hsr_callback    A \\ref MDBX_hsr_func function\n                             or NULL to disable.\n\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_hsr(
        env: *mut MDBX_env,
        hsr_callback: MDBX_hsr_func,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Gets current Handle-Slow-Readers callback used to resolve database\n full/overflow issue due to a reader(s) which prevents the old data from being\n recycled.\n \\see MDBX_hsr_func\n \\see mdbx_env_set_hsr()\n \\see mdbx_txn_park()\n \\see <a href=\"intro.html#long-lived-read\">Long-lived read transactions</a>\n\n \\param [in] env   An environment handle returned by \\ref mdbx_env_create().\n\n \\returns A MDBX_hsr_func function or NULL if disabled\n          or something wrong."]
    pub fn mdbx_env_get_hsr(env: *const MDBX_env) -> MDBX_hsr_func;
}
unsafe extern "C" {
    #[doc = " \\brief Acquires write-transaction lock.\n Provided for custom and/or complex locking scenarios.\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_lock(env: *mut MDBX_env, dont_wait: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Releases write-transaction lock.\n Provided for custom and/or complex locking scenarios.\n \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_unlock(env: *mut MDBX_env) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Open an environment instance using specific meta-page\n for checking and recovery.\n\n This function mostly of internal API for `mdbx_chk` utility and subject to\n change at any time. Do not use this function to avoid shooting your own\n leg(s).\n\n \\note On Windows the \\ref mdbx_env_open_for_recoveryW() is recommended\n to use."]
    pub fn mdbx_env_open_for_recovery(
        env: *mut MDBX_env,
        pathname: *const ::std::os::raw::c_char,
        target_meta: ::std::os::raw::c_uint,
        writeable: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_env_open_for_recovery()\n \\ingroup c_extra\n \\note Available only on Windows.\n \\see mdbx_env_open_for_recovery()"]
    pub fn mdbx_env_open_for_recoveryW(
        env: *mut MDBX_env,
        pathname: *const u16,
        target_meta: ::std::os::raw::c_uint,
        writeable: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Turn database to the specified meta-page.\n\n This function mostly of internal API for `mdbx_chk` utility and subject to\n change at any time. Do not use this function to avoid shooting your own\n leg(s)."]
    pub fn mdbx_env_turn_for_recovery(
        env: *mut MDBX_env,
        target_meta: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Получает базовую информацию о БД не открывая её.\n \\ingroup c_opening\n\n Назначение функции в получении базовой информации без открытия БД и\n отображения данных в память (что может быть достаточно затратным действием\n для ядра ОС). Полученная таким образом информация может быть полезной для\n подстройки опций работы с БД перед её открытием, а также в сценариях файловых\n менеджерах и прочих вспомогательных утилитах.\n\n \\todo Добавить в API возможность установки обратного вызова для ревизии опций\n       работы с БД в процессе её открытия (при удержании блокировок).\n\n \\param [in]  pathname  Путь к директории или файлу БД.\n \\param [out] info      Указатель на структуру \\ref MDBX_envinfo\n                        для получения информации.\n \\param [in] bytes      Актуальный размер структуры \\ref MDBX_envinfo, это\n                        значение используется для обеспечения совместимости\n                        ABI.\n\n \\note Заполняется только некоторые поля структуры \\ref MDBX_envinfo, значения\n которых возможно получить без отображения файлов БД в память и без захвата\n блокировок: размер страницы БД, геометрия БД, размер распределенного места\n (номер последней распределенной страницы), номер последней транзакции и\n boot-id.\n\n \\warning Полученная информация является снимком на время выполнения функции и\n может быть в любой момент изменена работающим с БД процессом. В том числе,\n нет препятствий к тому, чтобы другой процесс удалил БД и создал её заново с\n другим размером страницы и/или изменением любых других параметров.\n\n \\returns Ненулевое значение кода ошибки, либо 0 при успешном выполнении."]
    pub fn mdbx_preopen_snapinfo(
        pathname: *const ::std::os::raw::c_char,
        info: *mut MDBX_envinfo,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc mdbx_preopen_snapinfo()\n \\ingroup c_opening\n \\note Available only on Windows.\n \\see mdbx_preopen_snapinfo()"]
    pub fn mdbx_preopen_snapinfoW(
        pathname: *const u16,
        info: *mut MDBX_envinfo,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Режим проверки по-умолчанию, в том числе в режиме только-чтения."]
pub const MDBX_chk_flags_MDBX_CHK_DEFAULTS: MDBX_chk_flags = 0;
#[doc = " Проверка в режиме чтения-записи, с захватом блокировки и приостановки\n пишущих транзакций."]
pub const MDBX_chk_flags_MDBX_CHK_READWRITE: MDBX_chk_flags = 1;
#[doc = " Пропустить обход дерева страниц."]
pub const MDBX_chk_flags_MDBX_CHK_SKIP_BTREE_TRAVERSAL: MDBX_chk_flags = 2;
#[doc = " Пропустить просмотр записей ключ-значение."]
pub const MDBX_chk_flags_MDBX_CHK_SKIP_KV_TRAVERSAL: MDBX_chk_flags = 4;
#[doc = " Игнорировать порядок ключей и записей.\n \\note Требуется при проверке унаследованных БД созданных с использованием\n нестандартных (пользовательских) функций сравнения ключей или значений."]
pub const MDBX_chk_flags_MDBX_CHK_IGNORE_ORDER: MDBX_chk_flags = 8;
#[doc = " \\brief Флаги/опции для проверки целостности базы данных.\n \\note Данный API еще не зафиксирован, в последующих версиях могут быть\n незначительные доработки и изменения.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_flags = ::std::os::raw::c_int;
#[doc = " \\brief Флаги/опции для проверки целостности базы данных.\n \\note Данный API еще не зафиксирован, в последующих версиях могут быть\n незначительные доработки и изменения.\n \\see mdbx_env_chk()"]
pub use self::MDBX_chk_flags as MDBX_chk_flags_t;
pub const MDBX_chk_severity_MDBX_chk_severity_prio_shift: MDBX_chk_severity = 4;
pub const MDBX_chk_severity_MDBX_chk_severity_kind_mask: MDBX_chk_severity = 15;
pub const MDBX_chk_severity_MDBX_chk_fatal: MDBX_chk_severity = 0;
pub const MDBX_chk_severity_MDBX_chk_error: MDBX_chk_severity = 17;
pub const MDBX_chk_severity_MDBX_chk_warning: MDBX_chk_severity = 34;
pub const MDBX_chk_severity_MDBX_chk_notice: MDBX_chk_severity = 51;
pub const MDBX_chk_severity_MDBX_chk_result: MDBX_chk_severity = 68;
pub const MDBX_chk_severity_MDBX_chk_resolution: MDBX_chk_severity = 85;
pub const MDBX_chk_severity_MDBX_chk_processing: MDBX_chk_severity = 86;
pub const MDBX_chk_severity_MDBX_chk_info: MDBX_chk_severity = 103;
pub const MDBX_chk_severity_MDBX_chk_verbose: MDBX_chk_severity = 120;
pub const MDBX_chk_severity_MDBX_chk_details: MDBX_chk_severity = 137;
pub const MDBX_chk_severity_MDBX_chk_extra: MDBX_chk_severity = 154;
#[doc = " \\brief Уровни логирование/детализации информации,\n поставляемой через обратные вызовы при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_severity = ::std::os::raw::c_int;
#[doc = " \\brief Уровни логирование/детализации информации,\n поставляемой через обратные вызовы при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub use self::MDBX_chk_severity as MDBX_chk_severity_t;
pub const MDBX_chk_stage_MDBX_chk_none: MDBX_chk_stage = 0;
pub const MDBX_chk_stage_MDBX_chk_init: MDBX_chk_stage = 1;
pub const MDBX_chk_stage_MDBX_chk_lock: MDBX_chk_stage = 2;
pub const MDBX_chk_stage_MDBX_chk_meta: MDBX_chk_stage = 3;
pub const MDBX_chk_stage_MDBX_chk_tree: MDBX_chk_stage = 4;
pub const MDBX_chk_stage_MDBX_chk_gc: MDBX_chk_stage = 5;
pub const MDBX_chk_stage_MDBX_chk_space: MDBX_chk_stage = 6;
pub const MDBX_chk_stage_MDBX_chk_maindb: MDBX_chk_stage = 7;
pub const MDBX_chk_stage_MDBX_chk_tables: MDBX_chk_stage = 8;
pub const MDBX_chk_stage_MDBX_chk_conclude: MDBX_chk_stage = 9;
pub const MDBX_chk_stage_MDBX_chk_unlock: MDBX_chk_stage = 10;
pub const MDBX_chk_stage_MDBX_chk_finalize: MDBX_chk_stage = 11;
#[doc = " \\brief Стадии проверки,\n сообщаемые через обратные вызовы при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_stage = ::std::os::raw::c_int;
#[doc = " \\brief Стадии проверки,\n сообщаемые через обратные вызовы при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub use self::MDBX_chk_stage as MDBX_chk_stage_t;
#[doc = " \\brief Виртуальная строка отчета, формируемого при проверке целостности базы\n данных. \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_chk_line {
    pub ctx: *mut MDBX_chk_context,
    pub severity: u8,
    pub scope_depth: u8,
    pub empty: u8,
    pub begin: *mut ::std::os::raw::c_char,
    pub end: *mut ::std::os::raw::c_char,
    pub out: *mut ::std::os::raw::c_char,
}
impl Default for MDBX_chk_line {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Виртуальная строка отчета, формируемого при проверке целостности базы\n данных. \\see mdbx_env_chk()"]
pub type MDBX_chk_line_t = MDBX_chk_line;
#[doc = " \\brief Проблема обнаруженная при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_chk_issue {
    pub next: *mut MDBX_chk_issue,
    pub count: usize,
    pub caption: *const ::std::os::raw::c_char,
}
impl Default for MDBX_chk_issue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Проблема обнаруженная при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_issue_t = MDBX_chk_issue;
#[doc = " \\brief Иерархический контекст при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MDBX_chk_scope {
    pub issues: *mut MDBX_chk_issue_t,
    pub internal: *mut MDBX_chk_internal,
    pub object: *const ::std::os::raw::c_void,
    pub stage: MDBX_chk_stage_t,
    pub verbosity: MDBX_chk_severity_t,
    pub subtotal_issues: usize,
    pub usr_z: MDBX_chk_scope__bindgen_ty_1,
    pub usr_v: MDBX_chk_scope__bindgen_ty_1,
    pub usr_o: MDBX_chk_scope__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MDBX_chk_scope__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_void,
    pub number: usize,
}
impl Default for MDBX_chk_scope__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for MDBX_chk_scope {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Иерархический контекст при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_scope_t = MDBX_chk_scope;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_chk_user_table_cookie {
    _unused: [u8; 0],
}
#[doc = " \\brief Пользовательский тип для привязки дополнительных данных,\n связанных с некоторой таблицей ключ-значение, при проверке целостности базы\n данных. \\see mdbx_env_chk()"]
pub type MDBX_chk_user_table_cookie_t = MDBX_chk_user_table_cookie;
#[doc = " \\brief Гистограмма с некоторой статистической информацией,\n собираемой при проверке целостности БД.\n \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_chk_histogram {
    pub amount: usize,
    pub count: usize,
    pub ones: usize,
    pub pad: usize,
    pub ranges: [MDBX_chk_histogram__bindgen_ty_1; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_chk_histogram__bindgen_ty_1 {
    pub begin: usize,
    pub end: usize,
    pub amount: usize,
    pub count: usize,
}
#[doc = " \\brief Информация о некоторой таблицей ключ-значение,\n при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_chk_table {
    pub cookie: *mut MDBX_chk_user_table_cookie_t,
    pub name: MDBX_val,
    pub flags: MDBX_db_flags_t,
    pub id: ::std::os::raw::c_int,
    pub payload_bytes: usize,
    pub lost_bytes: usize,
    pub pages: MDBX_chk_table__bindgen_ty_1,
    pub histogram: MDBX_chk_table__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_chk_table__bindgen_ty_1 {
    pub all: usize,
    pub empty: usize,
    pub other: usize,
    pub branch: usize,
    pub leaf: usize,
    pub nested_branch: usize,
    pub nested_leaf: usize,
    pub nested_subleaf: usize,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_chk_table__bindgen_ty_2 {
    #[doc = " Tree deep histogram"]
    pub deep: MDBX_chk_histogram,
    #[doc = " Histogram of large/overflow pages length"]
    pub large_pages: MDBX_chk_histogram,
    #[doc = " Histogram of nested trees height, span length for GC"]
    pub nested_tree: MDBX_chk_histogram,
    #[doc = " Keys length histogram"]
    pub key_len: MDBX_chk_histogram,
    #[doc = " Values length histogram"]
    pub val_len: MDBX_chk_histogram,
}
impl Default for MDBX_chk_table {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Информация о некоторой таблицей ключ-значение,\n при проверке целостности базы данных.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_table_t = MDBX_chk_table;
#[doc = " \\brief Контекст проверки целостности базы данных.\n \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_chk_context {
    pub internal: *mut MDBX_chk_internal,
    pub env: *mut MDBX_env,
    pub txn: *mut MDBX_txn,
    pub scope: *mut MDBX_chk_scope_t,
    pub scope_nesting: u8,
    pub result: MDBX_chk_context__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_chk_context__bindgen_ty_1 {
    pub total_payload_bytes: usize,
    pub table_total: usize,
    pub table_processed: usize,
    pub total_unused_bytes: usize,
    pub unused_pages: usize,
    pub processed_pages: usize,
    pub reclaimable_pages: usize,
    pub gc_pages: usize,
    pub alloc_pages: usize,
    pub backed_pages: usize,
    pub problems_meta: usize,
    pub tree_problems: usize,
    pub gc_tree_problems: usize,
    pub kv_tree_problems: usize,
    pub problems_gc: usize,
    pub problems_kv: usize,
    pub total_problems: usize,
    pub steady_txnid: u64,
    pub recent_txnid: u64,
    #[doc = " Указатель на массив размером table_total с указателями на экземпляры\n структур MDBX_chk_table_t с информацией о всех таблицах ключ-значение,\n включая MainDB и GC/FreeDB."]
    pub tables: *const *const MDBX_chk_table_t,
}
impl Default for MDBX_chk_context__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for MDBX_chk_context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Контекст проверки целостности базы данных.\n \\see mdbx_env_chk()"]
pub type MDBX_chk_context_t = MDBX_chk_context;
#[doc = " \\brief Набор функций обратного вызова используемых при проверке целостности\n базы данных.\n\n Функции обратного вызова предназначены для организации взаимодействия с кодом\n приложения. В том числе, для интеграции логики приложения проверяющей\n целостность стуктуры данных выше уровня ключ-значение, подготовки и\n структурированного вывода информации как о ходе, так и результатов проверки.\n\n Все функции обратного вызова опциональны, неиспользуемые указатели должны\n быть установлены в `nullptr`.\n\n \\note Данный API еще не зафиксирован, в последующих версиях могут быть\n незначительные доработки и изменения.\n\n \\see mdbx_env_chk()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_chk_callbacks {
    pub check_break:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut MDBX_chk_context_t) -> bool>,
    pub scope_push: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            outer: *mut MDBX_chk_scope_t,
            inner: *mut MDBX_chk_scope_t,
            fmt: *const ::std::os::raw::c_char,
            args: va_list,
        ) -> ::std::os::raw::c_int,
    >,
    pub scope_conclude: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            outer: *mut MDBX_chk_scope_t,
            inner: *mut MDBX_chk_scope_t,
            err: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub scope_pop: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            outer: *mut MDBX_chk_scope_t,
            inner: *mut MDBX_chk_scope_t,
        ),
    >,
    pub issue: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            object: *const ::std::os::raw::c_char,
            entry_number: u64,
            issue: *const ::std::os::raw::c_char,
            extra_fmt: *const ::std::os::raw::c_char,
            extra_args: va_list,
        ),
    >,
    pub table_filter: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            name: *const MDBX_val,
            flags: MDBX_db_flags_t,
        ) -> *mut MDBX_chk_user_table_cookie_t,
    >,
    pub table_conclude: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            table: *const MDBX_chk_table_t,
            cursor: *mut MDBX_cursor,
            err: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub table_dispose: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut MDBX_chk_context_t, table: *const MDBX_chk_table_t),
    >,
    pub table_handle_kv: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            table: *const MDBX_chk_table_t,
            entry_number: usize,
            key: *const MDBX_val,
            value: *const MDBX_val,
        ) -> ::std::os::raw::c_int,
    >,
    pub stage_begin: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            arg1: MDBX_chk_stage_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub stage_end: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            arg1: MDBX_chk_stage_t,
            err: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub print_begin: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut MDBX_chk_context_t,
            severity: MDBX_chk_severity_t,
        ) -> *mut MDBX_chk_line_t,
    >,
    pub print_flush: ::std::option::Option<unsafe extern "C" fn(arg1: *mut MDBX_chk_line_t)>,
    pub print_done: ::std::option::Option<unsafe extern "C" fn(arg1: *mut MDBX_chk_line_t)>,
    pub print_chars: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut MDBX_chk_line_t,
            str_: *const ::std::os::raw::c_char,
            len: usize,
        ),
    >,
    pub print_format: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut MDBX_chk_line_t,
            fmt: *const ::std::os::raw::c_char,
            args: va_list,
        ),
    >,
    pub print_size: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut MDBX_chk_line_t,
            prefix: *const ::std::os::raw::c_char,
            value: u64,
            suffix: *const ::std::os::raw::c_char,
        ),
    >,
}
#[doc = " \\brief Набор функций обратного вызова используемых при проверке целостности\n базы данных.\n\n Функции обратного вызова предназначены для организации взаимодействия с кодом\n приложения. В том числе, для интеграции логики приложения проверяющей\n целостность стуктуры данных выше уровня ключ-значение, подготовки и\n структурированного вывода информации как о ходе, так и результатов проверки.\n\n Все функции обратного вызова опциональны, неиспользуемые указатели должны\n быть установлены в `nullptr`.\n\n \\note Данный API еще не зафиксирован, в последующих версиях могут быть\n незначительные доработки и изменения.\n\n \\see mdbx_env_chk()"]
pub type MDBX_chk_callbacks_t = MDBX_chk_callbacks;
unsafe extern "C" {
    #[doc = " \\brief Проверяет целостность базы данных.\n\n Взаимодействие с кодом приложения реализуется через функции обратного вызова,\n предоставляемые приложением посредством параметра `cb`. В ходе такого\n взаимодействия приложение может контролировать ход проверки, в том числе,\n пропускать/фильтровать обработку отдельных элементов, а также реализовать\n дополнительную верификацию структуры и/или информации с учетом назначения и\n семантической значимости для приложения. Например, приложение может выполнить\n проверку собственных индексов и корректность записей в БД. Именно с этой\n целью функционал проверки целостности был доработан для интенсивного\n использования обратных вызовов и перенесен из утилиты `mdbx_chk` в основную\n библиотеку.\n\n Проверка выполняется в несколько стадий, начиная с инициализации и до\n завершения, более подробно см \\ref MDBX_chk_stage_t. О начале и завершении\n каждой стадии код приложения уведомляется через соответствующие функции\n обратного вызова, более подробно см \\ref MDBX_chk_callbacks_t.\n\n \\param [in] env        Указатель на экземпляр среды.\n \\param [in] cb         Набор функций обратного вызова.\n \\param [in,out] ctx    Контекст проверки целостности базы данных,\n                        где будут формироваться результаты проверки.\n \\param [in] flags      Флаги/опции проверки целостности базы данных.\n \\param [in] verbosity  Необходимый уровень детализации информации о ходе\n                        и результатах проверки.\n \\param [in] timeout_seconds_16dot16  Ограничение длительности в 1/65536 долях\n                        секунды для выполнения проверки,\n                        либо 0 при отсутствии ограничения.\n \\returns Нулевое значение в случае успеха, иначе код ошибки."]
    pub fn mdbx_env_chk(
        env: *mut MDBX_env,
        cb: *const MDBX_chk_callbacks_t,
        ctx: *mut MDBX_chk_context_t,
        flags: MDBX_chk_flags_t,
        verbosity: MDBX_chk_severity_t,
        timeout_seconds_16dot16: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Вспомогательная функция для подсчета проблем детектируемых\n приложением, в том числе, поступающим к приложению через логирование.\n \\see mdbx_env_chk()\n \\see MDBX_debug_func\n \\returns Нулевое значение в случае успеха, иначе код ошибки."]
    pub fn mdbx_env_chk_encount_problem(ctx: *mut MDBX_chk_context_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MDBX_chk_internal {
    pub _address: u8,
}
